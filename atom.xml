<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiaoming&#39;s Blog</title>
  
  <subtitle>Share with you IT technology, to achieve progress together.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bxm0927.github.io/"/>
  <updated>2020-05-24T05:06:08.452Z</updated>
  <id>https://bxm0927.github.io/</id>
  
  <author>
    <name>白小明</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Chrome DevTools 调试技巧</title>
    <link href="https://bxm0927.github.io/2020/05/24/chrome-devtools/"/>
    <id>https://bxm0927.github.io/2020/05/24/chrome-devtools/</id>
    <published>2020-05-24T05:06:08.448Z</published>
    <updated>2020-05-24T05:06:08.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="noopener">https://developers.google.com/web/tools/chrome-devtools/</a></li><li><a href="https://juejin.im/book/5c526902e51d4543805ef35e/section/5c5269026fb9a049f1549e4a" target="_blank" rel="noopener">https://juejin.im/book/5c526902e51d4543805ef35e/section/5c5269026fb9a049f1549e4a</a></li></ul><p>工欲善其事必先利其器。</p><p>有些时候一个技巧可以节省我们很多的时间，也会让调试的过程变得更加简单直接。本次分享从不同的情景来说明应该如何搭配使用 Chrome DevTools 中的小技巧，让大家熟练掌握 Chrome 调试技巧，直接提升工作效率。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/9823cde9gy1g50ma3qnorj20pw0dh0t9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><h2 id="关于-Chrome"><a href="#关于-Chrome" class="headerlink" title="关于 Chrome"></a>关于 Chrome</h2><p>谷歌浏览器（通常简称为 Chrome ）是由谷歌开发的网络浏览器。 它于 2008 年首次针对 Microsoft Windows 发布，后来移植到 Linux ，macOS ，iOS 和 Android 。 浏览器也是 Chrome OS 的主要组件，它可以作为 Web 应用的平台。Chrome-wikipedia</p><p>现如今，浏览器的市场已天下三分，Chorme，Safari 和 FireFox，从 2008 年 Chrome 横空出世以来，如今已经一家独大占据了半壁江山：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="B2AAACDFE2124EEE94E2641FA0193037" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="关于-Chrome-DevTools"><a href="#关于-Chrome-DevTools" class="headerlink" title="关于 Chrome DevTools"></a>关于 Chrome DevTools</h2><p>对于大部分人来说，Chrome 可能只是个浏览器，但是对于开发人员来说，它更是一个强大无比的工具，为了方便开发人员调试代码，主流的浏览器都内置了 DevTools， 所以无论你是前端还是后端，掌握 Chrome DevTools 的使用技巧意味着效率直接的提高。</p><h3 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h3><ol><li>F12</li><li>Ctrl + Shift + I (Windows) 或 Cmd + Opt + I (Mac)</li><li>更多工具 &gt; 开发者工具</li><li>在页面元素上右键点击，选择 “检查”</li></ol><h3 id="面板概览"><a href="#面板概览" class="headerlink" title="面板概览"></a>面板概览</h3><p>Chrome DevTools 包含 1 个设备模式和 8 个常见的面板，我们还可以通过插件来增加一些面板（如：Vue-DevTools）</p><p><strong>0. 设备模式 Device Mode</strong></p><p>使用设备模式构建完全响应式，移动优先的网络体验。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="CB84697A18644580B93F27B787274002" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>1. 元素面板 Elements</strong></p><p>使用元素面板可以自由的操作 DOM 和 CSS 来迭代布局和设计页面。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="B3F3B926D46D42EDBF7F84898902B178" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>2. 控制台面板 Console</strong></p><p>在开发期间，可以使用控制台面板记录诊断信息，或者使用它作为 shell 在页面上与 JavaScript 交互。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="35ABFD539A3A4272AC301F693C03E21B" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>3. 源代码面板 Sources</strong></p><p>在源代码面板中设置断点来调试 JavaScript ，或者通过Workspaces（工作区）连接本地文件来使用开发者工具的实时编辑器。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="44E8E8D1617C4872B81D0B25A300A6CC" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>4. 网络面板 Network</strong></p><p>使用网络面板了解请求和下载的资源文件并优化网页加载性能。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="443BE4F9A69340EDB5C4E978492CAFF5" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>5. 性能面板 Performance</strong></p><p>使用性能面板可以通过记录和查看网站生命周期内发生的各种事件来提高页面的运行时性能。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="9595A6FDD8DE49FCA06830196EF86A3E" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>6. 内存面板 Memory</strong></p><p>如果需要比内存面板提供的更多信息，可以使用内存面板，例如跟踪内存泄漏。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="D7F65B18321D43778BB7F3B541FF6C9F" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>7. 应用面板 Application</strong></p><p>使用应用面板可以检查加载的所有资源，包括 IndexedDB 与 Web SQL 数据库，本地和会话存储，cookie，应用程序缓存，图像，字体和样式表。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="46F1EDC7929347A88CA7E412BB421C2B" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>8. 安全面板 Security</strong></p><p>使用安全面板调试混合内容问题，证书问题等等。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="F6F22421759D48C1BCCF201207252E5C" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="实用快捷键"><a href="#实用快捷键" class="headerlink" title="实用快捷键"></a>实用快捷键</h2><p><code>Ctrl + shift + D</code>：把 DevTools 窗口切换到右边、下边</p><p><code>Ctrl + shift + M</code>：切换设备模式</p><p><code>Ctrl + [</code> 和 <code>Ctrl + ]</code>：切换面板</p><p>上下箭头：递增/递减，可配合 Alt、Ctrl、Shift 实现不同的步长（对调整样式特别有用）</p><p><code>Ctrl + F</code>：在 elements， logs， sources 和 network 中查找</p><h2 id="使用-Command"><a href="#使用-Command" class="headerlink" title="使用 Command"></a>使用 Command</h2><p>我们直接可以直接看到的 DevTools 的功能，其实只是有限的一部分，怎么去探索更多的功能呢？</p><p>Command 菜单可以帮助我们快速找到那些被隐藏起来的功能，你可以使用 <code>Ctrl + Shift + P</code> 或 DevTools 的 <code>dropdown</code> 按钮打开 Command。</p><p>Command 包含下列几类命令：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="713B9C0F832643179CBB15769BDFFD41" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>常用的 Command：</p><ul><li>截屏：<code>capture</code></li><li>切换主题：<code>theme</code></li></ul><h2 id="copying"><a href="#copying" class="headerlink" title="copying"></a>copying</h2><p>你可以通过全局的方法 <code>copy()</code> 在 console 里复制任何你能拿到的资源</p><p>例如：<code>copy(location)</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="623FCE5084104E8995A7F7B8ACB28395" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="saving"><a href="#saving" class="headerlink" title="saving"></a>saving</h2><p>如果你在 console 中打印了一堆数据（例如一个大型数组），然后你想对这些数据做一些额外的操作，那就可以将它转换成一个全局变量，只需要右击它，并选择 “<strong>Store as global variable</strong>” (保存为全局变量) 选项。第一次使用的话，它会创建一个名为 temp1 的变量，第二次创建 temp2，以此类推。</p><blockquote><p>注意：得到的 temp$ 的是原数据的引用，操作会影响原数据。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="99C92C3DC2524A77BC929CE893AD007C" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="保存堆栈信息-Stack-trace"><a href="#保存堆栈信息-Stack-trace" class="headerlink" title="保存堆栈信息( Stack trace )"></a>保存堆栈信息( Stack trace )</h2><p>大多数情况下都不是一个人开发一个项目，而是一个团队协作，那么 如何准确的描述问题，就成为了沟通的关键 ，这时候 console 打印出来的堆栈跟踪的信息对你和同事来说就起大作用了，可以省去很多沟通成本，所以你可以直接把堆栈跟踪的信息保存为一个文件，而不只是截图发给对方：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="708C2C028A3240038CFF5CB468241CE4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="Snippets-代码段"><a href="#Snippets-代码段" class="headerlink" title="Snippets 代码段"></a>Snippets 代码段</h2><blockquote><p>如果你需要频繁地在 console 中输入某个代码段，Snippets 功能可能会帮助你。</p></blockquote><p>比如，我想统计网页标签使用数量，评价网页是否语义化，我会把这段脚本赋值 Console 面板：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计网页标签使用数量，评价网页是否语义化的重要指标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTagsMap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...document.querySelectorAll(<span class="string">'*'</span>)].reduce(<span class="function">(<span class="params">a, c</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tagName = c.tagName.toLowerCase()</span><br><span class="line">    a[tagName] = a[tagName] ? a[tagName] + <span class="number">1</span> : <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">getTagsMap()</span><br></pre></td></tr></table></figure><p>现在看来，即使这个脚本并没有花费我太多的精力来编写，但也只是偶尔运行一下，所以对于我来说，记住一段这样的脚本会很麻烦。</p><p>那怎么解决这个问题呢？</p><p>这就是 Snippets 的用武之地：它允许你存放 JavaScript 代码到 DevTools 中，方便你复用这些 JavaScript 代码段：</p><p>进入到 Sources 面板，在导航栏里选中 <code>Snippets</code> 这栏，点击 <code>New snippet</code> 新建一个代码段，然后输入你的代码之后保存就可以 <code>Run</code> 了！</p><blockquote><p>当我在 DevTools 中预设了一组很棒的代段块以后，甚至都不必再通过 Sources 来运行它们。使用 Command Menu 才是最快的方式。只需在它的输入框中输入 <code>!</code>，就可以根据名字来筛选预设代码段。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="4D35F1E65BA54363A62538C8F21F4137" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="Elements-篇"><a href="#Elements-篇" class="headerlink" title="Elements 篇"></a>Elements 篇</h2><p>H 隐藏元素</p><p>Delete 删除元素</p><p>Ctrl + C 复制元素</p><p>Ctrl + Z 撤销改动</p><p>拖动 &amp; 放置 元素</p><p>使用 Ctrl 移动元素</p><p>更多操作请在元素上点击右键</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="DED654DB71AD41878C64DAF958180E73" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="console-篇"><a href="#console-篇" class="headerlink" title="console 篇"></a>console 篇</h2><h3 id="多种多样的-console"><a href="#多种多样的-console" class="headerlink" title="多种多样的 console"></a>多种多样的 console</h3><p>console.log 普通打印</p><p>console.table 表格打印（适用于数组、类数组、对象）</p><p>console.dir 查看节点属性</p><p>console.assert 断言</p><p>console.time / console.timeEnd() 计时器</p><h3 id="console-中的-‘-’"><a href="#console-中的-‘-’" class="headerlink" title="console 中的 ‘$’"></a>console 中的 ‘$’</h3><p><strong>1. $0</strong></p><p>在 Chrome 的 Elements 面板中， <code>$0</code> 是对我们当前选中的 html 节点的引用。</p><p>同理，<code>$1</code> 是对上一次我们选择的节点的引用，一直到 <code>$4</code>。</p><p>你可以尝试一些相关操作，例如: <code>$1.appendChild($0)</code></p><p><strong>2. $ 和 $$</strong></p><p>console 面板中 $ 变量如果未曾被定义过就是 <code>document.querySelector</code> 的别名</p><p>$$ 相当于执行 <code>document.QuerySelectorAll</code> 并且它返回的是一个节点的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$(<span class="string">'div'</span>) === <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>))</span><br></pre></td></tr></table></figure><p><strong>3. $_</strong></p><p><code>$_</code> 是对上次执行的结果的引用</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="20BE513586DF4320B2A328B4A8DFD04F" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>4. $i</strong></p><p>在 DevTools 中使用 npm 插件！</p><p>有时你只是想尝试下新出的 npm 包，现在不用再大费周章去建一个项目测试了，只需要在 Chrome 扩展插件: <a href="https://chrome.google.com/webstore/detail/console-importer/hgajpakhafplebkdljleajgbpdmplhie/related" target="_blank" rel="noopener">Console Importer</a> 的帮助之下，快速的在 console 中引入和测试一些 npm 库。</p><p>运行 <code>$i(&#39;lodash&#39;)</code> 或者 <code>$i(&#39;moment&#39;)</code> 后，你就可以获取到 <code>lodash</code> / <code>momentjs</code> 了:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="06336F0E9C674034B82EA457D28DED0D" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="断点调试-breakpoints"><a href="#断点调试-breakpoints" class="headerlink" title="断点调试 breakpoints"></a>断点调试 breakpoints</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>你还在用<code>console.log</code> 和 <code>alert</code> 吗？使用断点（breakpoint）可以非常方便地调试 JavaScript 代码。</p><p>在行号上单击就设置了一个断点，然后你就可以调试了。当然这也是最最基本的打断点的方式了，当然了，相较于调试全靠 <code>console.log</code> 和 <code>alert</code> 已经高端很多了。</p><p>同时也可以通过在行号上右键点击 <code>Add breakpoint</code> 来设置断点。设置断点的行号上会显示一个蓝色的矩形来告诉你这里有一个断点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="E291DDCFF6624751A4CFEA239FF141B0" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>当断点触发时，整个页面会处于暂停状态，并会切换到 Source 页断点处方便调试，直到终止该断点调试后页面才会继续运行。</p><p>快捷键：</p><ul><li>F8</li><li>F9</li><li>F10</li><li>F11</li></ul><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>比如说你写了一个循环，该循环会执行 100 次，但是你只对第 50 次循环的结果感兴趣，又或者你只对一些满足某些条件的结果感兴趣。于是，你一手托腮，另一只手放在 F8 键上，狂按数十下下后正襟危坐，开始调试。</p><p>显然，Chrome 已经帮我们想到了这种场景，我们可以通过添加一些条件断点来避免一些无意义的断点：</p><ol><li>右击行号，选择 <code>Add conditional breakpoint...</code>(添加条件断点)</li><li>或者右击一个已经设置的断点并且选择 <code>Edit breakpoint</code>(编辑断点)</li></ol><p>然后输入一个执行结果为 <code>true</code> 或者 <code>false</code> 的表达式（它的值其实不需要完全为 <code>true</code> 或者 <code>false</code> 尽管那个弹出框的描述是这样说的）。在这个表达式中你可以使用任何这段代码可以获取到的值（当前行的作用域）。如果条件成立，这个断点就会生效。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1111565C36A54C83906C06EE659E1199" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h3 id="DOM-元素断点"><a href="#DOM-元素断点" class="headerlink" title="DOM 元素断点"></a>DOM 元素断点</h3><p>断点不仅仅可以设置在 JS 代码上，还可以在 DOM 元素上设置断点。</p><p>我们可以设置三种 DOM 元素断点</p><ol><li><code>subtree modifications</code> 子节点内容的的改变（子节点的属性修改不会触发，当前节点的修改不会触发）</li><li><code>attribute modifications</code> 当前节点的属性改变</li><li><code>node removal</code> 当前节点被移除</li></ol><p>当我们的脚本触发了 DOM 的修改时，devtools 会直接跳转到 Source 页并定位到修改 DOM 的那行代码上。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="B1936A8364814D018BB655E80F9C3837" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="你还一层层展开-DOM？"><a href="#你还一层层展开-DOM？" class="headerlink" title="你还一层层展开 DOM？"></a>你还一层层展开 DOM？</h2><p>Alt + Click，快速展开所有 DOM</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/5/11/1634e386ca68401d?imageslim" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="Network-重新发送-XHR-的请求"><a href="#Network-重新发送-XHR-的请求" class="headerlink" title="Network - 重新发送 XHR 的请求"></a>Network - 重新发送 XHR 的请求</h2><p>如何重新发送 XHR 的请求？刷新页面？太老套了，试试这么做：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="123BBE371105486AA89050D52BEF9D9E" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="恐龙小游戏-Chrome-Dino"><a href="#恐龙小游戏-Chrome-Dino" class="headerlink" title="恐龙小游戏(Chrome Dino)"></a>恐龙小游戏(Chrome Dino)</h2><p>相信在座的各位对 Google Chrome 中的一个复活节彩蛋 —— 恐龙小游戏(Chrome Dino)不会感到陌生。在与互联网断开连接时，当用户尝试访问网站，并在按下空格键后即可开始这个游戏。</p><p>Chrome 中的恐龙小游戏是一个简单的无限跑步游戏，它会让用户跳过仙人掌，并闪避障碍物，游戏为用户提供基本控制，按空格键跳跃（并开始游戏），向下箭头(↓)俯身奔跑以躲避障碍物。目标是在互联网重新开始工作之前让用户打发时间。</p><p>其实用户也可以在不打开飞行模式的情况下玩 Chrome dino 游戏。只需在 Chrome 浏览器的地址栏中输入 <code>chrome://dino</code>，用户就可以进入“街机模式”，在那里用户可以在全窗口环境中畅玩这款游戏。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/dkwuWwLoRK9lVMRe6gEYGibohT8l41icSlHedYylcAy4gmruial1Via48EBmxCUkIxzRaJwuAuibUr21uyS04iaagVbw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="image"></p><h2 id="推荐一些好用的-Chrome-扩展"><a href="#推荐一些好用的-Chrome-扩展" class="headerlink" title="推荐一些好用的 Chrome 扩展"></a>推荐一些好用的 Chrome 扩展</h2><p>启动页：掘金、Infinity新标签页、Momentum</p><p>翻译：Google 翻译、有道云翻译、百度翻译、有道词典Chrome划词插件</p><p>广告屏蔽：Adblock Plus</p><p>OneTab</p><p>Clipboard History 2</p><p>WEB前端助手(FeHelper)</p><p>JSONView</p><p>Stylish-为任意网站自定义主题</p><p>tampermonkey 油猴</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developers.google.com/web/tools/chrome-devtools/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/book/5c526902e51d4543805ef35e/section/5c5269026fb9a049f1549e4a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/book/5c526902e51d4543805ef35e/section/5c5269026fb9a049f1549e4a&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;工欲善其事必先利其器。&lt;/p&gt;
&lt;p&gt;有些时候一个技巧可以节省我们很多的时间，也会让调试的过程变得更加简单直接。本次分享从不同的情景来说明应该如何搭配使用 Chrome DevTools 中的小技巧，让大家熟练掌握 Chrome 调试技巧，直接提升工作效率。&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://ws1.sinaimg.cn/large/9823cde9gy1g50ma3qnorj20pw0dh0t9.jpg&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Promise 对象</title>
    <link href="https://bxm0927.github.io/2020/05/24/promise/"/>
    <id>https://bxm0927.github.io/2020/05/24/promise/</id>
    <published>2020-05-24T05:06:08.448Z</published>
    <updated>2020-05-24T05:06:08.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Promise-对象简介"><a href="#Promise-对象简介" class="headerlink" title="Promise 对象简介"></a>Promise 对象简介</h2><p>Promise 是异步编程的一种更优的解决方案，一定程度上解决了回调函数产生的“<strong>回调地狱</strong>”的问题。Promise 最早由社区提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 <code>Promise</code> 对象。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>==Promise 允许将回调函数的嵌套改成<strong>链式调用</strong>，即用同步的方式去写异步代码，使异步代码看起来像是线性结构。==</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/9823cde9gy1g4nth71v66j20kg0ckaad.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><h2 id="Promise-对象的两个特点"><a href="#Promise-对象的两个特点" class="headerlink" title="Promise 对象的两个特点"></a>Promise 对象的两个特点</h2><ol><li>对象的状态不受外界影响。</li></ol><p>Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p><ol start="2"><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。</li></ol><p>Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><blockquote><p>注意，我们一般说的 resolved，是指 Promise 对象的状态从 pending 变为 fulfilled，即异步操作成功。</p></blockquote><h2 id="Promise-对象的缺点"><a href="#Promise-对象的缺点" class="headerlink" title="Promise 对象的缺点"></a>Promise 对象的缺点</h2><p>Promise 也有一些缺点：</p><ol><li>首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</li><li>其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</li><li>第三，当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ol><h2 id="Promise-对象基本用法"><a href="#Promise-对象基本用法" class="headerlink" title="Promise 对象基本用法"></a>Promise 对象基本用法</h2><p>ES6 规定，<code>Promise</code> 对象是一个构造函数，用来生成 <code>Promise</code> 实例。该构造函数接受一个函数作为参数，该函数的两个参数分别是 <code>resolve</code> 和 <code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><ul><li><code>resolve</code> 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li><li><code>reject</code> 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li><li>如果调用 <code>resolve</code> 函数和 <code>reject</code> 函数时带有参数，那么它们的参数会被传递给回调函数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">  &#x2F;&#x2F; ... some code</span><br><span class="line"></span><br><span class="line">  if (&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。then 方法可以接受两个回调函数作为参数。</p><ul><li>第一个回调函数是 Promise 对象的状态变为 resolved 时调用，</li><li>第二个回调函数是 Promise 对象的状态变为 rejected 时调用。</li><li>其中，第二个函数是可选的，不一定要提供。</li><li>这两个函数都接受 Promise 对象传出的值作为参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">  function(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">  &#125;,</span><br><span class="line">  function(error) &#123;</span><br><span class="line">    &#x2F;&#x2F; failure</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面是一个 <code>Promise</code> 对象的简单例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一段时候后进行打印</span><br><span class="line">function timeout(ms) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms, &#39;done&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(3000).then(value &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><blockquote><p>Promise 实例具有 then、catch、finally 方法，也就是说，then、catch、finally 方法是定义在原型对象 Promise.prototype 上的。</p></blockquote><p>then 方法的作用是为 Promise 实例<strong>添加状态改变时的回调函数</strong>。</p><p>then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用（可选）。</p><p>then 方法返回的是一个新的 Promise 实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/post/test.json'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">post</span> =&gt;</span> getJSON(post.commentURL))</span><br><span class="line">  .then(</span><br><span class="line">    comments =&gt; <span class="built_in">console</span>.log(<span class="string">'resolved: '</span>, comments),</span><br><span class="line">    err =&gt; <span class="built_in">console</span>.log(<span class="string">'rejected: '</span>, err)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p>Promise.prototype.catch 方法是 <code>.then(null, rejection)</code> 或 <code>.then(undefined, rejection)</code> 的别名，<strong>用于指定发生错误时的回调函数</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'rejected'</span>, err))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .then(<span class="literal">null</span>, err =&gt; <span class="built_in">console</span>.log(<span class="string">'rejected:'</span>, err))</span><br></pre></td></tr></table></figure><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。</p><p>最佳实践：一般来说，不要在 then 方法里面定义 <code>reject</code> 状态的回调函数（即 then 的第二个参数），总是使用 catch 方法。一般总是建议，Promise 对象后面要跟 catch 方法，这样可以处理 Promise 内部发生的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p>finally 方法用于指定不管 Promise 对象最后状态如何，<strong>都会执行的操作</strong>。该方法是 ES2018 引入标准的。</p><p>我们一般在 finally 方法中关闭服务和资源。</p><p>finally 方法的回调函数不接受任何参数，这意味着没有办法知道前面的 Promise 状态到底是 fulfilled 还是 rejected。这表明，finally 方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>finally 本质上是 then 方法的特例。如果不使用 finally 方法，同样的语句需要为成功和失败两种情况各写一次。有了 finally 方法，则只需要写一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">  .finally(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 都会执行的操作</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">promise.then(</span><br><span class="line">  result &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 都会执行的操作</span><br><span class="line">    return result</span><br><span class="line">  &#125;,</span><br><span class="line">  error &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 都会执行的操作</span><br><span class="line">    throw error</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">promise</span><br><span class="line">  .then(result &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 都会执行的操作</span><br><span class="line">    return result</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 都会执行的操作</span><br><span class="line">    throw error</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>Promise.prototype.finally() 底层实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.finally &#x3D; function(callback) &#123;</span><br><span class="line">  let P &#x3D; this.constructor</span><br><span class="line">  return this.then(</span><br><span class="line">    value &#x3D;&gt; P.resolve(callback()).then(() &#x3D;&gt; value),</span><br><span class="line">    reason &#x3D;&gt; P.resolve(callback()).then(() &#x3D;&gt; throw reason),</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例（<strong>并发请求</strong>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 实例。p 的状态由 p1、p2、p3 决定，分成两种情况。</p><ol><li>只有p1、p2、p3的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</li><li>只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncThing</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里假如是一个异步操作</span></span><br><span class="line">    value &gt; <span class="number">10</span> ? resolve(value) : reject(value)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([someAsyncThing(<span class="number">11</span>), someAsyncThing(<span class="number">12</span>)])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sussess '</span> + res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error '</span> + err)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// sussess [11,12]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([someAsyncThing(<span class="number">11</span>), someAsyncThing(<span class="number">10</span>)])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sussess '</span> + res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error '</span> + err)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// error 10</span></span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><blockquote><p>race：赛跑</p></blockquote><p>Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</p><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>Promise.resolve 方法用于将现有对象转为 Promise 对象。</p><p>Promise.race 方法的参数与 Promise.all 方法一样，如果不是 Promise 实例，就会先调用 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将 jQuery 生成的 deferred 对象，转为一个新的 Promise 对象</span><br><span class="line">const jsPromise &#x3D; Promise.resolve($.ajax(&#39;&#x2F;whatever.json&#39;));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#39;foo&#39;)</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">new Promise(resolve &#x3D;&gt; resolve(&#39;foo&#39;))</span><br></pre></td></tr></table></figure><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p>Promise.reject(reason) 方法也会返回一个新的 Promise 实例，该实例的状态为 rejected。</p><h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><p>让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const f &#x3D; () &#x3D;&gt; console.log(&#39;now&#39;);</span><br><span class="line">Promise.try(f);</span><br><span class="line">console.log(&#39;next&#39;);</span><br><span class="line">&#x2F;&#x2F; now</span><br><span class="line">&#x2F;&#x2F; next</span><br></pre></td></tr></table></figure><h2 id="Promise-库"><a href="#Promise-库" class="headerlink" title="Promise 库"></a>Promise 库</h2><p>Bluebird：<a href="http://bluebirdjs.com/docs/api/promise.try.html" target="_blank" rel="noopener">http://bluebirdjs.com/docs/api/promise.try.html</a></p><p>Q：<a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">https://github.com/kriskowal/q</a></p><p>when：<a href="https://github.com/cujojs/when" target="_blank" rel="noopener">https://github.com/cujojs/when</a></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>Promise 新建后就会立即执行</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolved.'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    i == <span class="number">9999</span> &amp;&amp; resolve()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 3 5 4 1</span></span><br></pre></td></tr></table></figure><ol start="2"><li>调用 resolve 或 reject 并不会终结 Promise 的参数函数的执行。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>一般来说，调用 resolve 或 reject 以后，Promise 的使命就完成了，后继操作应该放到 then 方法里面，而不应该直接写在 resolve 或 reject 的后面。所以，最好在它们前面加上 return 语句，这样就不会有意外。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  return resolve(1)</span><br><span class="line">  &#x2F;&#x2F; 后面的语句不会执行</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>Promise 的 <code>resolve</code> 函数的参数是另一个 Promise 实例。即一个 Promise p1 的结果是返回另一个 Promise p2，那么 p1 的状态由 p2 决定。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表现：3s 后打印 "Error: fail"</span></span><br></pre></td></tr></table></figure><ol start="4"><li>Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'everything is great'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><ol start="5"><li>如果 Promise 状态已经变成 resolved，再抛出错误是无效的，即不会被捕获。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Promise-对象简介&quot;&gt;&lt;a href=&quot;#Promise-对象简介&quot; class=&quot;headerlink&quot; title=&quot;Promise 对象简介&quot;&gt;&lt;/a&gt;Promise 对象简介&lt;/h2&gt;&lt;p&gt;Promise 是异步编程的一种更优的解决方案，一定程度上解决了回调函数产生的“&lt;strong&gt;回调地狱&lt;/strong&gt;”的问题。Promise 最早由社区提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 &lt;code&gt;Promise&lt;/code&gt; 对象。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。&lt;/p&gt;
&lt;p&gt;==Promise 允许将回调函数的嵌套改成&lt;strong&gt;链式调用&lt;/strong&gt;，即用同步的方式去写异步代码，使异步代码看起来像是线性结构。==&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://ws1.sinaimg.cn/large/9823cde9gy1g4nth71v66j20kg0ckaad.jpg&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://bxm0927.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://bxm0927.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://bxm0927.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>post title with whitespace</title>
    <link href="https://bxm0927.github.io/2020/05/24/post-title-with-whitespace/"/>
    <id>https://bxm0927.github.io/2020/05/24/post-title-with-whitespace/</id>
    <published>2020-05-23T17:47:55.000Z</published>
    <updated>2020-05-23T17:47:55.647Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="https://bxm0927.github.io/2020/05/22/hello-hexo/"/>
    <id>https://bxm0927.github.io/2020/05/22/hello-hexo/</id>
    <published>2020-05-22T14:21:34.080Z</published>
    <updated>2020-05-22T14:21:49.275Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://bxm0927.github.io/2020/05/22/hello-world/"/>
    <id>https://bxm0927.github.io/2020/05/22/hello-world/</id>
    <published>2020-05-22T13:27:53.947Z</published>
    <updated>2020-05-22T14:21:32.191Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>test post</title>
    <link href="https://bxm0927.github.io/2019/06/28/test/"/>
    <id>https://bxm0927.github.io/2019/06/28/test/</id>
    <published>2019-06-28T09:17:35.000Z</published>
    <updated>2020-05-24T05:06:08.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图片（images）"><a href="#图片（images）" class="headerlink" title="图片（images）"></a>图片（images）</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/avatar.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><a id="more"></a><h2 id="引用块（quote）"><a href="#引用块（quote）" class="headerlink" title="引用块（quote）"></a>引用块（quote）</h2><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p></blockquote><blockquote class="pullquote [class]"><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p></blockquote><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p></blockquote><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io" target="_blank" rel="noopener">http://devdocs.io</a></p><footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752" target="_blank" rel="noopener">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><h2 id="代码块（code）"><a href="#代码块（code）" class="headerlink" title="代码块（code）"></a>代码块（code）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">'Hello World!'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>Array.map</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">'Hello World!'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&#39;Hello World!&#39;);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[rectangle setX: <span class="number">10</span> y: <span class="number">10</span> width: <span class="number">20</span> height: <span class="number">20</span>];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>Array.map</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.map(callback[, thisArg])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.compact([0, 1, false, 2, &#39;&#39;, 3]);</span><br><span class="line">&#x3D;&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图片（images）&quot;&gt;&lt;a href=&quot;#图片（images）&quot; class=&quot;headerlink&quot; title=&quot;图片（images）&quot;&gt;&lt;/a&gt;图片（images）&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;/images/avatar.jpg&quot; alt=&quot;avatar&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;avatar&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="Others" scheme="https://bxm0927.github.io/categories/Others/"/>
    
    
      <category term="test" scheme="https://bxm0927.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>blog-hexo</title>
    <link href="https://bxm0927.github.io/2013/07/13/blog/"/>
    <id>https://bxm0927.github.io/2013/07/13/blog/</id>
    <published>2013-07-13T12:46:25.000Z</published>
    <updated>2019-06-28T08:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><a id="more"></a><h2 id="✂️-Build-Setup"><a href="#✂️-Build-Setup" class="headerlink" title="✂️ Build Setup"></a>✂️ Build Setup</h2><p>前置条件：</p><ul><li>Node.js (Should be at least nodejs 6.9)</li><li>Git</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install Hexo</span></span><br><span class="line">$ npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line"><span class="comment">#  Create a new Hexo folder.</span></span><br><span class="line">$ hexo init &lt;blog-name&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;blog-name&gt;</span><br><span class="line">$ npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start the server.</span></span><br><span class="line">$ hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate static files.</span></span><br><span class="line">$ hexo generate <span class="comment"># hexo g</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deploy your website.</span></span><br><span class="line">$ hexo deploy <span class="comment"># hexo d</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># One-click deployment</span></span><br><span class="line">$ hexo generate --deploy <span class="comment"># hexo g -d</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/9823cde9gy1g4gy3sgql2j20k20armyb.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="✏️Q-amp-A"><a href="#✏️Q-amp-A" class="headerlink" title="✏️Q&amp;A"></a>✏️Q&amp;A</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt; 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FE" scheme="https://bxm0927.github.io/categories/FE/"/>
    
      <category term="HTML" scheme="https://bxm0927.github.io/categories/FE/HTML/"/>
    
    
      <category term="HTML" scheme="https://bxm0927.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://bxm0927.github.io/tags/CSS/"/>
    
      <category term="JS" scheme="https://bxm0927.github.io/tags/JS/"/>
    
  </entry>
  
</feed>
