<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiaoming&#39;s Blog</title>
  
  <subtitle>Share with you IT technology, to achieve progress together.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bxm0927.github.io/"/>
  <updated>2020-09-10T12:24:48.571Z</updated>
  <id>https://bxm0927.github.io/</id>
  
  <author>
    <name>白小明</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Chrome DevTools 调试技巧</title>
    <link href="https://bxm0927.github.io/2020/05/24/chrome-devtools/"/>
    <id>https://bxm0927.github.io/2020/05/24/chrome-devtools/</id>
    <published>2020-05-24T05:06:08.448Z</published>
    <updated>2020-09-10T12:24:48.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工欲善其事必先利其器。</p><p>有些时候一个技巧可以节省我们很多的时间，也会让调试的过程变得更加简单直接。本次分享从不同的情景来说明应该如何搭配使用 Chrome DevTools 中的小技巧，让大家熟练掌握 Chrome 调试技巧，直接提升工作效率。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/9823cde9gy1g50ma3qnorj20pw0dh0t9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><h2 id="关于-Chrome"><a href="#关于-Chrome" class="headerlink" title="关于 Chrome"></a>关于 Chrome</h2><p>谷歌浏览器（通常简称为 Chrome ）是由谷歌开发的网络浏览器。 它于 2008 年首次针对 Microsoft Windows 发布，后来移植到 Linux ，macOS ，iOS 和 Android 。 浏览器也是 Chrome OS 的主要组件，它可以作为 Web 应用的平台。Chrome-wikipedia</p><p>现如今，浏览器的市场已天下三分，Chorme，Safari 和 FireFox，从 2008 年 Chrome 横空出世以来，如今已经一家独大占据了半壁江山：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="B2AAACDFE2124EEE94E2641FA0193037" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="关于-Chrome-DevTools"><a href="#关于-Chrome-DevTools" class="headerlink" title="关于 Chrome DevTools"></a>关于 Chrome DevTools</h2><p>对于大部分人来说，Chrome 可能只是个浏览器，但是对于开发人员来说，它更是一个强大无比的工具，为了方便开发人员调试代码，主流的浏览器都内置了 DevTools， 所以无论你是前端还是后端，掌握 Chrome DevTools 的使用技巧意味着效率直接的提高。</p><h3 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h3><ol><li>F12</li><li>Ctrl + Shift + I (Windows) 或 Cmd + Opt + I (Mac)</li><li>更多工具 &gt; 开发者工具</li><li>在页面元素上右键点击，选择 “检查”</li></ol><h3 id="面板概览"><a href="#面板概览" class="headerlink" title="面板概览"></a>面板概览</h3><p>Chrome DevTools 包含 1 个设备模式和 8 个常见的面板，我们还可以通过插件来增加一些面板（如：Vue-DevTools）</p><p><strong>0. 设备模式 Device Mode</strong></p><p>使用设备模式构建完全响应式，移动优先的网络体验。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="CB84697A18644580B93F27B787274002" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>1. 元素面板 Elements</strong></p><p>使用元素面板可以自由的操作 DOM 和 CSS 来迭代布局和设计页面。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="B3F3B926D46D42EDBF7F84898902B178" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>2. 控制台面板 Console</strong></p><p>在开发期间，可以使用控制台面板记录诊断信息，或者使用它作为 shell 在页面上与 JavaScript 交互。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="35ABFD539A3A4272AC301F693C03E21B" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>3. 源代码面板 Sources</strong></p><p>在源代码面板中设置断点来调试 JavaScript ，或者通过Workspaces（工作区）连接本地文件来使用开发者工具的实时编辑器。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="44E8E8D1617C4872B81D0B25A300A6CC" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>4. 网络面板 Network</strong></p><p>使用网络面板了解请求和下载的资源文件并优化网页加载性能。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="443BE4F9A69340EDB5C4E978492CAFF5" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>5. 性能面板 Performance</strong></p><p>使用性能面板可以通过记录和查看网站生命周期内发生的各种事件来提高页面的运行时性能。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="9595A6FDD8DE49FCA06830196EF86A3E" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>6. 内存面板 Memory</strong></p><p>如果需要比内存面板提供的更多信息，可以使用内存面板，例如跟踪内存泄漏。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="D7F65B18321D43778BB7F3B541FF6C9F" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>7. 应用面板 Application</strong></p><p>使用应用面板可以检查加载的所有资源，包括 IndexedDB 与 Web SQL 数据库，本地和会话存储，cookie，应用程序缓存，图像，字体和样式表。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="46F1EDC7929347A88CA7E412BB421C2B" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>8. 安全面板 Security</strong></p><p>使用安全面板调试混合内容问题，证书问题等等。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="F6F22421759D48C1BCCF201207252E5C" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="实用快捷键"><a href="#实用快捷键" class="headerlink" title="实用快捷键"></a>实用快捷键</h2><p><code>Ctrl + shift + D</code>：把 DevTools 窗口切换到右边、下边</p><p><code>Ctrl + shift + M</code>：切换设备模式</p><p><code>Ctrl + [</code> 和 <code>Ctrl + ]</code>：切换面板</p><p>上下箭头：递增/递减，可配合 Alt、Ctrl、Shift 实现不同的步长（对调整样式特别有用）</p><p><code>Ctrl + F</code>：在 elements， logs， sources 和 network 中查找</p><h2 id="使用-Command"><a href="#使用-Command" class="headerlink" title="使用 Command"></a>使用 Command</h2><p>我们直接可以直接看到的 DevTools 的功能，其实只是有限的一部分，怎么去探索更多的功能呢？</p><p>Command 菜单可以帮助我们快速找到那些被隐藏起来的功能，你可以使用 <code>Ctrl + Shift + P</code> 或 DevTools 的 <code>dropdown</code> 按钮打开 Command。</p><p>Command 包含下列几类命令：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="713B9C0F832643179CBB15769BDFFD41" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>常用的 Command：</p><ul><li>截屏：<code>capture</code></li><li>切换主题：<code>theme</code></li></ul><h2 id="copying"><a href="#copying" class="headerlink" title="copying"></a>copying</h2><p>你可以通过全局的方法 <code>copy()</code> 在 console 里复制任何你能拿到的资源</p><p>例如：<code>copy(location)</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="623FCE5084104E8995A7F7B8ACB28395" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="saving"><a href="#saving" class="headerlink" title="saving"></a>saving</h2><p>如果你在 console 中打印了一堆数据（例如一个大型数组），然后你想对这些数据做一些额外的操作，那就可以将它转换成一个全局变量，只需要右击它，并选择 “<strong>Store as global variable</strong>” (保存为全局变量) 选项。第一次使用的话，它会创建一个名为 temp1 的变量，第二次创建 temp2，以此类推。</p><blockquote><p>注意：得到的 temp$ 的是原数据的引用，操作会影响原数据。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="99C92C3DC2524A77BC929CE893AD007C" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="保存堆栈信息-Stack-trace"><a href="#保存堆栈信息-Stack-trace" class="headerlink" title="保存堆栈信息( Stack trace )"></a>保存堆栈信息( Stack trace )</h2><p>大多数情况下都不是一个人开发一个项目，而是一个团队协作，那么 如何准确的描述问题，就成为了沟通的关键 ，这时候 console 打印出来的堆栈跟踪的信息对你和同事来说就起大作用了，可以省去很多沟通成本，所以你可以直接把堆栈跟踪的信息保存为一个文件，而不只是截图发给对方：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="708C2C028A3240038CFF5CB468241CE4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="Snippets-代码段"><a href="#Snippets-代码段" class="headerlink" title="Snippets 代码段"></a>Snippets 代码段</h2><blockquote><p>如果你需要频繁地在 console 中输入某个代码段，Snippets 功能可能会帮助你。</p></blockquote><p>比如，我想统计网页标签使用数量，评价网页是否语义化，我会把这段脚本赋值 Console 面板：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计网页标签使用数量，评价网页是否语义化的重要指标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTagsMap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...document.querySelectorAll(<span class="string">'*'</span>)].reduce(<span class="function">(<span class="params">a, c</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tagName = c.tagName.toLowerCase()</span><br><span class="line">    a[tagName] = a[tagName] ? a[tagName] + <span class="number">1</span> : <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">getTagsMap()</span><br></pre></td></tr></table></figure><p>现在看来，即使这个脚本并没有花费我太多的精力来编写，但也只是偶尔运行一下，所以对于我来说，记住一段这样的脚本会很麻烦。</p><p>那怎么解决这个问题呢？</p><p>这就是 Snippets 的用武之地：它允许你存放 JavaScript 代码到 DevTools 中，方便你复用这些 JavaScript 代码段：</p><p>进入到 Sources 面板，在导航栏里选中 <code>Snippets</code> 这栏，点击 <code>New snippet</code> 新建一个代码段，然后输入你的代码之后保存就可以 <code>Run</code> 了！</p><blockquote><p>当我在 DevTools 中预设了一组很棒的代段块以后，甚至都不必再通过 Sources 来运行它们。使用 Command Menu 才是最快的方式。只需在它的输入框中输入 <code>!</code>，就可以根据名字来筛选预设代码段。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="4D35F1E65BA54363A62538C8F21F4137" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="Elements-篇"><a href="#Elements-篇" class="headerlink" title="Elements 篇"></a>Elements 篇</h2><p>H 隐藏元素</p><p>Delete 删除元素</p><p>Ctrl + C 复制元素</p><p>Ctrl + Z 撤销改动</p><p>拖动 &amp; 放置 元素</p><p>使用 Ctrl 移动元素</p><p>更多操作请在元素上点击右键</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="DED654DB71AD41878C64DAF958180E73" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="console-篇"><a href="#console-篇" class="headerlink" title="console 篇"></a>console 篇</h2><h3 id="多种多样的-console"><a href="#多种多样的-console" class="headerlink" title="多种多样的 console"></a>多种多样的 console</h3><p>console.log 普通打印</p><p>console.table 表格打印（适用于数组、类数组、对象）</p><p>console.dir 查看节点属性</p><p>console.assert 断言</p><p>console.time / console.timeEnd() 计时器</p><h3 id="console-中的-‘-’"><a href="#console-中的-‘-’" class="headerlink" title="console 中的 ‘$’"></a>console 中的 ‘$’</h3><p><strong>1. $0</strong></p><p>在 Chrome 的 Elements 面板中， <code>$0</code> 是对我们当前选中的 html 节点的引用。</p><p>同理，<code>$1</code> 是对上一次我们选择的节点的引用，一直到 <code>$4</code>。</p><p>你可以尝试一些相关操作，例如: <code>$1.appendChild($0)</code></p><p><strong>2. $ 和 $$</strong></p><p>console 面板中 $ 变量如果未曾被定义过就是 <code>document.querySelector</code> 的别名</p><p>$$ 相当于执行 <code>document.QuerySelectorAll</code> 并且它返回的是一个节点的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$(<span class="string">'div'</span>) === <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>))</span><br></pre></td></tr></table></figure><p><strong>3. $_</strong></p><p><code>$_</code> 是对上次执行的结果的引用</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="20BE513586DF4320B2A328B4A8DFD04F" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p><strong>4. $i</strong></p><p>在 DevTools 中使用 npm 插件！</p><p>有时你只是想尝试下新出的 npm 包，现在不用再大费周章去建一个项目测试了，只需要在 Chrome 扩展插件: <a href="https://chrome.google.com/webstore/detail/console-importer/hgajpakhafplebkdljleajgbpdmplhie/related" target="_blank" rel="noopener">Console Importer</a> 的帮助之下，快速的在 console 中引入和测试一些 npm 库。</p><p>运行 <code>$i(&#39;lodash&#39;)</code> 或者 <code>$i(&#39;moment&#39;)</code> 后，你就可以获取到 <code>lodash</code> / <code>momentjs</code> 了:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="06336F0E9C674034B82EA457D28DED0D" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="断点调试-breakpoints"><a href="#断点调试-breakpoints" class="headerlink" title="断点调试 breakpoints"></a>断点调试 breakpoints</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>你还在用<code>console.log</code> 和 <code>alert</code> 吗？使用断点（breakpoint）可以非常方便地调试 JavaScript 代码。</p><p>在行号上单击就设置了一个断点，然后你就可以调试了。当然这也是最最基本的打断点的方式了，当然了，相较于调试全靠 <code>console.log</code> 和 <code>alert</code> 已经高端很多了。</p><p>同时也可以通过在行号上右键点击 <code>Add breakpoint</code> 来设置断点。设置断点的行号上会显示一个蓝色的矩形来告诉你这里有一个断点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="E291DDCFF6624751A4CFEA239FF141B0" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>当断点触发时，整个页面会处于暂停状态，并会切换到 Source 页断点处方便调试，直到终止该断点调试后页面才会继续运行。</p><p>快捷键：</p><ul><li>F8</li><li>F9</li><li>F10</li><li>F11</li></ul><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>比如说你写了一个循环，该循环会执行 100 次，但是你只对第 50 次循环的结果感兴趣，又或者你只对一些满足某些条件的结果感兴趣。于是，你一手托腮，另一只手放在 F8 键上，狂按数十下下后正襟危坐，开始调试。</p><p>显然，Chrome 已经帮我们想到了这种场景，我们可以通过添加一些条件断点来避免一些无意义的断点：</p><ol><li>右击行号，选择 <code>Add conditional breakpoint...</code>(添加条件断点)</li><li>或者右击一个已经设置的断点并且选择 <code>Edit breakpoint</code>(编辑断点)</li></ol><p>然后输入一个执行结果为 <code>true</code> 或者 <code>false</code> 的表达式（它的值其实不需要完全为 <code>true</code> 或者 <code>false</code> 尽管那个弹出框的描述是这样说的）。在这个表达式中你可以使用任何这段代码可以获取到的值（当前行的作用域）。如果条件成立，这个断点就会生效。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1111565C36A54C83906C06EE659E1199" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h3 id="DOM-元素断点"><a href="#DOM-元素断点" class="headerlink" title="DOM 元素断点"></a>DOM 元素断点</h3><p>断点不仅仅可以设置在 JS 代码上，还可以在 DOM 元素上设置断点。</p><p>我们可以设置三种 DOM 元素断点</p><ol><li><code>subtree modifications</code> 子节点内容的的改变（子节点的属性修改不会触发，当前节点的修改不会触发）</li><li><code>attribute modifications</code> 当前节点的属性改变</li><li><code>node removal</code> 当前节点被移除</li></ol><p>当我们的脚本触发了 DOM 的修改时，devtools 会直接跳转到 Source 页并定位到修改 DOM 的那行代码上。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="B1936A8364814D018BB655E80F9C3837" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="你还一层层展开-DOM？"><a href="#你还一层层展开-DOM？" class="headerlink" title="你还一层层展开 DOM？"></a>你还一层层展开 DOM？</h2><p>Alt + Click，快速展开所有 DOM</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/5/11/1634e386ca68401d?imageslim" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="Network-重新发送-XHR-的请求"><a href="#Network-重新发送-XHR-的请求" class="headerlink" title="Network - 重新发送 XHR 的请求"></a>Network - 重新发送 XHR 的请求</h2><p>如何重新发送 XHR 的请求？刷新页面？太老套了，试试这么做：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="123BBE371105486AA89050D52BEF9D9E" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="恐龙小游戏-Chrome-Dino"><a href="#恐龙小游戏-Chrome-Dino" class="headerlink" title="恐龙小游戏(Chrome Dino)"></a>恐龙小游戏(Chrome Dino)</h2><p>相信在座的各位对 Google Chrome 中的一个复活节彩蛋 —— 恐龙小游戏(Chrome Dino)不会感到陌生。在与互联网断开连接时，当用户尝试访问网站，并在按下空格键后即可开始这个游戏。</p><p>Chrome 中的恐龙小游戏是一个简单的无限跑步游戏，它会让用户跳过仙人掌，并闪避障碍物，游戏为用户提供基本控制，按空格键跳跃（并开始游戏），向下箭头(↓)俯身奔跑以躲避障碍物。目标是在互联网重新开始工作之前让用户打发时间。</p><p>其实用户也可以在不打开飞行模式的情况下玩 Chrome dino 游戏。只需在 Chrome 浏览器的地址栏中输入 <code>chrome://dino</code>，用户就可以进入“街机模式”，在那里用户可以在全窗口环境中畅玩这款游戏。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/dkwuWwLoRK9lVMRe6gEYGibohT8l41icSlHedYylcAy4gmruial1Via48EBmxCUkIxzRaJwuAuibUr21uyS04iaagVbw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="image"></p><h2 id="推荐一些好用的-Chrome-扩展"><a href="#推荐一些好用的-Chrome-扩展" class="headerlink" title="推荐一些好用的 Chrome 扩展"></a>推荐一些好用的 Chrome 扩展</h2><p>启动页：掘金、Infinity新标签页、Momentum</p><p>翻译：Google 翻译、有道云翻译、百度翻译、有道词典Chrome划词插件</p><p>广告屏蔽：Adblock Plus</p><p>OneTab</p><p>Clipboard History 2</p><p>WEB前端助手(FeHelper)</p><p>JSONView</p><p>Stylish-为任意网站自定义主题</p><p>tampermonkey 油猴</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工欲善其事必先利其器。&lt;/p&gt;
&lt;p&gt;有些时候一个技巧可以节省我们很多的时间，也会让调试的过程变得更加简单直接。本次分享从不同的情景来说明应该如何搭配使用 Chrome DevTools 中的小技巧，让大家熟练掌握 Chrome 调试技巧，直接提升工作效率。&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://ws1.sinaimg.cn/large/9823cde9gy1g50ma3qnorj20pw0dh0t9.jpg&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Promise 对象</title>
    <link href="https://bxm0927.github.io/2020/05/24/promise/"/>
    <id>https://bxm0927.github.io/2020/05/24/promise/</id>
    <published>2020-05-24T05:06:08.448Z</published>
    <updated>2020-05-24T05:06:08.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Promise-对象简介"><a href="#Promise-对象简介" class="headerlink" title="Promise 对象简介"></a>Promise 对象简介</h2><p>Promise 是异步编程的一种更优的解决方案，一定程度上解决了回调函数产生的“<strong>回调地狱</strong>”的问题。Promise 最早由社区提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 <code>Promise</code> 对象。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>==Promise 允许将回调函数的嵌套改成<strong>链式调用</strong>，即用同步的方式去写异步代码，使异步代码看起来像是线性结构。==</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/9823cde9gy1g4nth71v66j20kg0ckaad.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><h2 id="Promise-对象的两个特点"><a href="#Promise-对象的两个特点" class="headerlink" title="Promise 对象的两个特点"></a>Promise 对象的两个特点</h2><ol><li>对象的状态不受外界影响。</li></ol><p>Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p><ol start="2"><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。</li></ol><p>Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><blockquote><p>注意，我们一般说的 resolved，是指 Promise 对象的状态从 pending 变为 fulfilled，即异步操作成功。</p></blockquote><h2 id="Promise-对象的缺点"><a href="#Promise-对象的缺点" class="headerlink" title="Promise 对象的缺点"></a>Promise 对象的缺点</h2><p>Promise 也有一些缺点：</p><ol><li>首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</li><li>其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</li><li>第三，当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ol><h2 id="Promise-对象基本用法"><a href="#Promise-对象基本用法" class="headerlink" title="Promise 对象基本用法"></a>Promise 对象基本用法</h2><p>ES6 规定，<code>Promise</code> 对象是一个构造函数，用来生成 <code>Promise</code> 实例。该构造函数接受一个函数作为参数，该函数的两个参数分别是 <code>resolve</code> 和 <code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><ul><li><code>resolve</code> 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li><li><code>reject</code> 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li><li>如果调用 <code>resolve</code> 函数和 <code>reject</code> 函数时带有参数，那么它们的参数会被传递给回调函数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">  &#x2F;&#x2F; ... some code</span><br><span class="line"></span><br><span class="line">  if (&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。then 方法可以接受两个回调函数作为参数。</p><ul><li>第一个回调函数是 Promise 对象的状态变为 resolved 时调用，</li><li>第二个回调函数是 Promise 对象的状态变为 rejected 时调用。</li><li>其中，第二个函数是可选的，不一定要提供。</li><li>这两个函数都接受 Promise 对象传出的值作为参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">  function(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">  &#125;,</span><br><span class="line">  function(error) &#123;</span><br><span class="line">    &#x2F;&#x2F; failure</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面是一个 <code>Promise</code> 对象的简单例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一段时候后进行打印</span><br><span class="line">function timeout(ms) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms, &#39;done&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(3000).then(value &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><blockquote><p>Promise 实例具有 then、catch、finally 方法，也就是说，then、catch、finally 方法是定义在原型对象 Promise.prototype 上的。</p></blockquote><p>then 方法的作用是为 Promise 实例<strong>添加状态改变时的回调函数</strong>。</p><p>then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用（可选）。</p><p>then 方法返回的是一个新的 Promise 实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/post/test.json'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">post</span> =&gt;</span> getJSON(post.commentURL))</span><br><span class="line">  .then(</span><br><span class="line">    comments =&gt; <span class="built_in">console</span>.log(<span class="string">'resolved: '</span>, comments),</span><br><span class="line">    err =&gt; <span class="built_in">console</span>.log(<span class="string">'rejected: '</span>, err)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p>Promise.prototype.catch 方法是 <code>.then(null, rejection)</code> 或 <code>.then(undefined, rejection)</code> 的别名，<strong>用于指定发生错误时的回调函数</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'rejected'</span>, err))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .then(<span class="literal">null</span>, err =&gt; <span class="built_in">console</span>.log(<span class="string">'rejected:'</span>, err))</span><br></pre></td></tr></table></figure><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。</p><p>最佳实践：一般来说，不要在 then 方法里面定义 <code>reject</code> 状态的回调函数（即 then 的第二个参数），总是使用 catch 方法。一般总是建议，Promise 对象后面要跟 catch 方法，这样可以处理 Promise 内部发生的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p>finally 方法用于指定不管 Promise 对象最后状态如何，<strong>都会执行的操作</strong>。该方法是 ES2018 引入标准的。</p><p>我们一般在 finally 方法中关闭服务和资源。</p><p>finally 方法的回调函数不接受任何参数，这意味着没有办法知道前面的 Promise 状态到底是 fulfilled 还是 rejected。这表明，finally 方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>finally 本质上是 then 方法的特例。如果不使用 finally 方法，同样的语句需要为成功和失败两种情况各写一次。有了 finally 方法，则只需要写一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">  .finally(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 都会执行的操作</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">promise.then(</span><br><span class="line">  result &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 都会执行的操作</span><br><span class="line">    return result</span><br><span class="line">  &#125;,</span><br><span class="line">  error &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 都会执行的操作</span><br><span class="line">    throw error</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">promise</span><br><span class="line">  .then(result &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 都会执行的操作</span><br><span class="line">    return result</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 都会执行的操作</span><br><span class="line">    throw error</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>Promise.prototype.finally() 底层实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.finally &#x3D; function(callback) &#123;</span><br><span class="line">  let P &#x3D; this.constructor</span><br><span class="line">  return this.then(</span><br><span class="line">    value &#x3D;&gt; P.resolve(callback()).then(() &#x3D;&gt; value),</span><br><span class="line">    reason &#x3D;&gt; P.resolve(callback()).then(() &#x3D;&gt; throw reason),</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例（<strong>并发请求</strong>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 实例。p 的状态由 p1、p2、p3 决定，分成两种情况。</p><ol><li>只有p1、p2、p3的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</li><li>只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncThing</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里假如是一个异步操作</span></span><br><span class="line">    value &gt; <span class="number">10</span> ? resolve(value) : reject(value)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([someAsyncThing(<span class="number">11</span>), someAsyncThing(<span class="number">12</span>)])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sussess '</span> + res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error '</span> + err)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// sussess [11,12]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([someAsyncThing(<span class="number">11</span>), someAsyncThing(<span class="number">10</span>)])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sussess '</span> + res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error '</span> + err)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// error 10</span></span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><blockquote><p>race：赛跑</p></blockquote><p>Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</p><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>Promise.resolve 方法用于将现有对象转为 Promise 对象。</p><p>Promise.race 方法的参数与 Promise.all 方法一样，如果不是 Promise 实例，就会先调用 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将 jQuery 生成的 deferred 对象，转为一个新的 Promise 对象</span><br><span class="line">const jsPromise &#x3D; Promise.resolve($.ajax(&#39;&#x2F;whatever.json&#39;));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#39;foo&#39;)</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">new Promise(resolve &#x3D;&gt; resolve(&#39;foo&#39;))</span><br></pre></td></tr></table></figure><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p>Promise.reject(reason) 方法也会返回一个新的 Promise 实例，该实例的状态为 rejected。</p><h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><p>让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const f &#x3D; () &#x3D;&gt; console.log(&#39;now&#39;);</span><br><span class="line">Promise.try(f);</span><br><span class="line">console.log(&#39;next&#39;);</span><br><span class="line">&#x2F;&#x2F; now</span><br><span class="line">&#x2F;&#x2F; next</span><br></pre></td></tr></table></figure><h2 id="Promise-库"><a href="#Promise-库" class="headerlink" title="Promise 库"></a>Promise 库</h2><p>Bluebird：<a href="http://bluebirdjs.com/docs/api/promise.try.html" target="_blank" rel="noopener">http://bluebirdjs.com/docs/api/promise.try.html</a></p><p>Q：<a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">https://github.com/kriskowal/q</a></p><p>when：<a href="https://github.com/cujojs/when" target="_blank" rel="noopener">https://github.com/cujojs/when</a></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>Promise 新建后就会立即执行</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolved.'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    i == <span class="number">9999</span> &amp;&amp; resolve()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 3 5 4 1</span></span><br></pre></td></tr></table></figure><ol start="2"><li>调用 resolve 或 reject 并不会终结 Promise 的参数函数的执行。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>一般来说，调用 resolve 或 reject 以后，Promise 的使命就完成了，后继操作应该放到 then 方法里面，而不应该直接写在 resolve 或 reject 的后面。所以，最好在它们前面加上 return 语句，这样就不会有意外。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  return resolve(1)</span><br><span class="line">  &#x2F;&#x2F; 后面的语句不会执行</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>Promise 的 <code>resolve</code> 函数的参数是另一个 Promise 实例。即一个 Promise p1 的结果是返回另一个 Promise p2，那么 p1 的状态由 p2 决定。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表现：3s 后打印 "Error: fail"</span></span><br></pre></td></tr></table></figure><ol start="4"><li>Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'everything is great'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><ol start="5"><li>如果 Promise 状态已经变成 resolved，再抛出错误是无效的，即不会被捕获。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Promise-对象简介&quot;&gt;&lt;a href=&quot;#Promise-对象简介&quot; class=&quot;headerlink&quot; title=&quot;Promise 对象简介&quot;&gt;&lt;/a&gt;Promise 对象简介&lt;/h2&gt;&lt;p&gt;Promise 是异步编程的一种更优的解决方案，一定程度上解决了回调函数产生的“&lt;strong&gt;回调地狱&lt;/strong&gt;”的问题。Promise 最早由社区提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 &lt;code&gt;Promise&lt;/code&gt; 对象。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。&lt;/p&gt;
&lt;p&gt;==Promise 允许将回调函数的嵌套改成&lt;strong&gt;链式调用&lt;/strong&gt;，即用同步的方式去写异步代码，使异步代码看起来像是线性结构。==&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://ws1.sinaimg.cn/large/9823cde9gy1g4nth71v66j20kg0ckaad.jpg&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://bxm0927.github.io/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="https://bxm0927.github.io/tags/ES6/"/>
    
      <category term="JavaScript" scheme="https://bxm0927.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6 学习笔记（下）</title>
    <link href="https://bxm0927.github.io/2019/04/16/blog/"/>
    <id>https://bxm0927.github.io/2019/04/16/blog/</id>
    <published>2019-04-16T13:03:22.000Z</published>
    <updated>2019-06-03T09:29:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>==ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型。==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s &#x3D; Symbol();</span><br><span class="line">typeof s &#x2F;&#x2F; &quot;symbol&quot;</span><br></pre></td></tr></table></figure><p>调用 Symbol() 方法将创建一个新的 Symbol 类型的值，并且该值不与其它任何值相等，每个 Symbol 都是独一无二的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 没有参数的情况</span><br><span class="line">let s1 &#x3D; Symbol();</span><br><span class="line">let s2 &#x3D; Symbol();</span><br><span class="line">s1 &#x3D;&#x3D;&#x3D; s2 &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 有参数的情况</span><br><span class="line">let s1 &#x3D; Symbol(&#39;foo&#39;);</span><br><span class="line">let s2 &#x3D; Symbol(&#39;foo&#39;);</span><br><span class="line">s1 &#x3D;&#x3D;&#x3D; s2 &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><p>用途：</p><ul><li>扩展对象属性名：ES5 的对象属性名都是字符串，这容易造成属性名的冲突。</li></ul><h2 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h2><p>ES6 提供了新的数据结构 Set、Map 来弥补 ES5 在数据结构上的不足，类似 Java 的 Map 和 Set。</p><p>JS 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了 Map 和 Set，这样就有了四种数据集合。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>==使用建议：若每一个集合中的元素都是唯一的，这时就用 Set 不用 Array。==</p><p>Set 结构的实例有以下属性。</p><ol><li>Set.prototype.constructor：构造函数，默认就是 Set 函数。</li><li>Set.prototype.size：返回 Set 实例的成员总数。</li></ol><p>Set 实例的操作方法:</p><ol><li>add(value)：添加某个值，返回 Set 结构本身。</li><li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li><li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员。</li><li>clear()：清除所有成员，没有返回值。</li></ol><p>Set 实例的遍历方法:</p><ol><li>keys()：返回键名的遍历器</li><li>values()：返回键值的遍历器</li><li>entries()：返回键值对的遍历器</li><li>forEach()：使用回调函数遍历每个成员</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const s &#x3D; new Set();</span><br><span class="line">[2, 3, 5, 4, 5, 2, 2].forEach(x &#x3D;&gt; s.add(x));</span><br><span class="line">s &#x2F;&#x2F; Set(4) &#123;2, 3, 5, 4&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">let list &#x3D; new Set();</span><br><span class="line">[2, 3, 5, 4, 5, 2, 2].forEach(x &#x3D;&gt; list.add(x));</span><br><span class="line">for (let i of list) &#123;</span><br><span class="line">    console.log(i); &#x2F;&#x2F; 2 3 5 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加</span><br><span class="line">list.add(x)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取 Set 的长度</span><br><span class="line">list.size</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断是否存在某值</span><br><span class="line">list.has(3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除</span><br><span class="line">list.delete(1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 清空</span><br><span class="line">list.clear()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历</span><br><span class="line">for (let i of list) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let [key, value] of list.entries()) &#123;</span><br><span class="line">    console.log(&#96;$&#123;key&#125;,$&#123;value&#125;&#96;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.forEach((item) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Set 用途：</p><ul><li>数组去重</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p><p>也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><p>==使用建议：一般的，只有在模拟现实世界的实体对象时，才使用 Object。如果只是需要<code>key: value</code>形式的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。==</p><p>Map 操作方法：</p><ul><li>size</li><li>set(key, value)</li><li>get(key)</li><li>has(key)</li><li>delete(key)</li><li>clear()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明、添加</span><br><span class="line">let list &#x3D; new Map();</span><br><span class="line">list.set(&#39;key&#39;,&#39;value&#39;);</span><br><span class="line">console.log(list); &#x2F;&#x2F; &#123;&quot;key&quot; &#x3D;&gt; &quot;value&quot;&#125;</span><br><span class="line"></span><br><span class="line">let arr &#x3D; [[&#39;k1&#39;, &#39;v1&#39;], [&#39;k2&#39;, &#39;v2&#39;], [&#39;k3&#39;, &#39;v3&#39;]];</span><br><span class="line">let list &#x3D; new Map(arr);</span><br><span class="line">console.log(list); &#x2F;&#x2F; &#123;&quot;k1&quot; &#x3D;&gt; &quot;v1&quot;, &quot;k2&quot; &#x3D;&gt; &quot;v2&quot;, &quot;k3&quot; &#x3D;&gt; &quot;v3&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取 Map 的长度</span><br><span class="line">list.size</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取</span><br><span class="line">list.get(&#39;key&#39;); &#x2F;&#x2F; value</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断是否存在某值</span><br><span class="line">list.has(&#39;key&#39;); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除</span><br><span class="line">list.delete(&#39;key&#39;); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 清空</span><br><span class="line">list.clear();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历</span><br><span class="line">for (let i of list) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let [key, value] of list.entries()) &#123;</span><br><span class="line">    console.log(&#96;$&#123;key&#125;,$&#123;value&#125;&#96;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.forEach((item) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Proxy-代理器"><a href="#Proxy-代理器" class="headerlink" title="Proxy 代理器"></a>Proxy 代理器</h2><blockquote><p>代理（Proxy）和反射（Reflect）是 Java 框架的底层原理。</p><ul><li>代理(Proxy)是一种设计模式，提供了对目标对象另外的访问方式，即通过代理对象访问目标对象。<br>这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。<br>核心思想：不要随意去修改别人已经写好的代码或者方法，如果需改修改，可以通过代理的方式来扩展该方法</li><li>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；<br>对于任意一个对象，都能够调用它的任意方法和属性；<br>这种动态获取信息以及动态调用对象方法的功能称为 java 语言的反射机制</li></ul></blockquote><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，即用自己的定义覆盖了语言的原始定义。所以 Proxy 属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; new Proxy() 表示生成一个Proxy实例</span><br><span class="line">&#x2F;&#x2F; target 参数表示所要拦截的目标对象</span><br><span class="line">&#x2F;&#x2F; handler 参数也是一个对象，用来定制拦截行为。</span><br><span class="line">var proxy &#x3D; new Proxy(target, handler);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var proxy &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: function(target, property) &#123;</span><br><span class="line">    return 35;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time &#x2F;&#x2F; 35</span><br><span class="line">proxy.name &#x2F;&#x2F; 35</span><br><span class="line">proxy.title &#x2F;&#x2F; 35</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 原始对象</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    name: &#39;白小明&#39;,</span><br><span class="line">    age: 22</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新建一个 Proxy 实例</span><br><span class="line">let objProxy &#x3D; new Proxy(obj, &#123;</span><br><span class="line">    &#x2F;&#x2F; 拦截对象属性的读取</span><br><span class="line">    get(target, key) &#123;</span><br><span class="line">        return target[key].replace(&#39;白小明&#39;, &#39;小明&#39;);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 拦截对象设置属性</span><br><span class="line">    set(target, key, value) &#123;</span><br><span class="line">        if (key &#x3D;&#x3D;&#x3D; &#39;name&#39;) &#123;</span><br><span class="line">            return (target[key] &#x3D; value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return target[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(objProxy.name); &#x2F;&#x2F; 小明</span><br><span class="line"></span><br><span class="line">objProxy.name &#x3D; &#39;小白&#39;;</span><br><span class="line">objProxy.age &#x3D; 18;</span><br><span class="line">console.log(objProxy); &#x2F;&#x2F; Proxy &#123;name: &quot;小白&quot;, age: 22&#125;</span><br></pre></td></tr></table></figure><h2 id="Reflect-反射器"><a href="#Reflect-反射器" class="headerlink" title="Reflect 反射器"></a>Reflect 反射器</h2><p>Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API。</p><p>Reflect 对象的方法与 Proxy 对象的方法一一对应，只是 Reflect 不用 new</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reflect.get(target, key) &#123;&#125;</span><br><span class="line">Reflect.set(target, key, value) &#123;&#125;</span><br></pre></td></tr></table></figure><p>Reflect 对象的设计目的有这样几个。</p><ol><li>将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。也就是说，从 Reflect 对象上可以拿到语言内部的方法。</li><li>修改某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 老写法</span><br><span class="line">&#39;assign&#39; in Object &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 新写法</span><br><span class="line">Reflect.has(Object, &#39;assign&#39;) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h2 id="Decorator-装饰器"><a href="#Decorator-装饰器" class="headerlink" title="Decorator 装饰器"></a>Decorator 装饰器</h2><p>Decorator 是一个函数，用来修改类的行为。许多面向对象的语言都有修饰器的特性，如 Java 的注解机制。</p><p>目前，该功能还是一个提案。可以使用一个 babel 插件来让 babel 支持 Decorator 函数，并设置 .babelrc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-plugin-transform-decorators-legacy --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">        &quot;es2015&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;babel-plugin-transform-decorators-legacy&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例：使用-Decorator-函数限制某个属性是只读的"><a href="#实例：使用-Decorator-函数限制某个属性是只读的" class="headerlink" title="实例：使用 Decorator 函数限制某个属性是只读的"></a>实例：使用 Decorator 函数限制某个属性是只读的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 实例：使用 Decorator 函数限制某个属性是只读的</span><br><span class="line"> * @param &#123;*&#125; target 修改的类</span><br><span class="line"> * @param &#123;*&#125; name 修改的类的属性</span><br><span class="line"> * @param &#123;*&#125; descriptor 该属性的描述对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">let readOnly &#x3D; (target, name, descriptor) &#x3D;&gt; &#123;</span><br><span class="line">    descriptor.writable &#x3D; false;</span><br><span class="line">    return descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test &#123;</span><br><span class="line">    @readOnly</span><br><span class="line">    say() &#123;</span><br><span class="line">        console.log(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let t &#x3D; new Test();</span><br><span class="line"></span><br><span class="line">t.say();</span><br><span class="line">&#x2F;&#x2F; hello</span><br><span class="line"></span><br><span class="line">t.say &#x3D; () &#x3D;&gt; &#123; console.log(&quot;hello2&quot;); &#125;</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: Cannot assign to read only property &#39;say&#39; of object &#39;#&lt;Test&gt;&#39;</span><br></pre></td></tr></table></figure><h3 id="实例：使用-Decorator-函数实现前端埋点"><a href="#实例：使用-Decorator-函数实现前端埋点" class="headerlink" title="实例：使用 Decorator 函数实现前端埋点"></a>实例：使用 Decorator 函数实现前端埋点</h3><p>将埋点逻辑与业务逻辑解耦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 实例：使用 Decorator 函数实现前端日志埋点</span><br><span class="line"> * @param &#123;*&#125; target 修改的类</span><br><span class="line"> * @param &#123;*&#125; name 修改的类的属性</span><br><span class="line"> * @param &#123;*&#125; descriptor 该属性的描述对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">let logBurying &#x3D; (type) &#x3D;&gt; &#123;</span><br><span class="line">    return (target, name, descriptor) &#x3D;&gt; &#123;</span><br><span class="line">        let originMethod &#x3D; descriptor.value; &#x2F;&#x2F; 原始函数体</span><br><span class="line"></span><br><span class="line">        descriptor.value &#x3D; (...args) &#x3D;&gt; &#123;</span><br><span class="line">            originMethod.apply(target, args);</span><br><span class="line">            console.info(&#96;logBurying $&#123;type&#125;&#96;); &#x2F;&#x2F; 模拟埋点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AD &#123;</span><br><span class="line">    @logBurying(&quot;show&quot;)</span><br><span class="line">    show() &#123;</span><br><span class="line">        console.log(&quot;show&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @logBurying(&quot;click&quot;)</span><br><span class="line">    click() &#123;</span><br><span class="line">        console.log(&quot;click&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let t &#x3D; new AD();</span><br><span class="line"></span><br><span class="line">t.show(); &#x2F;&#x2F; show, logBurying show</span><br><span class="line">t.click(); &#x2F;&#x2F; click, logBurying click</span><br></pre></td></tr></table></figure><h3 id="core-decorators"><a href="#core-decorators" class="headerlink" title="core-decorators"></a>core-decorators</h3><p>core-decorators 是一个第三方库，实现了许多实用的 Decorator 函数。</p><p><a href="https://github.com/jayphelps/core-decorators" target="_blank" rel="noopener">https://github.com/jayphelps/core-decorators</a></p><h2 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h2><ul><li><input checked="" disabled="" type="checkbox"> ==Iterator（迭代器）的概念==</li></ul><p>JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了 Map 和 Set，这样就有了四种数据集合。</p><p>Iterator（迭代器）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员），我们就称这种数据结构是“可遍历的”（iterable）。</p><p>原生具备 Iterator 接口的数据结构如下：Array、Map、Set、String、TypedArray、函数的 arguments 对象、NodeList 对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 字符串</span><br><span class="line">let str &#x3D; &quot;hello&quot;;</span><br><span class="line">for (let s of str) &#123;</span><br><span class="line">  console.log(s); &#x2F;&#x2F; h e l l o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; DOM NodeList对象</span><br><span class="line">let paras &#x3D; document.querySelectorAll(&quot;p&quot;);</span><br><span class="line">for (let p of paras) &#123;</span><br><span class="line">  p.classList.add(&quot;test&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; arguments对象</span><br><span class="line">function printArgs() &#123;</span><br><span class="line">  for (let x of arguments) &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printArgs(&#39;a&#39;, &#39;b&#39;);</span><br><span class="line">&#x2F;&#x2F; &#39;a&#39;</span><br><span class="line">&#x2F;&#x2F; &#39;b&#39;</span><br></pre></td></tr></table></figure><p>扩展运算符会默认调用 Iterator 接口，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 例一</span><br><span class="line">var str &#x3D; &#39;hello&#39;;</span><br><span class="line">[...str] &#x2F;&#x2F;  [&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 例二</span><br><span class="line">let arr &#x3D; [&#39;b&#39;, &#39;c&#39;];</span><br><span class="line">[&#39;a&#39;, ...arr, &#39;d&#39;]</span><br><span class="line">&#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span><br></pre></td></tr></table></figure><p>ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费。Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即 for…of 循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;];</span><br><span class="line"></span><br><span class="line">for(let v of arr) &#123;</span><br><span class="line">  console.log(v); &#x2F;&#x2F; red green blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for…of 循环可以代替数组实例的 forEach 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;];</span><br><span class="line"></span><br><span class="line">for(let v of arr) &#123;</span><br><span class="line">  console.log(v); &#x2F;&#x2F; red green blue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach(function (element, index) &#123;</span><br><span class="line">  console.log(element); &#x2F;&#x2F; red green blue</span><br><span class="line">  console.log(index);   &#x2F;&#x2F; 0 1 2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h2><blockquote><p>参考《前端通讯——异步编程 · 解决方案》</p></blockquote><h2 id="Generator-状态机"><a href="#Generator-状态机" class="headerlink" title="Generator 状态机"></a>Generator 状态机</h2><blockquote><p>参考《前端通讯——异步编程 · 解决方案》</p></blockquote><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><blockquote><p>参考《前端通讯——异步编程 · 解决方案》</p></blockquote><h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><blockquote><p>参考《JavaScript 面向对象》</p></blockquote><h2 id="Module-模块化"><a href="#Module-模块化" class="headerlink" title="Module 模块化"></a>Module 模块化</h2><blockquote><p>参考前端模块化</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;Symbol&quot;&gt;&lt;a href=&quot;#Symbol&quot; class=&quot;headerlink&quot; title=&quot;Symbol&quot;&gt;&lt;/a&gt;Symbol&lt;/h2&gt;&lt;p&gt;==ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 Ja
      
    
    </summary>
    
    
      <category term="JS" scheme="https://bxm0927.github.io/categories/JS/"/>
    
    
      <category term="HTML" scheme="https://bxm0927.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://bxm0927.github.io/tags/CSS/"/>
    
      <category term="JS" scheme="https://bxm0927.github.io/tags/JS/"/>
    
      <category term="ES6" scheme="https://bxm0927.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 学习笔记（上）</title>
    <link href="https://bxm0927.github.io/2019/04/15/blog/"/>
    <id>https://bxm0927.github.io/2019/04/15/blog/</id>
    <published>2019-04-15T14:43:29.000Z</published>
    <updated>2019-06-12T09:29:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><p>ES6 加强了对 Unicode 的支持，并且扩展了 String 字符串对象，解决了 ES5 在字符串功能上的痛点。</p><p>最佳实践：静态字符串一律使用单引号，不使用双引号。动态字符串使用模板字符串。</p><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串第一个用途：字符串拼接。将表达式嵌入字符串中进行拼接，用 ``和<code>\${}</code>来界定。这使得事情变得更简单，代码更容易阅读。你可以在花括号内放置任何东西：变量、方程式或函数调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; es5</span><br><span class="line">var name1 &#x3D; &quot;bai&quot;;</span><br><span class="line">console.log(&#39;hello &#39; + name1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; es6</span><br><span class="line">const name2 &#x3D; &quot;ming&quot;;</span><br><span class="line">console.log(&#96;hello $&#123;name2&#125;&#96;);</span><br></pre></td></tr></table></figure><p>模板字符串第二个用途：在 ES5 时我们通过反斜杠来做多行字符串拼接。ES6 模板字符串直接搞定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; es5</span><br><span class="line">var msg &#x3D; &quot;Hi \</span><br><span class="line">man!&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; es6</span><br><span class="line">const template &#x3D; &#96;&lt;div&gt;</span><br><span class="line">    &lt;span&gt;hello world&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;&#96;;</span><br></pre></td></tr></table></figure><p>模板字符串之中还能调用函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">  return &quot;Hello World&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&#96;输出值为：$&#123;fn()&#125;&#96;) &#x2F;&#x2F; &quot;输出值为：Hello World&quot;</span><br></pre></td></tr></table></figure><h3 id="字符串扩展方法"><a href="#字符串扩展方法" class="headerlink" title="字符串扩展方法"></a>字符串扩展方法</h3><p>传统上，JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p><ul><li>includes()：返回布尔值，判断数组、字符串是否包含某个元素。</li><li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><p>includes() 可以代替 indexOf()，endsWith() 可以用来检测文件后缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; includes: 判断是否包含然后返回布尔值</span><br><span class="line">&#39;hahah&#39;.includes(&#39;y&#39;) &#x2F;&#x2F; false</span><br><span class="line">[&#39;1&#39;,&#39;y&#39;].includes(&#39;y&#39;) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES5 indexOf</span><br><span class="line">let arr &#x3D; [&#39;react&#39;, &#39;angular&#39;, &#39;vue&#39;];</span><br><span class="line"></span><br><span class="line">if (arr.indexOf(&#39;react&#39;) !&#x3D;&#x3D; -1) &#123;</span><br><span class="line">  console.log(&#39;React存在&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 includes</span><br><span class="line">let arr &#x3D; [&#39;react&#39;, &#39;angular&#39;, &#39;vue&#39;];</span><br><span class="line"></span><br><span class="line">if (arr.includes(&#39;react&#39;)) &#123;</span><br><span class="line">  console.log(&#39;React存在&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; repeat: 字符串重复n次</span><br><span class="line">console.log(&#39;he&#39;.repeat(3)); &#x2F;&#x2F; &#39;hehehe&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 开始字符</span><br><span class="line">console.log(&#39;abcd&#39;.startsWith(&#39;aa&#39;)); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 结束字符</span><br><span class="line">console.log(&#39;abcd&#39;.endsWith(&#39;cd&#39;)); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; padStart、padEnd 长度不足就补</span><br><span class="line">let date &#x3D; new Date();</span><br><span class="line">let month &#x3D; date.getMonth() + 1;</span><br><span class="line">console.log(month.toString().padStart(2, &#39;0&#39;)); &#x2F;&#x2F; 06</span><br><span class="line"></span><br><span class="line">console.log(&#39;123&#39;.padStart(11, &#39;0&#39;)); &#x2F;&#x2F; 00000000123</span><br><span class="line">console.log(&#39;123&#39;.padEnd(11, &#39;0&#39;)); &#x2F;&#x2F; 12300000000</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; padStart ES5实现</span><br><span class="line">padStart(num, n &#x3D; 2, str &#x3D; &#39;0&#39;) &#123;</span><br><span class="line">  let len &#x3D; num.toString().length</span><br><span class="line">  while (len &lt; n) &#123;</span><br><span class="line">    num &#x3D; str + num</span><br><span class="line">    len++</span><br><span class="line">  &#125;</span><br><span class="line">  return num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h2><h3 id="y-修饰符"><a href="#y-修饰符" class="headerlink" title="y 修饰符"></a>y 修饰符</h3><p>y 修饰符的作用与 g 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配<strong>必须从剩余的第一个位置开始</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s&#x3D; &#39;bbb_bb_b&#39;;</span><br><span class="line">let reg1 &#x3D; &#x2F;b+&#x2F;g;</span><br><span class="line">let reg2 &#x3D; &#x2F;b+&#x2F;y;</span><br><span class="line">console.log(reg1.exec(s), reg2.exec(s)); &#x2F;&#x2F; [&quot;bbb&quot;, index: 0, input: &quot;bbb_bb_b&quot;] [&quot;bbb&quot;, index: 0, input: &quot;bbb_bb_b&quot;]</span><br><span class="line">console.log(reg1.exec(s), reg2.exec(s)); &#x2F;&#x2F; [&quot;bb&quot;, index: 4, input: &quot;bbb_bb_b&quot;] null</span><br></pre></td></tr></table></figure><h3 id="u-修饰符"><a href="#u-修饰符" class="headerlink" title="u 修饰符"></a>u 修饰符</h3><p>含义为“Unicode 模式”，用来正确处理大于\uFFFF 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;^\uD83D&#x2F;u.test(&#39;\uD83D\uDC2A&#39;) &#x2F;&#x2F; false</span><br><span class="line">&#x2F;^\uD83D&#x2F;.test(&#39;\uD83D\uDC2A&#39;) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h3 id="s-修饰符"><a href="#s-修饰符" class="headerlink" title="s 修饰符"></a>s 修饰符</h3><p>dotAll 模式</p><h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><h3 id="Number-新增数值方法"><a href="#Number-新增数值方法" class="headerlink" title="Number 新增数值方法"></a>Number 新增数值方法</h3><p>注意 Number.isFinite() 和 Number.isNaN() 与传统的全局方法 isFinite() 和 isNaN() 的区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; isFinite: 判断一个数值是否是有尽的</span><br><span class="line">console.log(Number.isFinite(100)); &#x2F;&#x2F; true</span><br><span class="line">console.log(Number.isFinite(100 &#x2F; 0)); &#x2F;&#x2F; false</span><br><span class="line">console.log(Number.isFinite(NaN)); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; isNaN: 判断一个数值是否是一个非数值</span><br><span class="line">console.log(Number.isNaN(NaN)); &#x2F;&#x2F; true</span><br><span class="line">console.log(Number.isNaN(100)); &#x2F;&#x2F; false</span><br><span class="line">console.log(Number.isNaN(100 &#x2F; 0)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> Number.parseInt(), Number.parseFloat()</li></ul><p>ES6 将全局方法 parseInt() 和 parseFloat()，移植到 Number 对象上面，行为完全保持不变。</p><ul><li><input checked="" disabled="" type="checkbox"> Number.isInteger()：用来判断一个数值是否为整数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; isInteger: 判断一个数值是否是一个整数</span><br><span class="line">console.log(Number.isInteger(100)); &#x2F;&#x2F; true</span><br><span class="line">console.log(Number.isInteger(100.0)); &#x2F;&#x2F; true</span><br><span class="line">console.log(Number.isInteger(100.5)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><h3 id="Math-新增数学方法"><a href="#Math-新增数学方法" class="headerlink" title="Math 新增数学方法"></a>Math 新增数学方法</h3><p>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p><ul><li>Math.trunc 方法用于去除一个数的小数部分，返回整数部分。</li><li>Math.sign 方法用来判断一个数到底是正数、负数、还是零。</li><li>Math.cbrt 方法用于计算一个数的立方根。</li><li>Math.hypot 方法返回所有参数的平方和的平方根。</li><li>ES6 新增了 4 个对数相关方法。</li><li>ES6 新增了 6 个双曲函数方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; trunc: 返回整数部分</span><br><span class="line">console.log(Math.trunc(4)); &#x2F;&#x2F; 4</span><br><span class="line">console.log(Math.trunc(4.1)); &#x2F;&#x2F; 4</span><br><span class="line">console.log(Math.trunc(-1.9)); &#x2F;&#x2F; -1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回数值符号</span><br><span class="line">console.log(Math.sign(-5)); &#x2F;&#x2F; -1</span><br><span class="line">console.log(Math.sign(0)); &#x2F;&#x2F; 0</span><br><span class="line">console.log(Math.sign(5)); &#x2F;&#x2F; 1</span><br><span class="line">console.log(Math.sign(&#39;abc&#39;)); &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure><h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h3><p>ES2016 新增了一个指数运算符（<code>**</code>），类似 <code>Math.pow</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5</span><br><span class="line">Math.pow(2, 3) &#x2F;&#x2F; 8</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6</span><br><span class="line">2 ** 3 &#x2F;&#x2F; 8</span><br></pre></td></tr></table></figure><p>指数运算符可以与赋值运算符结合，形成一个新的赋值运算符（**=）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 1.5;</span><br><span class="line">a **&#x3D; 2;</span><br><span class="line">&#x2F;&#x2F; 等同于 a &#x3D; a * a;</span><br><span class="line"></span><br><span class="line">let b &#x3D; 4;</span><br><span class="line">b **&#x3D; 3;</span><br><span class="line">&#x2F;&#x2F; 等同于 b &#x3D; b * b * b;</span><br></pre></td></tr></table></figure><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><p>==rest 参数可以理解为聚拢，扩展运算符可以理解为“展开”==。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(...args) &#123;</span><br><span class="line">    console.log(...args);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">foo(1, 2, 3); &#x2F;&#x2F; 1, 2, 3</span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [first, ...rest] &#x3D; [1, 2, 3, 4, 5];</span><br></pre></td></tr></table></figure><p>用途：数组合并的新写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的合并数组</span></span><br><span class="line">arr1.concat(arr2, arr3) <span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的合并数组</span></span><br><span class="line">;[...arr1, ...arr2, ...arr3] <span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br></pre></td></tr></table></figure><p>用途：复制数组的新写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const a1 &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">const a2 &#x3D; [...a1];</span><br><span class="line">a2[0] &#x3D; 2;</span><br><span class="line">a1 &#x2F;&#x2F; [1, 2]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">const [...a2] &#x3D; a1;</span><br><span class="line">a2[0] &#x3D; 2;</span><br><span class="line">a1 &#x2F;&#x2F; [1, 2]</span><br></pre></td></tr></table></figure><p>用途：获取数组除了某几项的其他项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let num &#x3D; [1, 3, 5, 7, 9];</span><br><span class="line">let [first, second, ...rest] &#x3D; num;</span><br><span class="line">rest; &#x2F;&#x2F; [5, 7, 9]</span><br></pre></td></tr></table></figure><p>用途：函数调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var numbers &#x3D; [4, 38];</span><br><span class="line">add(...numbers) &#x2F;&#x2F; 42</span><br></pre></td></tr></table></figure><h3 id="数组扩展方法"><a href="#数组扩展方法" class="headerlink" title="数组扩展方法"></a>数组扩展方法</h3><p>Array.from 方法用于将两类对象转为真正的数组：</p><ol><li>类似数组的对象（如 String、NodeList、arguments），所谓类似数组的对象，本质特征只有一点，即必须有 length 属性。</li><li>可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike) <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike) <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure><p>Array.of 方法用于将一组值，转换为数组。Array.of 基本上可以用来替代 Array()或 new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.of()); &#x2F;&#x2F; []</span><br><span class="line">console.log(Array.of(1, 3, 5, 7, 9)); &#x2F;&#x2F; [1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure><p>数组实例的 find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined</p><p>数组实例的 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log([1, 4, -5, -1, 10].find((n) &#x3D;&gt; n &lt; 0)); &#x2F;&#x2F; -5</span><br><span class="line">console.log([1, 4, -5, -1, 10].findIndex((n) &#x3D;&gt; n &lt; 0)); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure><p>fill 方法使用给定值，填充一个数组。常用于空数组的初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)); &#x2F;&#x2F; [7, 7, 7]</span><br><span class="line">console.log(new Array(3).fill(7)); &#x2F;&#x2F; [7, 7, 7]</span><br></pre></td></tr></table></figure><p>entries()，keys()和 values()——用于遍历数组，它们都返回一个遍历器对象。keys()是对键名（索引）的遍历、values()是对键值的遍历，entries()是对键值对的遍历。可以配合 for…of 循环进行遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) &#123;</span><br><span class="line">    console.log(index); &#x2F;&#x2F; 0 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) &#123;</span><br><span class="line">    console.log(elem); &#x2F;&#x2F; a b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) &#123;</span><br><span class="line">    console.log(index, elem); &#x2F;&#x2F; 0 &quot;a&quot;    1 &quot;b&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 includes 方法类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log([1, 2, 3].includes(2)); &#x2F;&#x2F; true</span><br><span class="line">console.log([1, 2, 3].includes(4)); &#x2F;&#x2F; false</span><br><span class="line">console.log([1, 2, NaN].includes(NaN)); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>Array.prototype.flat 方法用于将嵌套的数组“拉平”，变成一维的数组。</p><h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><h3 id="对象属性的简洁表示法"><a href="#对象属性的简洁表示法" class="headerlink" title="对象属性的简洁表示法"></a>对象属性的简洁表示法</h3><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5</span><br><span class="line">var o &#x3D; 1,</span><br><span class="line">    k &#x3D; 2;</span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">    o: o,</span><br><span class="line">    k: k,</span><br><span class="line">    name: &#39;bxm&#39;,</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6</span><br><span class="line">let c &#x3D; 1,</span><br><span class="line">    n &#x3D; 2;</span><br><span class="line">let obj2 &#x3D; &#123;</span><br><span class="line">    c, &#x2F;&#x2F; 等同于 c: c</span><br><span class="line">    n,</span><br><span class="line">    name: &#39;bai&#39;,</span><br><span class="line">    getName() &#123; &#x2F;&#x2F; 等同于 getName: function() &#123;&#125;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用途：</p><ul><li>用于函数的返回值</li><li>CommonJS 模块、ES6 模块输出一组变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getPoint() &#123;</span><br><span class="line">  const x &#x3D; 1;</span><br><span class="line">  const y &#x3D; 10;</span><br><span class="line">  return &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123; getItem, setItem, clear &#125;;</span><br></pre></td></tr></table></figure><h3 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h3><p>现在，对象的属性可以是一个变量或表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [i]: <span class="string">'value'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(obj)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Object &#123;0: "value"&#125;</span></span><br><span class="line"><span class="comment">// Object &#123;1: "value"&#125;</span></span><br><span class="line"><span class="comment">// Object &#123;2: "value"&#125;</span></span><br><span class="line"><span class="comment">// Object &#123;3: "value"&#125;</span></span><br><span class="line"><span class="comment">// Object &#123;4: "value"&#125;</span></span><br></pre></td></tr></table></figure><p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  id: <span class="number">5</span>,</span><br><span class="line">  name: <span class="string">'San Francisco'</span>,</span><br><span class="line">&#125;</span><br><span class="line">obj[getKey(<span class="string">'enabled'</span>)] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  id: <span class="number">5</span>,</span><br><span class="line">  name: <span class="string">'San Francisco'</span>,</span><br><span class="line">  [getKey(<span class="string">'enabled'</span>)]: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h3><p>Object.keys()，Object.values()，Object.entries()</p><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>Object.assign() 又叫做==浅拷贝==，用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign() 的第一个参数是目标对象，后面的参数都是源对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123; <span class="attr">a</span>: <span class="string">'1'</span> &#125;, &#123; <span class="attr">b</span>: <span class="string">'2'</span> &#125;) <span class="comment">// Object &#123;a: "1", b: "2"&#125;</span></span><br></pre></td></tr></table></figure><p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2)</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p>最佳实践：在实际项目中，我们为了不改变源对象，一般会把目标对象传为<code>{}</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, objA, objB)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给对象添加属性</span></span><br><span class="line"><span class="keyword">this</span>.seller = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.seller, response.data)</span><br></pre></td></tr></table></figure><p>小技巧：扩展运算符也可以实现 Object.assign() 的功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aClone = &#123; ...a &#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aClone = <span class="built_in">Object</span>.assign(&#123;&#125;, a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b)</span><br></pre></td></tr></table></figure><p>用途：</p><ul><li>==为属性指定默认值，然后用来覆盖默认的配置选项（config）==</li><li>为对象添加属性和方法</li><li>合并多个对象</li><li>对象浅克隆</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultConfig, options)</span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>ES2017</p><p>返回指定对象的某个指定属性的属性描述符，该属性必须是对象自己定义而不是继承自原型链</p><p><code>Object.getOwnPropertyDescriptors()</code>相当于<code>Object.getOwnPropertyDescriptor()</code>的复数形式，可以获取对象的所有自身属性的描述符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[object Object] &#123;</span><br><span class="line"> configurable：当该值为true时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</span><br><span class="line"> enumerable：当且仅当该属性的 enumerable 为 true时，该属性才能够出现在对象的枚举属性中。默认为 false。</span><br><span class="line"> value</span><br><span class="line"> writable</span><br><span class="line"> get</span><br><span class="line"> set</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[object Object] &#123;</span><br><span class="line">    configurable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    value: [&quot;React Quickly&quot;],</span><br><span class="line">    writable:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>ES5 给函数定义参数默认值，使用的是短路运算，有一定缺陷和冗余。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5</span><br><span class="line">function foo(num) &#123;</span><br><span class="line">  num &#x3D; num || 200;</span><br><span class="line">  return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6</span><br><span class="line">function foo(num &#x3D; 200) &#123;</span><br><span class="line">  return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(&#123;x, y &#x3D; 5&#125; &#x3D; &#123;&#125;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() &#x2F;&#x2F; undefined 5</span><br></pre></td></tr></table></figure><p>通常情况下，默认值后面不能再有没有默认值的参数，即定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p><p>另外，可以将参数默认值设为 undefined，表明这个参数是可以省略的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function foo(optional &#x3D; undefined) &#123; ··· &#125;</span><br></pre></td></tr></table></figure><h3 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h3><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function rest(...args) &#123; console.log(args); &#125;</span><br><span class="line">rest(); &#x2F;&#x2F; []</span><br><span class="line">rest(1); &#x2F;&#x2F; [1]</span><br><span class="line">rest(1,2); &#x2F;&#x2F; [1, 2]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo(x, y, ...rest) &#123;</span><br><span class="line">    return ((x + y) * rest.length);</span><br><span class="line">&#125;</span><br><span class="line">foo(1, 2, &#39;hello&#39;, true, 7); &#x2F;&#x2F; 9</span><br></pre></td></tr></table></figure><p>最佳实践：不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">function concatenateAll() &#123;</span><br><span class="line">  const args &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">  return args.join(&#39;&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">function concatenateAll(...args) &#123;</span><br><span class="line">  return args.join(&#39;&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数，箭头函数是函数的快捷写法，使得表达更加简洁，有以下特性。</p><ul><li>不需要 function 关键字来创建函数</li><li>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分；</li><li>而当你的函数有且仅有一个参数的时候，是可以省略掉括号<code>()</code>的</li><li>当你函数中有且仅有一个表达式的时候，可以省略<code>return</code>语句和大括号<code>{}</code>；</li><li>而如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5</span><br><span class="line">var arr1 &#x3D; [1, 2, 3];</span><br><span class="line">var newArr1 &#x3D; arr1.map(function(x) &#123; return x + 1; &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6</span><br><span class="line">let arr2 &#x3D; [1, 2, 3];</span><br><span class="line">let newArr2 &#x3D; arr2.map((x) &#x3D;&gt; &#123; x + 1 &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 箭头函数使得表达更加简洁</span><br><span class="line">let isEven &#x3D; n &#x3D;&gt; n % 2 &#x3D;&#x3D; 0;</span><br><span class="line">let square &#x3D; n &#x3D;&gt; n * n;</span><br><span class="line">let f &#x3D; () &#x3D;&gt; 5; &#x2F;&#x2F; 等同于 let f &#x3D; function () &#123; return 5 &#125;;</span><br><span class="line">let f &#x3D; v &#x3D;&gt; v; &#x2F;&#x2F; 等同于 let f &#x3D; function (v) &#123; return v; &#125;;</span><br><span class="line">let sum &#x3D; (num1, num2) &#x3D;&gt; num1 + num2; &#x2F;&#x2F; 等同于 let sum &#x3D; function(num1, num2) &#123; return num1 + num2; &#125;;</span><br><span class="line">[1,2,3].map(x &#x3D;&gt; x * x); &#x2F;&#x2F; 等同于 [1,2,3].map(function (x) &#123; return x * x; &#125;);</span><br></pre></td></tr></table></figure><p>立即执行函数可以写成箭头函数的形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;Welcome to the Internet.&#39;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="箭头函数中的-this-绑定"><a href="#箭头函数中的-this-绑定" class="headerlink" title="箭头函数中的 this 绑定"></a>箭头函数中的 this 绑定</h3><p>箭头函数让复杂的 this 变得清晰：</p><ul><li>==箭头函数内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。即，this 对象的指向是可变的，但是在箭头函数中，它是固定的。==</li><li>箭头函数中的 this 继承当前上下文的 this 关键字，即箭头函数中 this 的作用域和外面是一样的，==并不产生新的作用域==。</li><li>本质上，箭头函数里面根本没有自己的 this，而是引用外层的 this。</li><li>箭头函数可以绑定 this 对象，大大减少了显式绑定 this 对象的写法（call、apply、bind）。</li><li>箭头函数取代 Function.prototype.bind，不应再用 self/_this/that 绑定 this。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 。运行下面的代码会报错，这是因为setTimeout中的this指向的是全局对象。</span><br><span class="line">class Animal &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.type &#x3D; &#39;animal&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    says(say) &#123;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            console.log(this.type + &#39; says &#39; + say);</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var animal &#x3D; new Animal();</span><br><span class="line">animal.says(&#39;hi&#39;); &#x2F;&#x2F;undefined says hi</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解决办法：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 传统方法1: 将this传给self,再用self来指代this</span><br><span class="line">says(say) &#123;</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(self.type + &#39; says &#39; + say);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 传统方法2: 用bind(this),即</span><br><span class="line">says(say) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(this.type + &#39; says &#39; + say);</span><br><span class="line">    &#125;.bind(this), 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6: 箭头函数</span><br><span class="line">says(say) &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(this.type + &#39; says &#39; + say);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h3><p>现在，函数参数与数组和对象的尾逗号规则，保持一致了。函数定义和调用时，尾部允许有一个逗号。这样可以避免一些不必要的报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function clownsEverywhere(</span><br><span class="line">  param1,</span><br><span class="line">  param2</span><br><span class="line">) &#123; &#x2F;* ... *&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">clownsEverywhere(</span><br><span class="line">  &#39;foo&#39;,</span><br><span class="line">  &#39;bar&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>编程风格：单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾，方便扩展。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">k1</span>: v1, <span class="attr">k2</span>: v2 &#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  k1: v1,</span><br><span class="line">  k2: v2,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">k1</span>: v1, <span class="attr">k2</span>: v2 &#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  k1: v1,</span><br><span class="line">  k2: v2,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h3><p>优化递归性能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字符串的扩展&quot;&gt;&lt;a href=&quot;#字符串的扩展&quot; class=&quot;headerlink&quot; title=&quot;字符串的扩展&quot;&gt;&lt;/a&gt;字符串的扩展&lt;/h2&gt;&lt;p&gt;ES6 加强了对 Unicode 的支持，并且扩展了 String 字符串对象，解决了 ES5 在字符串功能
      
    
    </summary>
    
    
      <category term="JS" scheme="https://bxm0927.github.io/categories/JS/"/>
    
    
      <category term="HTML" scheme="https://bxm0927.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://bxm0927.github.io/tags/CSS/"/>
    
      <category term="JS" scheme="https://bxm0927.github.io/tags/JS/"/>
    
      <category term="ES6" scheme="https://bxm0927.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 学习笔记（中）</title>
    <link href="https://bxm0927.github.io/2019/04/13/blog/"/>
    <id>https://bxm0927.github.io/2019/04/13/blog/</id>
    <published>2019-04-13T15:46:21.000Z</published>
    <updated>2019-06-22T02:28:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ECMAScript-简介"><a href="#ECMAScript-简介" class="headerlink" title="ECMAScript 简介"></a>ECMAScript 简介</h2><p>ECMAScript 是一种由 ECMA 国际的组织（European Computer Manufacturers Association，欧洲计算机制造商协会），通过 ECMA-262 标准化的脚本程序设计语言。而 JavaScript 是 ECMA-262 标准的实现和扩展。浏览器为 JavaScript 增加了 DOM 和 BOM 功能。</p><p>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。</p><p>ECMA-262 规定了 ECMAScript 语言的几个重要组成部分：</p><ol><li>基本语法</li><li>数据类型</li><li>语句</li><li>关键字</li><li>操作符</li><li>内置对象</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://note.youdao.com/yws/res/129431/FFF77AE770D2451F87A1D8EAA7F5D649" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="ECMAScript-版本"><a href="#ECMAScript-版本" class="headerlink" title="ECMAScript 版本"></a>ECMAScript 版本</h2><p>ECMAScript 3 是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript 语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习 JavaScript，其实就是在学 3.0 版的语法。</p><p>ECMAScript 6 从开始制定到最后发布，整整用了 15 年。</p><table><thead><tr><th>版本号</th><th>发布时间</th><th>内容</th></tr></thead><tbody><tr><td>ECMAScript 1</td><td>1997 年 06 月</td><td>首版</td></tr><tr><td>ECMAScript 2</td><td>1998 年 6 月</td><td>格式修正，以使得其形式与 ISO/IEC16262 国际标准一致</td></tr><tr><td>ECMAScript 3</td><td>1999 年 12 月</td><td>正则表达式，新的控制指令，异常处理，错误定义更加明确及其它改变</td></tr><tr><td>ECMAScript 4</td><td>2007 年 10 月</td><td>由于过于激进，各方对于是否通过这个标准，发生了严重分歧，最终没有发布通过。</td></tr><tr><td>ECMAScript 5</td><td>2009 年 12 月</td><td>和第 3 版标准不大，引进了一些夭折的 ECMAScript 4 的一些功能</td></tr><tr><td>ECMAscript 5.1</td><td>2011 年 6 月</td><td>成为 ISO 国际标准（ISO/IEC 16262:2011）。</td></tr><tr><td>ECMAScript 2015（ES2015、ES6）</td><td>2015 年 6 月 17 日</td><td>ECMAScript 的第六版修订，于 2015 年完成标准化。</td></tr><tr><td>ECMAScript 2016（ES2016）</td><td>2016 年 6 月</td><td>在 ES2015 基础上进行小幅修订</td></tr><tr><td>ECMAScript 2017（ES2017）</td><td>2017 年 6 月</td><td></td></tr><tr><td>ECMAScript 2018（ES2018）</td><td>2018 年 6 月</td><td></td></tr><tr><td>ECMAScript 2019（ES2019）</td><td>2019 年 6 月</td><td></td></tr></tbody></table><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://user-gold-cdn.xitu.io/2020/6/30/17305e482e2b7f3b?w=3486&h=810&f=png&s=199122" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://user-gold-cdn.xitu.io/2020/6/30/17305e4b914e68af?w=3486&h=1260&f=png&s=343038" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="ES6-与-ECMAScript-2015-的关系"><a href="#ES6-与-ECMAScript-2015-的关系" class="headerlink" title="ES6 与 ECMAScript 2015 的关系"></a>ES6 与 ECMAScript 2015 的关系</h2><p>ES6 泛指 ES 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等。而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。</p><p><a href="https://github.com/ruanyf/es6tutorial/blob/8240374c621ba0180b381c74c78198bf7107c433/docs/intro.md#es6-%E4%B8%8E-ecmascript-2015-%E7%9A%84%E5%85%B3%E7%B3%BB" target="_blank" rel="noopener">https://github.com/ruanyf/es6tutorial/blob/8240374c621ba0180b381c74c78198bf7107c433/docs/intro.md#es6-%E4%B8%8E-ecmascript-2015-%E7%9A%84%E5%85%B3%E7%B3%BB</a></p><h2 id="TC39"><a href="#TC39" class="headerlink" title="TC39"></a>TC39</h2><p>ECMA 的第 39 号技术专家委员会（Technical Committee 39，简称 TC39）负责制订 ECMAScript 标准，成员包括 Microsoft、Mozilla、Google 等大公司。</p><p>TC39 是一个讨论 JavaScript 标准规范的技术委员会，已决定从 2019 年开始改变其运营结构。TC39 每年召开六次会议，规模已经发展到每次有 40 到 60 人参会的程度。</p><p>这个委员会以前是主席和副主席的运营结构，现在改为由三位联合主席（Aki Braun（PayPal）、Brian Terlson（微软）和 Yulia Startsev（Mozilla））共同负责的架构。他们还在 2019 年 3 月开设了官方网站：</p><ul><li><a href="https://tc39.es/" target="_blank" rel="noopener">https://tc39.es/</a></li><li><a href="https://tc39.github.io" target="_blank" rel="noopener">https://tc39.github.io</a></li><li><a href="https://github.com/tc39" target="_blank" rel="noopener">https://github.com/tc39</a></li></ul><p>每一项新特性最终要进入到 ECMAScript 规范里，需要经历 5 个阶段，这 5 个阶段如下：</p><ul><li>Stage 0: Strawperson：只要是 TC39 成员或者贡献者，都可以提交想法</li><li>Stage 1: Proposal：这个阶段确定一个正式的提案</li><li>Stage 2: draft：规范的第一个版本，进入此阶段的提案大概率会成为标准</li><li>Stage 3: Candidate：进一步完善提案细则</li><li>Stage 4: Finished：表示已准备好将其添加到正式的 ECMAScript 标准</li></ul><h2 id="ECMAScript-6-简介"><a href="#ECMAScript-6-简介" class="headerlink" title="ECMAScript 6 简介"></a>ECMAScript 6 简介</h2><blockquote><p>ES6 相关知识点主要以阮一峰文档为主，此篇笔记只是做一些常用功能提炼、补充说明和自己的理解。另外，有些属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</p></blockquote><p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></p><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，泛指 5.1 版以后的 JavaScript，涵盖了 ES2015、ES2016、ES2017 等等。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><ul><li>2015 年 6 月正式发布 ECMAScript 2015（简称 ES2015）</li><li>2016 年 6 月，在 ES2015 基础上进行小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的 <code>includes</code> 方法和指数运算符），基本上是同一个标准。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://note.youdao.com/yws/res/114198/5C9920E955714BAFA562BC14D2859429" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="常用的-ES6-新特性"><a href="#常用的-ES6-新特性" class="headerlink" title="常用的 ES6 新特性"></a>常用的 ES6 新特性</h2><ul><li>let、const</li><li>解构赋值</li><li>扩展运算符（展开）</li><li>rest 参数（收缩）</li><li>模版字符串</li><li>函数参数的默认值</li><li>箭头函数</li><li>对象属性的简洁表示法</li><li>Promise</li><li>Class</li><li>ES Module</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://note.youdao.com/yws/res/114200/E564D24DB7794322A0A126A22544D8BB" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="ES6-部署"><a href="#ES6-部署" class="headerlink" title="ES6 部署"></a>ES6 部署</h2><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>为了环境的兼容性，你可以使用 babel 来将 ES6 代码转为 ES5 代码。</p><blockquote><p>npm WARN deprecated <a href="mailto:babel-preset-es2015@6.24.1">babel-preset-es2015@6.24.1</a>: � Thanks for using Babel: we recommend using babel-preset-env now: please read babeljs.io/env to update!（已弃用 babel-preset-es2015，现在建议使用 babel-preset-env）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; npm install babel-preset-es2015 --save-dev</span><br><span class="line">npm install babel-preset-env --save-dev</span><br></pre></td></tr></table></figure><p>.babelrc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;env&quot;, &#123;</span><br><span class="line">        &quot;targets&quot;: &#123;</span><br><span class="line">            &quot;browsers&quot;: [&quot;Android &gt;&#x3D; 4.0&quot;, &quot;ios &gt;&#x3D; 6&quot;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;include&quot;: [],</span><br><span class="line">        &quot;useBuiltIns&quot;: true</span><br><span class="line">    &#125;]</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [&quot;lodash&quot;],</span><br><span class="line">    [&quot;transform-object-rest-spread&quot;],</span><br><span class="line">    [&quot;component&quot;, &#123; &quot;libraryName&quot;: &quot;mint-ui&quot;, &quot;style&quot;: true &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="let-和-const-命令"><a href="#let-和-const-命令" class="headerlink" title="let 和 const 命令"></a>let 和 const 命令</h2><p>ES6 提出了两个新的声明变量的命令：<code>let</code>和<code>const</code>，主要是为了规避使用<code>var</code>定义变量时的副作用（变量提升问题、作用域问题等），减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的设计是为了让大家养成良好的编程习惯 —— 变量一定要在声明之后使用，否则就报错。</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>JavaScript 一直是函数作用域，这就是为什么将整个 JavaScript 文件包装在一个空的立即调用函数表达式（IIFE）中变得很普遍的原因。这样做是为了隔离文件中的所有变量，因此没有可变冲突。</p><p>现在，我们有块作用域和两个绑定到块的新变量声明。</p><p>ES6 带来了块级作用域，通过<code>let</code>和<code>const</code>定义的变量属于块级作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    var a &#x3D; 1;</span><br><span class="line">    let b &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); &#x2F;&#x2F; 1</span><br><span class="line">console.log(b); &#x2F;&#x2F; Uncaught ReferenceError: b is not defined</span><br></pre></td></tr></table></figure><p>注意：<code>let</code>和<code>const</code>不允许重复声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let v &#x3D; 1;</span><br><span class="line">let v &#x3D; 2; &#x2F;&#x2F; Uncaught SyntaxError: Identifier &#39;v&#39; has already been declared</span><br></pre></td></tr></table></figure><p>注意：由<code>let</code>和<code>const</code>命令声明的变量不是顶层对象（window、global）的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 1;</span><br><span class="line">window.a &#x3D;&#x3D;&#x3D; undefined; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>let 完全可以取代 var，因为两者语义相同，而且 let 没有副作用（不存在变量提升问题，并且属于块级作用域）。==建议不再使用 var 命令，而是使用 let 命令取代。==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">if (true) &#123;</span><br><span class="line">  let x &#x3D; &#39;hello&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码如果用 var 替代 let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var 命令做不到这一点。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const 用来声明只读的常量。一旦声明，常量的值就不能改变，否则报错。</p><p>注意: const 定义的数组和对象可以被修改（不变的是指向的内存地址）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const k &#x3D; &#123; a: 1 &#125;;</span><br><span class="line">k.a &#x3D; 2;</span><br><span class="line">k.b &#x3D; 3;</span><br><span class="line">console.log(k); &#x2F;&#x2F; Object &#123;a: 2, b: 3&#125;</span><br></pre></td></tr></table></figure><p>最佳实践：</p><ul><li>在 let 和 const 之间，建议优先使用 const，尤其是在全局环境，不应该设置变量，只应设置常量。</li><li>所有的函数都应该设置为常量。</li></ul><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 1;</span><br><span class="line">&#123;</span><br><span class="line">    console.log(a); &#x2F;&#x2F; Uncaught ReferenceError: a is not defined</span><br><span class="line">    let a &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h3><p>ES5 只有两种声明变量的方法：var 命令和 function 命令。</p><p>ES6 添加了 let 和 const 命令、import 命令和 class 命令。所以，ES6 一共有 6 种声明变量的方法。</p><ol><li>var</li><li>function</li><li>let</li><li>const</li><li>import</li><li>class</li></ol><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>变量的解构赋值简化了数组和对象中信息的提取。ES6 前，我们一个一个获取对象信息；ES6 后，解构能让我们从对象或者数组里取出数据存为变量</p><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var data &#x3D; &#123; name: &#39;dys&#39;, age: 1 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES5</span><br><span class="line">var name &#x3D; data.name;</span><br><span class="line">var age &#x3D; data.age;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6</span><br><span class="line">const &#123; name, age &#125; &#x3D; data;</span><br></pre></td></tr></table></figure><p>其实，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><p>对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let &#123; foo, bar &#125; &#x3D; &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">let &#123; foo: foo, bar: bar &#125; &#x3D; &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5</span><br><span class="line">var people1 &#x3D; &#123;</span><br><span class="line">  name: &#39;bai&#39;,</span><br><span class="line">  age: 20,</span><br><span class="line">  color: [&#39;red&#39;, &#39;blue&#39;]</span><br><span class="line">&#125;;</span><br><span class="line">var myName &#x3D; people1.name;</span><br><span class="line">var myAge &#x3D; people1.age;</span><br><span class="line">var myColor &#x3D; people1.color[0];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6</span><br><span class="line">let people2 &#x3D; &#123;</span><br><span class="line">  name: &#39;ming&#39;,</span><br><span class="line">  age: 20,</span><br><span class="line">  color: [&#39;red&#39;, &#39;blue&#39;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let &#123; name, age &#125; &#x3D; people2;</span><br><span class="line">let [first, second] &#x3D; people2.color;</span><br></pre></td></tr></table></figure><h3 id="解构赋值允许指定默认值"><a href="#解构赋值允许指定默认值" class="headerlink" title="解构赋值允许指定默认值"></a>解构赋值允许指定默认值</h3><p>==解构赋值允许指定默认值==。注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于 undefined，默认值才会生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [x &#x3D; 1] &#x3D; [undefined]; x &#x2F;&#x2F; 1</span><br><span class="line">let [x &#x3D; 1] &#x3D; [null]; x &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure><p>==如果解构不成功，变量的值就等于 undefined==。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let [x, y &#x3D; &#39;b&#39;] &#x3D; [&#39;a&#39;, undefined]; &#x2F;&#x2F; x&#x3D;&#39;a&#39;, y&#x3D;&#39;b&#39;</span><br><span class="line">let [head, ...tail] &#x3D; [1, 2, 3, 4]; &#x2F;&#x2F; head&#x3D;1, tail&#x3D;[2, 3, 4]</span><br><span class="line"></span><br><span class="line">let &#123; foo, bar &#125; &#x3D; &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;; &#x2F;&#x2F; foo&#x3D;&quot;aaa&quot;, bar&#x3D;&quot;bbb&quot;</span><br><span class="line">let &#123; log, sin, cos &#125; &#x3D; Math;</span><br><span class="line"></span><br><span class="line">let [a, b, c, d, e] &#x3D; &#39;hello&#39;;</span><br></pre></td></tr></table></figure><h3 id="解构赋值用途"><a href="#解构赋值用途" class="headerlink" title="解构赋值用途"></a>解构赋值用途</h3><ul><li>交换变量的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 1;</span><br><span class="line">let b &#x3D; 2;</span><br><span class="line">[b, a] &#x3D; [a, b];</span><br><span class="line">console.log(a, b); &#x2F;&#x2F; 2 1</span><br></pre></td></tr></table></figure><ul><li>从函数返回多个值，以前需要通过数组索引取值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    return [1, 2, 3, 4, 5, 6];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a, b, rest;</span><br><span class="line">[a, , , b, ...rest] &#x3D; foo();</span><br><span class="line">console.log(a, b, rest); &#x2F;&#x2F; 1 4 [5, 6]</span><br></pre></td></tr></table></figure><ul><li>提取 JSON 数据</li><li>函数参数的定义</li><li>函数参数的默认值</li><li>输入模块的指定方法</li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>使用数组成员对变量赋值时，优先使用解构赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">const first &#x3D; arr[0];</span><br><span class="line">const second &#x3D; arr[1];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">const [first, second] &#x3D; arr;</span><br></pre></td></tr></table></figure><p>函数的参数如果是对象的成员，优先使用解构赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">function getFullName(user) &#123;</span><br><span class="line">  const firstName &#x3D; user.firstName;</span><br><span class="line">  const lastName &#x3D; user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">function getFullName(obj) &#123;</span><br><span class="line">  const &#123; firstName, lastName &#125; &#x3D; obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; best</span><br><span class="line">function getFullName(&#123; firstName, lastName &#125;) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">function processInput(input) &#123;</span><br><span class="line">  return [left, right, top, bottom];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good</span><br><span class="line">function processInput(input) &#123;</span><br><span class="line">  return &#123; left, right, top, bottom &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123; left, right &#125; &#x3D; processInput(input);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ECMAScript-简介&quot;&gt;&lt;a href=&quot;#ECMAScript-简介&quot; class=&quot;headerlink&quot; title=&quot;ECMAScript 简介&quot;&gt;&lt;/a&gt;ECMAScript 简介&lt;/h2&gt;&lt;p&gt;ECMAScript 是一种由 ECMA 国际的组织
      
    
    </summary>
    
    
      <category term="JS" scheme="https://bxm0927.github.io/categories/JS/"/>
    
    
      <category term="HTML" scheme="https://bxm0927.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://bxm0927.github.io/tags/CSS/"/>
    
      <category term="JS" scheme="https://bxm0927.github.io/tags/JS/"/>
    
      <category term="ES6" scheme="https://bxm0927.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>聊聊布局</title>
    <link href="https://bxm0927.github.io/2019/02/25/layout/"/>
    <id>https://bxm0927.github.io/2019/02/25/layout/</id>
    <published>2019-02-25T14:57:15.000Z</published>
    <updated>2020-09-09T12:45:15.560Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/bxm0927/picture-link/master/markdown-note/2019-2-24005.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="布局方法"><a href="#布局方法" class="headerlink" title="布局方法"></a>布局方法</h2><p>过时的布局方法</p><ul><li>表格布局（table）</li></ul><p>传统的布局方法</p><ul><li>定位（position）</li><li>浮动（float）</li></ul><p>前沿的布局方法</p><ul><li>弹性盒子布局（Flexible Box Layout）</li><li>网格布局（Grid Layout）</li></ul><h2 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h2><p>布局可以从以下几个方面思考：</p><ol><li>利用 <code>float</code> + <code>margin</code> 实现</li><li>利用 <code>absolute</code> 绝对定位实现</li><li>利用 BFC 实现</li><li>利用 Flexbox 实现</li><li>利用 Grid 实现</li></ol><p>几个注意点：</p><ul><li>移动端能用 <code>Flex</code> 就用 <code>Flex</code>，灵活方便并且功能强大，无愧为网页布局的一大利器！</li><li>使用 <code>float</code> 时，注意要清除浮动，避免高度塌陷</li><li>避免使用老旧的 <code>table</code> 布局（如 <code>display: table;</code>、<code>display: table-row;</code>、<code>display: table-cell;</code>）。表格布局会使 <code>margin</code> 失效，设置间隔比较麻烦。</li></ul><a id="more"></a><h2 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><p>行内元素水平居中：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 text-align: center 可以将块级元素内部的行内元素水平居中。</span></span><br><span class="line"><span class="comment">// 此方法对 inline、inline-block、inline-table 和 inline-flex 元素水平居中都有效。</span></span><br><span class="line"><span class="comment">// 也可以将 block 元素设置成 inline-block，再用这种方式实现块级元素的水平居中</span></span><br><span class="line"><span class="selector-class">.inline-x-center</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单个块级元素水平居中：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可通过将左和右外边距设置为 auto 来实现块级元素水平居中。</span></span><br><span class="line"><span class="comment">// 此时需要设置宽度，如果宽度是 100%，则对齐没有效果。</span></span><br><span class="line"><span class="keyword">@mixin</span> margin-auto-center(<span class="variable">$width</span>: <span class="number">80%</span>) &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: auto;</span><br><span class="line">    <span class="attribute">margin-right</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个块级元素水平居中：</p><blockquote><p>注意多个 <code>inline-block</code> 元素间空白字符 <code>font-size</code> 不为 0 的问题</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="comment">/* font-size: 0; */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><p>行内元素垂直居中：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.inline-y-center</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>垂直对齐一幅图像、字体图标：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vertical-align 属性设置元素的垂直对齐方式，默认情况下，元素放置在父元素的基线(baseline)上。</span></span><br><span class="line"><span class="selector-class">.img-y-center</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><blockquote><p>总结：一般情况下，水平垂直居中，我们最常用的就是绝对定位加负边距，缺点就是需要知道宽高，使用 <code>transform</code> 倒是可以不需要知道宽高，但是兼容性不好（IE9+）</p></blockquote><p>高度宽度已知：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Negative margin</span></span><br><span class="line"><span class="keyword">@mixin</span> margin-center(<span class="variable">$width</span>, <span class="variable">$height</span>) &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$height</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -(<span class="variable">$width</span> / <span class="number">2</span>);</span><br><span class="line">    <span class="attribute">margin-top</span>: -(<span class="variable">$height</span> / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高度宽度未知：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transform centering</span></span><br><span class="line"><span class="comment">// Horizontally and vertically centers a child element within a parent element using `position: absolute` and `transform: translate()`.</span></span><br><span class="line"><span class="comment">// Similar to `flexbox`, this method does not require you to know the height or width of your parent or child so it is ideal for responsive applications.</span></span><br><span class="line"><span class="selector-class">.transform-center</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: translate(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flexbox centering</span></span><br><span class="line"><span class="comment">// Horizontally and vertically centers a child element within a parent element using `flexbox`.</span></span><br><span class="line"><span class="selector-class">.flexbox-center</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;           <span class="comment">// enables flexbox.</span></span><br><span class="line">    <span class="attribute">align-items</span>: center;     <span class="comment">// centers the child vertically.</span></span><br><span class="line">    <span class="attribute">justify-content</span>: center; <span class="comment">// centers the child horizontally.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Grid centering</span></span><br><span class="line"><span class="comment">// Horizontally and vertically centers a child element within a parent element using `grid`.</span></span><br><span class="line"><span class="selector-class">.grid-center</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;           <span class="comment">// enables grid.</span></span><br><span class="line">    <span class="attribute">align-items</span>: center;     <span class="comment">// centers the child vertically.</span></span><br><span class="line">    <span class="attribute">justify-content</span>: center; <span class="comment">// centers the child horizontally.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两列布局"><a href="#两列布局" class="headerlink" title="两列布局"></a>两列布局</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/bxm0927/picture-link/master/markdown-note/2019-2-24001.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h3 id="左列定宽，右列自适应"><a href="#左列定宽，右列自适应" class="headerlink" title="左列定宽，右列自适应"></a>左列定宽，右列自适应</h3><ol><li>利用 <code>float</code> + <code>margin</code> 实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line"><span class="attribute">margin-left</span>: <span class="number">120px</span>; <span class="comment">/* 大于等于 `.left` 的宽度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用 BFC 实现：</li></ol><blockquote><p>BFC（Block fomatting context）：块级元素格式化上下文，它决定了其子元素将如何定位，以及和其他元素的相互关系。</p></blockquote><blockquote><p>BFC 在页面上是一个独立的容器，与其他元素互不影响</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line"><span class="attribute">overflow</span>: hidden; <span class="comment">/* 触发 BFC 达到自适应 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>利用 <code>absolute</code> 绝对定位实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">100px</span>; <span class="comment">/* 大于等于 `.left` 的宽度 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>利用 Flexbox 实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 均分了父元素剩余空间 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>利用 Grid 实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> auto; <span class="comment">/* 设定 2 列就 ok 了, auto 换成 1fr 也行 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左列自适应，右列定宽"><a href="#左列自适应，右列定宽" class="headerlink" title="左列自适应，右列定宽"></a>左列自适应，右列定宽</h3><ol><li>利用 <code>float</code> + <code>margin</code> 实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">100px</span>; <span class="comment">/* 抵消 left 的 margin-left 以达到 parent 水平居中 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100px</span>; <span class="comment">/* 正值等于 right 的宽度 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用 BFC 实现：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-class">.left</span> &#123;</span><br><span class="line">        <span class="attribute">overflow</span>: hidden; <span class="comment">/* 触发 BFC 达到自适应 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.right</span> &#123;</span><br><span class="line">        <span class="attribute">float</span>: right;</span><br><span class="line">        <span class="attribute">margin-left</span>: <span class="number">10px</span>; <span class="comment">/* margin 需要定义在 right 上 */</span></span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!<span class="selector-tag">--</span> <span class="selector-tag">right</span> 先渲染 <span class="selector-tag">--</span>&gt;</span><br><span class="line">&lt;div id="right"&gt;右列定宽&lt;/div&gt;</span><br><span class="line">&lt;div id="left"&gt;左列自适应&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>利用 <code>absolute</code> 绝对定位实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">100px</span>; <span class="comment">/* 大于等于 `.right` 的宽度 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>利用 Flexbox 实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 均分了父元素剩余空间 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>利用 Grid 实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: auto <span class="number">100px</span>; <span class="comment">/* 设定 2 列就 ok 了, auto 换成 1fr 也行 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一列不定，一列自适应"><a href="#一列不定，一列自适应" class="headerlink" title="一列不定，一列自适应"></a>一列不定，一列自适应</h3><blockquote><p>盒子宽度随着内容增加或减少发生变化，另一个盒子自适应</p></blockquote><blockquote><p>这里演示左列不定宽，右列自适应。左列自适应，右列不定宽同理。</p></blockquote><ol><li>利用 BFC 实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left; <span class="comment">/* 只设置浮动，不设宽度 */</span></span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden; <span class="comment">/* 触发 BFC */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用 Flexbox 实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="comment">/* 不设宽度 */</span></span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 均分 parent 剩余的部分 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>利用 Grid 实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: auto <span class="number">1</span>fr; <span class="comment">/* auto 和 1fr 换一下顺序就是“左列自适应，右列不定宽”了 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三列布局"><a href="#三列布局" class="headerlink" title="三列布局"></a>三列布局</h2><h3 id="两列定宽，一列自适应"><a href="#两列定宽，一列自适应" class="headerlink" title="两列定宽，一列自适应"></a>两列定宽，一列自适应</h3><ol><li>利用 <code>float</code> + <code>margin</code> 实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">310px</span>; <span class="comment">/* 100 + 10 + 200，防止宽度不够，子元素换行*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>; <span class="comment">/* left 和 center 间隔 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">320px</span>; <span class="comment">/* 等于 left 和 center 的宽度之和加上间隔，多出来的就是 right 和 center 的间隔 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用 BFC 实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">320px</span>; <span class="comment">/* 防止宽度不够，子元素换行 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>; <span class="comment">/* 在此定义和 right 的间隔 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>利用 Flexbox 实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>利用 Grid 实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">200px</span> auto; <span class="comment">/* 设置3列，固定第一第二列的宽度，第三列 auto 或者 1fr */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左右定宽，中间自适应"><a href="#左右定宽，中间自适应" class="headerlink" title="左右定宽，中间自适应"></a>左右定宽，中间自适应</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2017/8/20/00913c0a5f49e94f13dd4a0bf5eea826?imageView2/0/w/1280/h/960" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h4 id="利用-Flexbox-实现"><a href="#利用-Flexbox-实现" class="headerlink" title="利用 Flexbox 实现"></a>利用 Flexbox 实现</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用-absolute-绝对定位实现"><a href="#利用-absolute-绝对定位实现" class="headerlink" title="利用 absolute 绝对定位实现"></a>利用 absolute 绝对定位实现</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">100px</span>; <span class="comment">/* 大于等于 left 的宽度，或者给 parent 添加同样大小的 padding-left */</span></span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">200px</span>; <span class="comment">/* 大于等于 right 的宽度，或者给 parent 添加同样大小的 padding-right */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><p>圣杯布局又叫做固比固布局，即两边固定宽度，中间自适应的三栏布局。</p><p>具体操作是三栏全部浮动，左右两栏负 margin 让其跟中间栏并排。</p><p>注意：中间栏要在放在文档流前面以优先渲染。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"grail"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 中间盒子优先渲染 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Qui, ut.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.grail</span> &#123;</span></span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">        width: 100%;</span><br><span class="line">        min-width: 1024px;</span><br><span class="line">        height: 400px;</span><br><span class="line"><span class="css">        <span class="comment">/* 让中间自适应的盒子安全显示 */</span></span></span><br><span class="line">        padding: 0 300px;</span><br><span class="line">        background-color: darkseagreen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: deepskyblue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        position: relative;</span><br><span class="line">        left: -300px;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line"><span class="css">        <span class="comment">/* 左侧盒子上浮; */</span></span></span><br><span class="line">        margin-left: -100%;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        position: relative;</span><br><span class="line">        right: -300px;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line"><span class="css">        <span class="comment">/* 右侧盒子上浮 */</span></span></span><br><span class="line">        margin-left: -300px;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><p>事实上，圣杯布局和双飞翼布局是一回事，它们实现的都是三栏布局，但是双飞翼布局可以更好地解决中栏内容超出的情景。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"grail"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle-wrapper"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Qui, ut.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.grail</span> &#123;</span></span><br><span class="line">        width: 100%;</span><br><span class="line">        min-width: 1024px;</span><br><span class="line">        height: 400px;</span><br><span class="line">        background-color: darkseagreen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.middle-wrapper</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: deepskyblue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line">        height: 300px;</span><br><span class="line">        margin-left: 300px;</span><br><span class="line">        margin-right: 300px;</span><br><span class="line">        background-color: yellowgreen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        margin-left: -100%;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        margin-left: -300px;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h2><h3 id="等宽布局"><a href="#等宽布局" class="headerlink" title="等宽布局"></a>等宽布局</h3><ol><li>浮动等宽布局：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.column</span> &#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">25%</span>; <span class="comment">/* 100 ÷ 列数，得出百分比 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>弹性盒子等宽布局：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.column</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>网格等宽布局：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">6</span>, <span class="number">1</span>fr);  <span class="comment">/* 6 就是列数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="九宫格布局"><a href="#九宫格布局" class="headerlink" title="九宫格布局"></a>九宫格布局</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/bxm0927/picture-link/master/markdown-note/2019-2-24003.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>DOM结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>使用 table 表格布局实现：</li></ol><blockquote><p>display:table       相当于 table 标签</p></blockquote><blockquote><p>display:table-row   相当于 tr 标签</p></blockquote><blockquote><p>display:table-cell  相当于 td 标签</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.row</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-row;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 Flex 弹性盒子布局实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.row</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 Grid 网格布局实现：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">1</span>fr); <span class="comment">/* 等同于 1fr 1fr 1fr，此为重复的合并写法 */</span></span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">1</span>fr);  <span class="comment">/* 等同于 1fr 1fr 1fr，此为重复的合并写法 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.column-xs-1</span> &#123;  <span class="attribute">width</span>: <span class="number">8.33333333%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-xs-2</span> &#123;  <span class="attribute">width</span>: <span class="number">16.66666667%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-xs-3</span> &#123;  <span class="attribute">width</span>: <span class="number">25%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-xs-4</span> &#123;  <span class="attribute">width</span>: <span class="number">33.33333333%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-xs-5</span> &#123;  <span class="attribute">width</span>: <span class="number">41.66666667%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-xs-6</span> &#123;  <span class="attribute">width</span>: <span class="number">50%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-xs-7</span> &#123;  <span class="attribute">width</span>: <span class="number">58.33333333%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-xs-8</span> &#123;  <span class="attribute">width</span>: <span class="number">66.66666667%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-xs-9</span> &#123;  <span class="attribute">width</span>: <span class="number">75%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-xs-10</span> &#123;  <span class="attribute">width</span>: <span class="number">83.33333333%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-xs-11</span> &#123;  <span class="attribute">width</span>: <span class="number">91.66666667%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-xs-12</span> &#123;  <span class="attribute">width</span>: <span class="number">100%</span>;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.column-sm-1</span> &#123;  <span class="attribute">width</span>: <span class="number">8.33333333%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-sm-2</span> &#123;  <span class="attribute">width</span>: <span class="number">16.66666667%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-sm-3</span> &#123;  <span class="attribute">width</span>: <span class="number">25%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-sm-4</span> &#123;  <span class="attribute">width</span>: <span class="number">33.33333333%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-sm-5</span> &#123;  <span class="attribute">width</span>: <span class="number">41.66666667%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-sm-6</span> &#123;  <span class="attribute">width</span>: <span class="number">50%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-sm-7</span> &#123;  <span class="attribute">width</span>: <span class="number">58.33333333%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-sm-8</span> &#123;  <span class="attribute">width</span>: <span class="number">66.66666667%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-sm-9</span> &#123;  <span class="attribute">width</span>: <span class="number">75%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-sm-10</span> &#123;  <span class="attribute">width</span>: <span class="number">83.33333333%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-sm-11</span> &#123;  <span class="attribute">width</span>: <span class="number">91.66666667%</span>;  &#125;</span><br><span class="line">  <span class="selector-class">.column-sm-12</span> &#123;  <span class="attribute">width</span>: <span class="number">100%</span>;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class^=<span class="string">"column-xs-"</span>]</span>&#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class^=<span class="string">"column-sm-"</span>]</span>&#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滚动场景"><a href="#滚动场景" class="headerlink" title="滚动场景"></a>滚动场景</h2><p>横向滚动：<code>overflow-x: auto;</code></p><p>纵向滚动：<code>overflow-y: auto;</code></p><p>横向、纵向滚动：<code>overflow: auto;</code></p><blockquote><p>更复杂的滚动场景可以借助第三方库实现，如 better-scroll</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://raw.githubusercontent.com/bxm0927/picture-link/master/markdown-note/2019-2-24005.png&quot; alt=&quot;image&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;image&lt;/div&gt;
            &lt;/figure&gt;

&lt;h2 id=&quot;布局方法&quot;&gt;&lt;a href=&quot;#布局方法&quot; class=&quot;headerlink&quot; title=&quot;布局方法&quot;&gt;&lt;/a&gt;布局方法&lt;/h2&gt;&lt;p&gt;过时的布局方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表格布局（table）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传统的布局方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定位（position）&lt;/li&gt;
&lt;li&gt;浮动（float）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前沿的布局方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;弹性盒子布局（Flexible Box Layout）&lt;/li&gt;
&lt;li&gt;网格布局（Grid Layout）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;经验之谈&quot;&gt;&lt;a href=&quot;#经验之谈&quot; class=&quot;headerlink&quot; title=&quot;经验之谈&quot;&gt;&lt;/a&gt;经验之谈&lt;/h2&gt;&lt;p&gt;布局可以从以下几个方面思考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用 &lt;code&gt;float&lt;/code&gt; + &lt;code&gt;margin&lt;/code&gt; 实现&lt;/li&gt;
&lt;li&gt;利用 &lt;code&gt;absolute&lt;/code&gt; 绝对定位实现&lt;/li&gt;
&lt;li&gt;利用 BFC 实现&lt;/li&gt;
&lt;li&gt;利用 Flexbox 实现&lt;/li&gt;
&lt;li&gt;利用 Grid 实现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;几个注意点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移动端能用 &lt;code&gt;Flex&lt;/code&gt; 就用 &lt;code&gt;Flex&lt;/code&gt;，灵活方便并且功能强大，无愧为网页布局的一大利器！&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;float&lt;/code&gt; 时，注意要清除浮动，避免高度塌陷&lt;/li&gt;
&lt;li&gt;避免使用老旧的 &lt;code&gt;table&lt;/code&gt; 布局（如 &lt;code&gt;display: table;&lt;/code&gt;、&lt;code&gt;display: table-row;&lt;/code&gt;、&lt;code&gt;display: table-cell;&lt;/code&gt;）。表格布局会使 &lt;code&gt;margin&lt;/code&gt; 失效，设置间隔比较麻烦。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://bxm0927.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="https://bxm0927.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://bxm0927.github.io/tags/CSS/"/>
    
      <category term="JavaScript" scheme="https://bxm0927.github.io/tags/JavaScript/"/>
    
      <category term="Layout" scheme="https://bxm0927.github.io/tags/Layout/"/>
    
  </entry>
  
  <entry>
    <title>Java 文件 I/O 流详细解读</title>
    <link href="https://bxm0927.github.io/2018/07/11/Java-io/"/>
    <id>https://bxm0927.github.io/2018/07/11/Java-io/</id>
    <published>2018-07-11T13:31:05.000Z</published>
    <updated>2020-09-09T12:45:15.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-O-概述"><a href="#I-O-概述" class="headerlink" title="I/O 概述"></a>I/O 概述</h2><p>利用 Java 的 I/O（input/output，输入和输出）技术可以将数据保存到文本文件、二进制文件甚至是压缩包之中，以达到永久性保存数据的要求。I/O 通常使用“流”的方式进行数据传输，一个流必须有源和目的地，他们通常是磁盘文件，但也可以是键盘、鼠标、显示器、内存甚至是网络等设备。</p><a id="more"></a><p>Java 语言定义了许多类专门负责各种形式的输入和输出，这些类被放在<code>java.io</code>包中，他们根据数据形态可分为：流式部分和非流式部分。</p><p>Java I/O 机制提供了一套简单的标准化 API，以方便从不同的数据源读取和写入字符数据或字节数据。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/18-7-11/63818593.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="非流式部分"><a href="#非流式部分" class="headerlink" title="非流式部分"></a>非流式部分</h2><h3 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h3><p>文件自身操作类，是 <code>java.io</code> 包中唯一一个与文件本身有关的操作类。File 类用于处理文件和文件系统，如创建、删除、重命名文件等操作，以路径名的形式代表一个文件。</p><blockquote></blockquote><p>File 类的构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File(String filePath)                   &#x2F;&#x2F; 创建指定文件路径的 File 对象</span><br><span class="line">File(String filePath, String fileName)  &#x2F;&#x2F; 创建指定文件路径和指定文件名的 File 对象</span><br><span class="line">File(File dirObj, String fileName)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File f1 &#x3D; new File(&quot;&#x2F;&quot;);</span><br><span class="line">File f2 &#x3D; new File(&quot;&#x2F;&quot;, &quot;a.txt&quot;);</span><br><span class="line">File f3 &#x3D; new File(f1, &quot;a.txt&quot;);</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>File 类不支持文件内容的读写操作。</li><li>路径（filePath）分为相对路径和绝对路径，相对路径是相对于项目根目录而言的。</li></ul><h4 id="File-类常用方法"><a href="#File-类常用方法" class="headerlink" title="File 类常用方法"></a>File 类常用方法</h4><blockquote><p>文件路径分隔符：<code>/</code>、<code>\\</code>或<code>File.separator</code></p></blockquote><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>length()</td><td>文件的长度（字节 Byte）</td></tr><tr><td>getName()</td><td>返回文件名</td></tr><tr><td>getParent()</td><td>返回父目录名</td></tr><tr><td>exists()</td><td>判断文件（或目录）是否存在</td></tr><tr><td>canRead()</td><td>判断文件是否可读</td></tr><tr><td>canWrite()</td><td>判断文件是否可写</td></tr><tr><td>isFile()</td><td>是否是一个文件</td></tr><tr><td>delete()</td><td>删除文件</td></tr><tr><td>getPath()</td><td>返回相对路径</td></tr><tr><td>getAbsolutePath()</td><td>返回绝对路径</td></tr><tr><td>getCanonicalPath()</td><td>返回路径名的规范格式？？</td></tr><tr><td>isDirectory()</td><td>是否是目录</td></tr><tr><td>isAbsolute()</td><td>是否是绝对路径名</td></tr><tr><td>isHidden()</td><td>是否是隐藏文件</td></tr><tr><td>lastModified()</td><td>最后修改时间</td></tr><tr><td>list()、list(filter)</td><td>返回当前目录下的文件和目录的列表（String[]）</td></tr><tr><td>listFiles()</td><td>返回直接子目录(文件)的抽象</td></tr><tr><td>createNewFile()</td><td>创建文件</td></tr><tr><td>mkdir()</td><td>创建单级目录</td></tr><tr><td>mkdirs()</td><td>创建多级目录</td></tr><tr><td>renameTo()</td><td>重命名</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">File f1 &#x3D; new File(&quot;e:&quot; + File.separator + &quot;test.txt&quot;);</span><br><span class="line"></span><br><span class="line">if (f1.exists()) &#123;</span><br><span class="line">    f1.delete();</span><br><span class="line">    System.out.println(&quot;文件删除成功&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        f1.createNewFile();</span><br><span class="line">        System.out.println(&quot;文件创建成功&quot;);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(f1.getName()); &#x2F;&#x2F; test.txt</span><br><span class="line">System.out.println(f1.getPath()); &#x2F;&#x2F; e:\test.txt</span><br><span class="line">System.out.println(f1.getAbsolutePath()); &#x2F;&#x2F; e:\test.txt</span><br><span class="line">System.out.println(f1.getParent()); &#x2F;&#x2F; e:\</span><br><span class="line">System.out.println(f1.canRead()); &#x2F;&#x2F; true</span><br><span class="line">System.out.println(f1.canWrite()); &#x2F;&#x2F; true</span><br><span class="line">System.out.println(f1.isDirectory()); &#x2F;&#x2F; false</span><br><span class="line">System.out.println(f1.isFile()); &#x2F;&#x2F; true</span><br><span class="line">System.out.println(f1.isAbsolute()); &#x2F;&#x2F; true</span><br><span class="line">System.out.println(f1.lastModified()); &#x2F;&#x2F; 1519556856932</span><br><span class="line">System.out.println(f1.length() + &quot;Byte&quot;); &#x2F;&#x2F; 0Byte</span><br></pre></td></tr></table></figure><h3 id="RandomAccessFile-类"><a href="#RandomAccessFile-类" class="headerlink" title="RandomAccessFile 类"></a>RandomAccessFile 类</h3><p>文件随机访问类，即可以跳转到文件的任意位置处进行读写操作。RandomAccessFile 对象有一个位置指示器，指向当前读写处的位置。该类仅限于操作文件，不能访问其他 IO 设备，如网络、内存映象等等。</p><p>RandomAccessFile 类的构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile(File file, String mode)     &#x2F;&#x2F; 创建一个随机访问文件流，文件属性由 File 参数指定</span><br><span class="line">RandomAccessFile(String name, String mode)   &#x2F;&#x2F; 创建一个随机访问文件流，文件名由 name 参数指定</span><br></pre></td></tr></table></figure><p>mode 决定了随机访问文件流的操作模式：</p><table><thead><tr><th>value</th><th>meaning</th></tr></thead><tbody><tr><td>r</td><td>read，以只读方式打开，调用该对象的任何写方法都会导致 IOException 异常</td></tr><tr><td>rw</td><td>read-write，以读、写方式打开，若文件不存在，则创建之</td></tr><tr><td>rws</td><td>read-write-synchronized，以读、写方式打开，且文件内容同步更新</td></tr><tr><td>rwd</td><td>类似 rws</td></tr></tbody></table><h4 id="RandomAccessFile-类常用方法"><a href="#RandomAccessFile-类常用方法" class="headerlink" title="RandomAccessFile 类常用方法"></a>RandomAccessFile 类常用方法</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>close()</td><td>关闭此随机访问文件流</td></tr><tr><td>length()</td><td>返回此文件的长度</td></tr><tr><td>read()</td><td>从这个文件读取一个字节的数据</td></tr><tr><td>write(byte[] b)</td><td>写 b.length 字节到文件中</td></tr><tr><td>getFilePointer()</td><td>返回此文件中的当前偏移量（位置指示器）</td></tr><tr><td>seek(long pos)</td><td>设置文件指针偏移量（位置指示器）</td></tr><tr><td>skipBytes(int n)</td><td>跳过指定字节</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向文件中写入三个员工的信息，并读出</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Employee person1 &#x3D; new Employee(&quot;zhangsan&quot;, 18);</span><br><span class="line">        Employee person2 &#x3D; new Employee(&quot;lisi&quot;, 20);</span><br><span class="line"></span><br><span class="line">        File file &#x3D; new File(&quot;C:&#x2F;Users&#x2F;bxm09&#x2F;Desktop&#x2F;test.txt&quot;);</span><br><span class="line">        if (file.exists()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RandomAccessFile f1 &#x3D; new RandomAccessFile(&quot;C:&#x2F;Users&#x2F;bxm09&#x2F;Desktop&#x2F;test.txt&quot;, &quot;rw&quot;);</span><br><span class="line">        f1.write(person1.name.getBytes());</span><br><span class="line">        f1.writeInt(person1.age);</span><br><span class="line">        f1.write(person2.name.getBytes());</span><br><span class="line">        f1.writeInt(person2.age);</span><br><span class="line">        f1.close();</span><br><span class="line"></span><br><span class="line">        RandomAccessFile f2 &#x3D; new RandomAccessFile(&quot;C:&#x2F;Users&#x2F;bxm09&#x2F;Desktop&#x2F;test.txt&quot;, &quot;r&quot;);</span><br><span class="line">        System.out.println(&quot;第 2 个员工的信息：&quot;);</span><br><span class="line">        f2.skipBytes(12); &#x2F;&#x2F; 跳过指定字节</span><br><span class="line">        String p1Name &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 8; i++) &#123;</span><br><span class="line">            p1Name +&#x3D; (char) f2.readByte();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;name：&quot; + p1Name);</span><br><span class="line">        System.out.println(&quot;age：&quot; + f2.readInt());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;第 1 个员工的信息：&quot;);</span><br><span class="line">        f2.seek(0); &#x2F;&#x2F; 设置文件指针偏移量</span><br><span class="line">        String p2Name &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 8; i++) &#123;</span><br><span class="line">            p2Name +&#x3D; (char) f2.readByte();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;name：&quot; + p2Name);</span><br><span class="line">        System.out.println(&quot;age：&quot; + f2.readInt());</span><br><span class="line">        f2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 员工类</span><br><span class="line">class Employee &#123;</span><br><span class="line">    String name; &#x2F;&#x2F; 员工姓名</span><br><span class="line">    int age; &#x2F;&#x2F; 员工年龄</span><br><span class="line">    final static int LENGTH &#x3D; 8; &#x2F;&#x2F; 规定 name 为 8 个字符，方便读取。8 个字符 &#x3D; 8个汉字 &#x3D; 8个数字 &#x3D; 8个字母</span><br><span class="line"></span><br><span class="line">    public Employee(String name, int age) &#123;</span><br><span class="line">        if (name.length() &gt; LENGTH) &#123;</span><br><span class="line">            name &#x3D; name.substring(0, LENGTH); &#x2F;&#x2F; 超八位则截取</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (name.length() &lt; LENGTH) &#123;</span><br><span class="line">                name +&#x3D; &quot;\u0000&quot;; &#x2F;&#x2F; 不足八位用空格代替</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="流式部分"><a href="#流式部分" class="headerlink" title="流式部分"></a>流式部分</h2><p>在 Java 中，所有的 I/O 机制都是基于数据“流”方式完成的，而操作流的对象都封装到了 <code>java.io</code> 包中。</p><p>I/O 流的分类：</p><ul><li>按操作数据的内容形态划分：字节流（InputStream、OutputStream）和字符流（Reader、Writer）</li><li>按流的功能流向划分：输入流（InputStream、Reader）和输出流（OutputStream、Writer）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class InputStream implements Closeable &#123; ... &#125;</span><br><span class="line">public abstract class OutputStream implements Closeable, Flushable &#123; ... &#125;</span><br><span class="line">public abstract class Reader implements Readable, Closeable &#123; ... &#125;</span><br><span class="line">public abstract class Writer implements Appendable, Closeable, Flushable &#123; ... &#125;</span><br></pre></td></tr></table></figure><blockquote><p>字节流类和字符流类的 API 大致相同</p></blockquote><blockquote><p>流属于资源，使用后要关闭之（记得擦屁股 - - !）</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/18-3-5/67568977.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>字符流又叫做文本流，是用于操作字符数据的 I/O 流，==通常用来处理字符或字符串数据（汉字、多国语言等）==。</p><ul><li>Reader 字符输入流</li><li>Writer 字符输出流</li></ul><p>每个字节存放一个 ASCII 码，代表一个字符（而对于 Unicode 编码来说，每两个字节表示一个字符）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">File file &#x3D; new File(&quot;C:&#x2F;Users&#x2F;bxm09&#x2F;Desktop&#x2F;test.txt&quot;);</span><br><span class="line"></span><br><span class="line">Writer out &#x3D; new FileWriter(file);</span><br><span class="line">out.write(&quot;hello world!&quot;);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">Reader in &#x3D; new FileReader(file);</span><br><span class="line">char[] accept &#x3D; new char[1024]; &#x2F;&#x2F; 此数组用于存放读取到的数据</span><br><span class="line">int len &#x3D; in.read(accept);</span><br><span class="line">System.out.println(new String(accept, 0, len)); &#x2F;&#x2F; 将字符数组转化为字符串</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>字节流又叫做二进制流，是用于操作字节数据的 I/O 流，==通常用来处理二进制数据（多媒体数据、网络传输数据等）==。</p><ul><li>InputStream 字节输入流</li><li>OutputStream 字节输出流</li></ul><p>字节流在输入输出时，与内存中的存储形式相同，以单个字节（Byte）为读写单位。用字节流来处理数据可以节省内存空间和转化时间，但一个字节并不代表一个字符，所以不能直接输出字符形式。</p><p>一般在操作文件流时，不管是字节流还是字符流，都可以按照如下的流程进行：</p><ol><li>使用 File 类找到一个要操作的文件对象。</li><li>使用 File 类的对象去实例化字节流类或字符流类的子类</li><li>使用字节/字符的读写操作</li><li>关闭 IO 流资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"C:/Users/bxm09/Desktop/test.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写文件</span></span><br><span class="line">OutputStream out = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="string">"hello world!"</span>.getBytes();</span><br><span class="line">out.write(b);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"><span class="keyword">byte</span>[] accept = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; <span class="comment">// 此数组用于存放读取到的数据</span></span><br><span class="line"><span class="keyword">int</span> len = in.read(accept);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(accept, <span class="number">0</span>, len)); <span class="comment">// 将字节数组转化为字符串</span></span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><p>使用文件流可以将数据永久保存在文件中。</p><ul><li>FileInputStream 字节文件输入流</li><li>FileOutputStream 字节文件输出流</li><li>FileReader 字符文件输入流</li><li>FileWriter 字符文件输出流</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 文件流初体验</span><br><span class="line">&#x2F;&#x2F; 使用 FileInputStream 向文件写入数据，然后使用 FileOutputStream 读取文件中的数据</span><br><span class="line"></span><br><span class="line">File file &#x3D; new File(&quot;hello.txt&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写文件</span><br><span class="line">try &#123;</span><br><span class="line">    OutputStream out &#x3D; new FileOutputStream(file);</span><br><span class="line">    out.write(&quot;HELLO WORLD&quot;.getBytes());</span><br><span class="line"></span><br><span class="line">    out.flush(); &#x2F;&#x2F; 记得擦屁股</span><br><span class="line">    out.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 读文件</span><br><span class="line">try &#123;</span><br><span class="line">    InputStream in &#x3D; new FileInputStream(file);</span><br><span class="line">    byte[] data &#x3D; new byte[1024]; &#x2F;&#x2F; 用于存储读取到的数据</span><br><span class="line">    int len &#x3D; in.read(data);</span><br><span class="line">    System.out.println(new String(data, 0, len));</span><br><span class="line"></span><br><span class="line">    in.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>为了达到较高的转换效率，建议不要直接使用 InputStream、OutputStream 来进行读写，而应尽量使用缓冲流类来对数据进行缓存处理。</p><ul><li>BufferedReader 字符缓冲输入流</li><li>BufferedWriter 字符缓冲输出流</li><li>InputStreamReader 字节缓冲输入流</li><li>OutputStreamWriter 字节缓冲输出流</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/18-7-11/43278259.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 缓冲流初体验，性能对比，复制一首歌曲</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    InputStream in &#x3D; new FileInputStream(&quot;爱我中华.mp3&quot;); &#x2F;&#x2F; 指定需要复制的文件路径</span><br><span class="line">    OutputStream out &#x3D; new FileOutputStream(&quot;爱我中华2.mp3&quot;); &#x2F;&#x2F; 指定文件复制后的输出路径</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; copyOfByte(in, out); &#x2F;&#x2F; 耗时18599毫秒</span><br><span class="line">    &#x2F;&#x2F; copyOfByteArray(in, out); &#x2F;&#x2F; 耗时40毫秒</span><br><span class="line">    copyOfBuffer(in, out); &#x2F;&#x2F; 耗时14毫秒</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1. 使用字节读写</span><br><span class="line">private static void copyOfByte(InputStream in, OutputStream out) throws IOException &#123;</span><br><span class="line">    long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    int data &#x3D; 0;</span><br><span class="line">    while (data !&#x3D; -1) &#123;</span><br><span class="line">        data &#x3D; in.read(); &#x2F;&#x2F; read 方法返回 -1 表示要读的文件已经到了尽头</span><br><span class="line">        out.write(data);</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line"></span><br><span class="line">    long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;耗时&quot; + (endTime - startTime) + &quot;毫秒&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 使用字节数组读写</span><br><span class="line">private static void copyOfByteArray(InputStream in, OutputStream out) throws IOException &#123;</span><br><span class="line">    long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    byte[] bytes &#x3D; new byte[1024];</span><br><span class="line">    int data &#x3D; 0;</span><br><span class="line">    while (data !&#x3D; -1) &#123;</span><br><span class="line">        data &#x3D; in.read(bytes);</span><br><span class="line">        out.write(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line"></span><br><span class="line">    long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;耗时&quot; + (endTime - startTime) + &quot;毫秒&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 使用缓冲流来读写</span><br><span class="line">private static void copyOfBuffer(InputStream in, OutputStream out) throws IOException &#123;</span><br><span class="line">    long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    InputStream buffIn &#x3D; new BufferedInputStream(in);</span><br><span class="line">    OutputStream buffOut &#x3D; new BufferedOutputStream(out);</span><br><span class="line">    byte[] bytes &#x3D; new byte[1024];</span><br><span class="line">    int data;</span><br><span class="line">    while ((data &#x3D; buffIn.read(bytes)) !&#x3D; -1) &#123;</span><br><span class="line">        buffOut.write(bytes, 0, data);</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line"></span><br><span class="line">    long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;耗时&quot; + (endTime - startTime) + &quot;毫秒&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>字符流对字节流进行了包装，使其可以接受字符串的输入，字符流在输入时在其底层将字符转化为字节，读取时又将字节转化为字符。如果要将字节显示为字符，就需要用到字节与字符的转换。</p><ul><li>InputStreamReader：字节输入流转为字符输入流</li><li>OutputStreamWriter：字节输出流转为字符输出流</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 读取来自控制台的输入</span><br><span class="line">BufferedReader buffIn &#x3D; new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">BufferedWriter buffOut &#x3D; new BufferedWriter(new OutputStreamWriter(System.out));</span><br><span class="line"></span><br><span class="line">String readLine &#x3D; buffIn.readLine(); &#x2F;&#x2F; 读取键盘上输入的一整行字符</span><br></pre></td></tr></table></figure><blockquote><p>JDK 5 后的版本我们也可以使用 Java Scanner 类来获取控制台的输入。</p></blockquote><h3 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h3><p>管道：将一个程序的输出当做另一个程序的输入。</p><p>管道流主要用于连接两个线程间的通讯。</p><p>管道流分为两组：</p><ul><li>字节管道操作流：PipedInputStream、PipedOutputStream</li><li>字符管道操作流：PipedReader、PipedWriter</li></ul><p>一个 PipedInputStream 对象必须和一个 PipedOutputStream 对象进行连接，才能产生一个通信管道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PipedInputStream;</span><br><span class="line">import java.io.PipedOutputStream;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 管道流</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Sender sender &#x3D; new Sender();</span><br><span class="line">        Receiver receiver &#x3D; new Receiver();</span><br><span class="line"></span><br><span class="line">        PipedOutputStream out &#x3D; sender.getPipedOutputStream(); &#x2F;&#x2F; 返回各自的管道流</span><br><span class="line">        PipedInputStream in &#x3D; receiver.getPipedInputStream();</span><br><span class="line"></span><br><span class="line">        out.connect(in); &#x2F;&#x2F; 管道连接</span><br><span class="line"></span><br><span class="line">        new Thread(sender).start(); &#x2F;&#x2F; 启动线程</span><br><span class="line">        new Thread(receiver).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 消息发送方</span><br><span class="line">class Sender implements Runnable &#123;</span><br><span class="line">    PipedOutputStream out &#x3D; new PipedOutputStream();</span><br><span class="line"></span><br><span class="line">    public PipedOutputStream getPipedOutputStream() &#123;</span><br><span class="line">        return out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        String str &#x3D; &quot;hello world!&quot;;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            out.write(str.getBytes());</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 消息接受方</span><br><span class="line">class Receiver implements Runnable &#123;</span><br><span class="line">    PipedInputStream in &#x3D; new PipedInputStream();</span><br><span class="line"></span><br><span class="line">    public PipedInputStream getPipedInputStream() &#123;</span><br><span class="line">        return in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        byte[] accept &#x3D; new byte[1024];</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            int len &#x3D; in.read(accept);</span><br><span class="line">            System.out.println(&quot;Receiver：&quot; + new String(accept, 0, len));</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>打印流是一个输出信息最方便的流类，==如果由程序向一个终端输出数据时，一定要使用打印流==。</p><p>打印流特点：</p><ol><li>不抛出 IO 异常</li><li>自动刷新</li></ol><p>打印流分为两组：</p><ul><li>字节打印流：PrintStream</li><li>字符打印流：PrintWriter</li></ul><p>PrintStream 类提供了一系列重载的 print 和 println 方法，用来将基本数据类型的格式转换为字符串进行输出，对于一个非基本数据类型的对象，print 和 println 方法会默认调用对象的 toString 方法。</p><p>PrintStream 继承了 OutputStream类，并且实现了方法 write()，但是 write() 方法不经常使用，因为 print() 和 println() 方法用起来更为方便。</p><blockquote><p>打印流使用的是“装饰设计模式”，即：将一个不是很完善的功能，添加一些代码后将其完善起来。</p></blockquote><blockquote><p><code>System.out.prinln</code> 语句中的 <code>System.out</code> 就是 PrintStream 类的一个实例化对象。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 向屏幕输出信息</span><br><span class="line">PrintWriter out &#x3D; new PrintWriter(System.out);</span><br><span class="line">out.println(&quot;hello&quot;);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向文件输出信息</span><br><span class="line">File f &#x3D; new File(&quot;C:&#x2F;Users&#x2F;bxm09&#x2F;Desktop&#x2F;test.txt&quot;);</span><br><span class="line">PrintWriter out &#x3D; new PrintWriter(new FileWriter(f));</span><br><span class="line">out.println(&quot;hello&quot;);</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure><h4 id="打印流的格式化输出"><a href="#打印流的格式化输出" class="headerlink" title="打印流的格式化输出"></a>打印流的格式化输出</h4><p>类似C语言的 printf 函数，即用一些占位标记来暂时代替输出。</p><table><thead><tr><th>占位标记</th><th>含义</th></tr></thead><tbody><tr><td>%s</td><td>字符串</td></tr><tr><td>%S</td><td>字符串（大写形式）</td></tr><tr><td>%c</td><td>字符</td></tr><tr><td>%d</td><td>整数（十进制）</td></tr><tr><td>%o</td><td>整数（八进制）</td></tr><tr><td>%x</td><td>整数（十六进制）</td></tr><tr><td>%X</td><td>整数（十六进制大写形式）</td></tr><tr><td>%f</td><td>小数</td></tr><tr><td>%.nf</td><td>小数（限制小数位数）</td></tr><tr><td>%e</td><td>科学计数法</td></tr><tr><td>%E</td><td>科学计数法（大写形式）</td></tr><tr><td>%n</td><td>换行</td></tr><tr><td>%b</td><td>布尔值</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(&quot;字符串：%s，小数：%.2f&quot;, &quot;hello&quot;, 20.123); &#x2F;&#x2F; 字符串：hello，小数：20.12</span><br></pre></td></tr></table></figure><h3 id="内存操作流"><a href="#内存操作流" class="headerlink" title="内存操作流"></a>内存操作流</h3><p>在内存中读写数据，而不是在文件中。此时，内存作为源和目的地。</p><p>内存操作流分为两组：</p><ul><li>字节内存操作流：ByteArrayInputStream、ByteArrayOutputStream</li><li>字符内存操作流：CharArrayReade、CharArrayWriter</li></ul><h3 id="合并流（序列流）"><a href="#合并流（序列流）" class="headerlink" title="合并流（序列流）"></a>合并流（序列流）</h3><p>SequenceInputStream 类可以将多个输入流按顺序连接起来，也可以实现多个文件的合并操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 两个文件的合并为一个文件</span><br><span class="line">File f1 &#x3D; new File(&quot;e:&#x2F;1.txt&quot;);</span><br><span class="line">File f2 &#x3D; new File(&quot;e:&#x2F;2.txt&quot;);</span><br><span class="line">File f3 &#x3D; new File(&quot;e:&#x2F;3.txt&quot;);</span><br><span class="line"></span><br><span class="line">FileInputStream in1 &#x3D; new FileInputStream(f1); &#x2F;&#x2F; 文件输入流</span><br><span class="line">FileInputStream in2 &#x3D; new FileInputStream(f2); &#x2F;&#x2F; 文件输入流</span><br><span class="line"></span><br><span class="line">SequenceInputStream s &#x3D; new SequenceInputStream(in1, in2); &#x2F;&#x2F; 将两个输入流合并为一个输入流</span><br><span class="line"></span><br><span class="line">FileOutputStream out &#x3D; new FileOutputStream(f3); &#x2F;&#x2F; 文件输出流</span><br><span class="line"></span><br><span class="line">int len;</span><br><span class="line">while ((len &#x3D; s.read()) !&#x3D; -1) &#123;</span><br><span class="line">    out.write(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in1.close();</span><br><span class="line">in2.close();</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure><h3 id="对象流（对象序列化）"><a href="#对象流（对象序列化）" class="headerlink" title="对象流（对象序列化）"></a>对象流（对象序列化）</h3><p>对象序列化是指将内存中保存的对象转化为二进制数据流的形式的一种操作。通过对象序列化，可以方便的地实现对象的存储和读取。</p><p>对象反序列化就是使用 ObjectInputStream 类将序列化的对象读取出来。</p><p>在 Java 中，并不是所有类的对象都可以被序列化，会报<code>NotSerializableException</code>异常，只有实现了 <code>java.io.Serializable</code> 接口的类的对象可以被序列化，Serializable 接口中没有任何成员，是一个标识接口。</p><p>有两个类用于对象序列化操作：</p><ul><li>对象输入流：ObjectInputStream</li><li>对象输出流：ObjectOutputStream</li></ul><h4 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h4><p>阻止对象序列化</p><p>在默认情况下，当一个类的对象序列化时，会将这个类的所有属性都保存下来，如果不希望类中的某个属性被序列化，就需要加上 transient 关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        File file &#x3D; new File(&quot;.&#x2F;test&quot;);</span><br><span class="line">        serializ(file);</span><br><span class="line">        deserializ(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对象序列化：存储</span><br><span class="line">    private static void serializ(File file) throws Exception &#123;</span><br><span class="line">        OutputStream out &#x3D; new FileOutputStream(file);</span><br><span class="line">        ObjectOutputStream cout &#x3D; new ObjectOutputStream(out);</span><br><span class="line">        cout.writeObject(new Person(&quot;白小明&quot;)); &#x2F;&#x2F; 写对象</span><br><span class="line">        cout.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对象反序列化：读取</span><br><span class="line">    private static void deserializ(File file) throws Exception &#123;</span><br><span class="line">        InputStream in &#x3D; new FileInputStream(file);</span><br><span class="line">        ObjectInputStream cin &#x3D; new ObjectInputStream(in);</span><br><span class="line">        Person p &#x3D; (Person) cin.readObject(); &#x2F;&#x2F; 读对象</span><br><span class="line">        System.out.println(p.getName()); &#x2F;&#x2F; null</span><br><span class="line">        cin.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;serial&quot;)</span><br><span class="line">class Person implements Serializable &#123;</span><br><span class="line">    private transient String name; &#x2F;&#x2F; 该属性不想被序列化</span><br><span class="line"></span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;I-O-概述&quot;&gt;&lt;a href=&quot;#I-O-概述&quot; class=&quot;headerlink&quot; title=&quot;I/O 概述&quot;&gt;&lt;/a&gt;I/O 概述&lt;/h2&gt;&lt;p&gt;利用 Java 的 I/O（input/output，输入和输出）技术可以将数据保存到文本文件、二进制文件甚至是压缩包之中，以达到永久性保存数据的要求。I/O 通常使用“流”的方式进行数据传输，一个流必须有源和目的地，他们通常是磁盘文件，但也可以是键盘、鼠标、显示器、内存甚至是网络等设备。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://bxm0927.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://bxm0927.github.io/tags/Java/"/>
    
      <category term="IO" scheme="https://bxm0927.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Java 类集框架详细解读</title>
    <link href="https://bxm0927.github.io/2018/07/11/Java-Collection/"/>
    <id>https://bxm0927.github.io/2018/07/11/Java-Collection/</id>
    <published>2018-07-11T05:48:05.000Z</published>
    <updated>2020-09-09T12:45:15.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类集框架概述"><a href="#类集框架概述" class="headerlink" title="类集框架概述"></a>类集框架概述</h2><p>类集框架又叫做集合框架或集合类，是 Java 提供的一套性能优良、使用方便的接口和类，位于<code>java.util</code>包中。类集框架本质上是对基本的数据结构（线性表、树等）和算法（查找、排序等）的封装。</p><a id="more"></a><p>由于基本数据类型不能保存一系列的数据，对其进行扩展便形成了数组；又由于数组长度不可更改，缺乏灵活性，对数组进一步扩展便形成了功能更强大的“类集框架”。数组和类集框架都是一种“容器”，不同的是：</p><ul><li>数组的长度时固定的，集合类的长度时可变的；</li><li>数组用来存放基本数据类型，集合类用来存储对象的引用，不能存储基本数据类型，存储的基本数据类型会进行自动类型转换。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合类初体验</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(list.size()); <span class="comment">// 2</span></span><br><span class="line">    System.out.println(list); <span class="comment">// [1, 2]</span></span><br><span class="line">    list.forEach(item -&gt; System.out.print(item + <span class="string">" "</span>)); <span class="comment">// 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类集框架体系结构"><a href="#类集框架体系结构" class="headerlink" title="类集框架体系结构"></a>类集框架体系结构</h2><p>类集框架最上层定义了两个接口，Collection 和 Map，Collection 叫做集合接口，每次只保存一个对象；Map 叫做映射接口，每次保存一对对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; ... &#125;</span><br><span class="line">public interface Map&lt;K,V&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>在类集框架的类中，有一些是上层接口，有一些是抽象类（如：AbstractCollection、AbstractList、AbstractSet、AbstractMap等），提供了接口的部分实现，还有一些是具体实现类，这些类可以直接拿来使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; ... &#125;</span><br><span class="line">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; ... &#125;</span><br><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><img src="http://oph264zoo.bkt.clouddn.com/18-2-28/99945912.jpg" alt=""></p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素。Collection 接口很少在开发中直接去使用，且没有直接实现它的标准类，通常都会用它的子接口 List 和 Set。</p><p>Collection 接口中定义的常用抽象方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>int size()</code></td><td>类集中元素的个数</td></tr><tr><td><code>boolean add(Object obj)</code></td><td>将 obj 添加到类集中</td></tr><tr><td><code>boolean addAll(Collection c)</code></td><td>将 c 中的所有元素添加到类集中</td></tr><tr><td><code>boolean remove(Object obj)</code></td><td>从类集中删除 obj</td></tr><tr><td><code>boolean removeAll(Collection c)</code></td><td>从类集中删除 c 中的所有元素</td></tr><tr><td><code>boolean retainAll(Collection c)</code></td><td>从类集中删除除了包含在 c 中的所有的元素</td></tr><tr><td><code>void clear()</code></td><td>清空类集中的元素</td></tr><tr><td><code>boolean contains(Object obj)</code></td><td>obj 是否属于该类集</td></tr><tr><td><code>boolean containsAll(Collection c)</code></td><td>c 中所有元素是否都属于该类集</td></tr><tr><td><code>boolean isEmpty()</code></td><td>类集是否为空</td></tr><tr><td><code>Object[] toArray()</code></td><td>将类集中的元素以数组的形式返回</td></tr><tr><td><code>Object[] toArray(Object array[])</code></td><td>将类集中指定类型的元素以数组的形式返回</td></tr><tr><td><code>Iterator iterator()</code></td><td>调用类集的迭代器</td></tr></tbody></table><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List 接口是实现了 Collection 接口的子接口，是数据结构中的线性表的体现，List 接口下还有一些实现它的标准类：ArrayList、LinkedList，其中：</p><ul><li>ArrayList 是顺序表的体现</li><li>LinkedList 是链表的体现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; ... &#125;</span><br><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; ... &#125;</span><br><span class="line">public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>List 集合的特点是：</p><ul><li>List 集合中的元素允许重复</li><li>List 集合中存储的元素在逻辑上是有序的，因此能够通过索引来访问 List 中的元素，能够精确的控制每个元素插入的位置</li></ul><p>List 接口对 Collection 接口进行了扩充，增加了一些方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Object set(int index, Object obj)</code></td><td>对列表中指定索引处的对象进行赋值</td></tr><tr><td><code>Object get(int index)</code></td><td>查找列表中指定索引处的对象（根据索引找对象）</td></tr><tr><td><code>int indexOf(Object obj)</code></td><td>查找列表中 obj 第一次出现的索引，没有则返回 -1（根据对象找索引）</td></tr><tr><td><code>int lastIndexOf(Object obj)</code></td><td>查找列表中 obj 最后一次出现的索引，没有则返回 -1（根据对象找索引）</td></tr><tr><td><code>void add(int index, Object obj)</code></td><td>将 obj 插入到列表的 index 索引处（列表动态扩容）</td></tr><tr><td><code>boolean addAll(int index, Collection c)</code></td><td>将 c 中的所有元素插入到列表的 index 索引处</td></tr><tr><td><code>Object remove(int index)</code></td><td>删除列表中指定索引处的对象（列表动态压缩）</td></tr><tr><td><code>List subList(int start, int end)</code></td><td>返回一个子列表</td></tr><tr><td><code>ListIterator listIterator()</code></td><td>调用列表开始的迭代器</td></tr><tr><td><code>ListIterator listIterator(int index)</code></td><td>调用列表指定索引处开始的迭代器</td></tr></tbody></table><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><blockquote><p>可以这么说，Java 中最常用的两个类就是 String 和 ArrayList 了</p></blockquote><p>ArrayList 是 List 接口的实现类，是数据结构中顺序表的体现，相当于一个动态数组（长度可变的数组）。ArrayList 的底层是<code>Object[]</code>，String 底层是 <code>char[]</code> 数组。</p><p>除了上层 List 给予的特性外，ArrayList 集合类还具有以下的特性：</p><ul><li>允许有 null 元素</li><li>不同步，非线程安全</li><li>访问快（查找、遍历），时间复杂度是O(1)；更新慢（插入、删除），时间复杂度为O(n)。当 ArrayLIst 里有大量数据时，这时候去频繁插入或删除元素，会触发底层数组频繁拷贝，效率很低，还会造成内存空间的浪费。</li></ul><p>ArrayList 类的构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList();                    &#x2F;&#x2F; 初始容量为 10</span><br><span class="line">ArrayList(int initialCapacity); &#x2F;&#x2F; 指定初始容量为 initialCapacity 大小</span><br><span class="line">ArrayList(Collection c);        &#x2F;&#x2F; 由 c 中的元素初始化</span><br></pre></td></tr></table></figure><blockquote><p>注意：虽然初始化数组的长度是10，但是size是0，size是实际长度，并不是数组的容量</p></blockquote><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList 是 List 接口的实现类，是数据结构中链表（双向循环链表）的体现。链表在物理存储上通常是非连续的，数据元素的逻辑顺序通过链表中的指针引用来实现。</p><p>除了上层 List 给予的特性外，LinkedList 集合类还具有以下的特性：</p><ul><li>允许有 null 元素</li><li>不同步，非线程安全</li><li>访问慢（查找、遍历），更新快（插入、删除），因为插入和删除时不会触发底层数组的复制</li></ul><p>LinkedList 类的构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkedList();               &#x2F;&#x2F; 初始容量为 10</span><br><span class="line">LinkedList(Collection c);   &#x2F;&#x2F; 由 c 中的元素初始化</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; LinkedList 初体验</span><br><span class="line">LinkedList&lt;Integer&gt; linkedList &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line">System.out.println(linkedList); &#x2F;&#x2F; []</span><br><span class="line"></span><br><span class="line">linkedList.addFirst(1); &#x2F;&#x2F; 这里会自动装箱 int -&gt; Integer</span><br><span class="line">linkedList.addFirst(2);</span><br><span class="line">linkedList.addLast(3);</span><br><span class="line">linkedList.addLast(4);</span><br><span class="line">System.out.println(linkedList); &#x2F;&#x2F; [2, 1, 3, 4]</span><br><span class="line"></span><br><span class="line">linkedList.removeFirst();</span><br><span class="line">linkedList.removeLast();</span><br><span class="line">System.out.println(linkedList); &#x2F;&#x2F; [1, 3]</span><br><span class="line"></span><br><span class="line">linkedList.set(1, 9527);</span><br><span class="line">System.out.println(linkedList.get(1)); &#x2F;&#x2F; 9527</span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 接口也是 Collection 接口的子接口，它并没有对 Collection 接口进行了扩充，而是完整的继承了 Collection 接口。Set 接口下也有一些实现它的标准类：HashSet、TreeSet、SortedSet。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123; ... &#125;</span><br><span class="line">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; ... &#125;</span><br><span class="line">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>Set 集合的特点是：</p><ul><li>Set 集合中的元素不可重复</li><li>Set 集合中的元素是无序的的，因此不能通过索引来访问 Set 中的元素，但是删除和插入效率较高，因为插入和删除不会引起元素位置改变</li></ul><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>HashSet 类使用哈希表实现了 Set 接口。</p><p>除了上层 Set 给予的特性外，HashSet 集合类还具有以下的特性：</p><ul><li>允许有 null 元素，但最多只能一个</li><li>不同步，非线程安全</li><li>不保证元素的迭代顺序，同 HashMap</li></ul><blockquote><p>所谓无序，就是 Java 语言没有规定 HashSet 按什么顺序遍历。你应该知道，有好多种 Java 虚拟机，有的运行在Windows上，有的运行在 Linux上。即使在同一个平台上，也会有好几种虚拟机。每种虚拟机对 HashSet 的实现都是不一样的，所以每种虚拟机对 HashSet 的遍历顺序可能都不太一样。但对同一种虚拟机来说，你的遍历输出都是一样的。 Java 是跨平台的，你写的程序可能会在不同的平台上运行，这些平台上的虚拟机都是不一样的。如果你选用了 HashSet，就要明白，在不同的平台上，遍历顺序可能会不一样。如果你对遍历顺序有要求，就要考虑使用有序的，或排序的容器。</p></blockquote><p>HashSet 类的构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashSet(); &#x2F;&#x2F; 初始化一个哈希表</span><br><span class="line">HashSet(Collection c); &#x2F;&#x2F; 由 c 中的元素初始化</span><br><span class="line">HashSet(int capacity); &#x2F;&#x2F; 初始容量为 capacity</span><br><span class="line">HashSet(int capacity, float fillRatio); &#x2F;&#x2F; 初始容量为 capacity，填充比 fillRatio，默认 0.75</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HashSet 初体验</span><br><span class="line">HashSet&lt;String&gt; hs &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">hs.add(&quot;F&quot;);</span><br><span class="line">hs.add(&quot;C&quot;);</span><br><span class="line">hs.add(&quot;B&quot;);</span><br><span class="line">hs.add(&quot;E&quot;);</span><br><span class="line">hs.add(&quot;D&quot;);</span><br><span class="line">hs.add(&quot;A&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(hs.size()); &#x2F;&#x2F; 6</span><br><span class="line">System.out.println(hs.add(&quot;C&quot;)); &#x2F;&#x2F; false</span><br><span class="line">hs.remove(&quot;C&quot;);</span><br><span class="line">System.out.println(hs.add(&quot;C&quot;)); &#x2F;&#x2F; true</span><br><span class="line">System.out.println(hs); &#x2F;&#x2F; [A, B, C, D, E, F]</span><br></pre></td></tr></table></figure><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet 类使用树（二叉树）实现 了Set 接口。</p><p>除了上层 Set 给予的特性外，TreeSet 集合类还具有以下的特性：</p><ul><li>对象默认按升序存储，检索很快</li><li>适用于存储大量需要检索的信息</li></ul><p>TreeSet 类的构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeSet(); &#x2F;&#x2F; 初始化一个空的 TreeSet</span><br><span class="line">TreeSet(Collection c); &#x2F;&#x2F; 由 c 中的元素初始化</span><br><span class="line">TreeSet(Comparator comp); &#x2F;&#x2F; 通过比较器（Comparator）自定义比较规则</span><br><span class="line">TreeSet(SortedSet ss);</span><br></pre></td></tr></table></figure><p>TreeSet 类扩充的方法：</p><ul><li>first()：返回第一个元素</li><li>last()：返回最后一个元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; TreeSet 初体验</span><br><span class="line">TreeSet&lt;String&gt; ts &#x3D; new TreeSet&lt;&gt;();</span><br><span class="line">ts.add(&quot;1&quot;);</span><br><span class="line">ts.add(&quot;3&quot;);</span><br><span class="line">ts.add(&quot;2&quot;);</span><br><span class="line">ts.add(&quot;C&quot;);</span><br><span class="line">ts.add(&quot;a&quot;);</span><br><span class="line">ts.add(&quot;B&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(ts.first()); &#x2F;&#x2F; 1</span><br><span class="line">System.out.println(ts); &#x2F;&#x2F; [1, 2, 3, B, C, a]</span><br></pre></td></tr></table></figure><h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h4><p>SortedSet 类也实现了 Set 接口，保存有序的集合。</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>Queue 接口是数据结构中队列的实现，与 List、Set 同一级别，都是继承了 Collection 接口。LinkedList 类实现了 Queue 接口。</p><p>队列有两个基本操作：在队列尾部加入一个元素（入队），和从队列头部移除一个元素（出队）</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>boolean add(E e)</code></td><td>增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常</td></tr><tr><td><code>boolean offer(E e)</code></td><td>添加一个元素并返回true，如果队列已满，则返回false</td></tr><tr><td><code>E remove()</code></td><td>移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</td></tr><tr><td><code>E poll()</code></td><td>移除并返问队列头部的元素，如果队列为空，则返回null</td></tr><tr><td><code>E element()</code></td><td>返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</td></tr><tr><td><code>E peek()</code></td><td>返回队列头部的元素，如果队列为空，则返回null</td></tr></tbody></table><hr><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map 叫做映射接口，它存储的是一系列形如<code>&lt;K, V&gt;</code>的“键值对”元素，提供 key 到 value 的映射，通过 key 就能找到对应的 value，key 必须是唯一的，value 可以相同。</p><p>Map 接口下也有一些实现它的标准类：HashMap、TreeMap、SortedMap 等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Map&lt;K,V&gt; &#123; ... &#125;</span><br><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable  &#123; ... &#125;</span><br><span class="line">public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><img src="http://oph264zoo.bkt.clouddn.com/17-10-6/95753617.jpg" alt=""></p><p>Map 接口中常用的方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>int size()</code></td><td>返回“键值对”的个数</td></tr><tr><td><code>Object get(Object k)</code></td><td>通过 key 获取 value</td></tr><tr><td><code>Object put(Object k, Object v)</code></td><td>添加一对对象到映射中，同时改写原来 key 所对应 value（如果存在的话）</td></tr><tr><td><code>Object putAll(Map m)</code></td><td>将映射 m 添加到调用的映射中</td></tr><tr><td><code>void remove(Object k)</code></td><td>删除关键字为 k 的那一对对象</td></tr><tr><td><code>void clear()</code></td><td>清空映射</td></tr><tr><td><code>boolean containsKey()</code></td><td>映射中是否存在该 key</td></tr><tr><td><code>boolean containsValue()</code></td><td>映射中是否存在该 value</td></tr><tr><td><code>boolean isTmpty()</code></td><td>映射是否为空</td></tr><tr><td><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></td><td>将 Map 变为 Collection 返回</td></tr><tr><td><code>Set&lt;k&gt; keySet()</code></td><td>得到键的“类集视图”</td></tr><tr><td><code>Collection values()</code></td><td>得到值的“类集视图”</td></tr></tbody></table><blockquote><p>需要注意的是，Map 并不属于 Collection，他们没有任何亲缘关系。但可以通过一些方法获得映射的类集视图：entrySet()、keySet() 和 values()，“类集视图”是将映射集成到类集框架内的手段。</p></blockquote><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap 类使用哈希表实现 Map 接口</p><p>HashMap 集合类的特点：</p><ul><li>允许有 null 元素，但 key 最多有一个 null，value 不限制</li><li>不同步，非线程安全</li><li>更新快（插入、删除元素）</li><li>不保证元素的迭代顺序，同 HashSet</li></ul><p>HashMap 类的构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap(); &#x2F;&#x2F; 初始化一个散列映射</span><br><span class="line">HashMap(Map m); &#x2F;&#x2F; 由 m 中的元素初始化</span><br><span class="line">HashMap(int capacity); &#x2F;&#x2F; 初始容量为 capacity</span><br><span class="line">HashMap(int capacity, float fillRatio); &#x2F;&#x2F; 初始容量为 capacity，填充比 fillRatio，默认 0.75</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Double&gt; hm &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">System.out.println(hm); &#x2F;&#x2F; &#123;&#125;</span><br><span class="line"></span><br><span class="line">hm.put(&quot;苹果&quot;, 19.8);</span><br><span class="line">hm.put(&quot;橘子&quot;, 15.0);</span><br><span class="line">hm.put(&quot;香蕉&quot;, 13.5);</span><br><span class="line">hm.put(&quot;香蕉&quot;, 14.5); &#x2F;&#x2F; 修改元素</span><br><span class="line">System.out.println(hm); &#x2F;&#x2F; &#123;苹果&#x3D;19.8, 香蕉&#x3D;14.5, 橘子&#x3D;15.0&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将 Map 转换为 Set</span><br><span class="line">Set&lt;Entry&lt;String, Double&gt;&gt; set &#x3D; hm.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String, Double&gt;&gt; it &#x3D; set.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Double&gt; entry &#x3D; (Map.Entry&lt;String, Double&gt;) it.next();</span><br><span class="line"></span><br><span class="line">    System.out.println(entry); &#x2F;&#x2F; 苹果&#x3D;19.8 香蕉&#x3D;14.5 橘子&#x3D;15.0</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap 类使用树（二叉树）来实现 Map 接口。</p><p>TreeMap 集合类的特点：</p><ul><li>key 和 value 都不允许有 null 元素</li><li>元素按升序排序</li><li>更新和访问的效率不如 HashMap</li></ul><p>TreeMap 类的构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeMap(); &#x2F;&#x2F; 初始化一个空的树映射</span><br><span class="line">TreeMap(Comparator comp); &#x2F;&#x2F; 通过比较器（Comparator）自定义比较规则</span><br><span class="line">TreeMap(Map m); &#x2F;&#x2F; 由 m 中的元素初始化</span><br><span class="line">TreeMap(sortedMap sm); &#x2F;&#x2F; 由 sm 中的元素初始化</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;String, Double&gt; tm &#x3D; new TreeMap&lt;String, Double&gt;();</span><br><span class="line">System.out.println(tm); &#x2F;&#x2F; &#123;&#125;</span><br><span class="line"></span><br><span class="line">tm.put(&quot;苹果&quot;, 19.8);</span><br><span class="line">tm.put(&quot;橘子&quot;, 15.0);</span><br><span class="line">tm.put(&quot;香蕉&quot;, 13.5);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set &#x3D; tm.keySet();</span><br><span class="line">Iterator&lt;String&gt; it &#x3D; set.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    String string &#x3D; (String) it.next();</span><br><span class="line">    System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collection&lt;Double&gt; coll &#x3D; tm.values();</span><br><span class="line">Iterator&lt;Double&gt; it2 &#x3D; coll.iterator();</span><br><span class="line">while (it2.hasNext()) &#123;</span><br><span class="line">    Double double1 &#x3D; (Double) it2.next();</span><br><span class="line">    System.out.println(double1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h3><p>SortedMap 类也实现了 Map 接口，使 Key 保持在升序排列。</p><h3 id="Map-Entry-接口"><a href="#Map-Entry-接口" class="headerlink" title="Map.Entry 接口"></a>Map.Entry 接口</h3><p><code>java.util.Map.Entry</code> 接口描述了在一个 Map 中的一个元素（键/值对），其中有两个重要的方法：</p><ul><li><code>getKey()</code></li><li><code>getValue()</code></li></ul><h2 id="Collection-的输出和遍历"><a href="#Collection-的输出和遍历" class="headerlink" title="Collection 的输出和遍历"></a>Collection 的输出和遍历</h2><h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h3><p>Iterator 是标准的类集输出方式。</p><p>迭代器（Iterator）是一种设计模式，Java 把它封装成了一个接口，利用这个接口的迭代方法<code>iterator()</code>可以实现类集的遍历。</p><p>每一个 Collection 接口的标准实现类都提供一个迭代方法<code>iterator()</code>，调用这个方法返回一个该类集的迭代器（类似 C 语言中的指针），用来遍历该类集的每一个元素。</p><p>Iterator 接口定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">    public boolean hasNext();</span><br><span class="line">    public E next();</span><br><span class="line">    public void remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>hasNext：判断是否有下一个元素</li><li>next：取得下一个元素</li><li>remove：删除当前元素（需要先通过<code>next</code>取得元素）</li></ul><p>使用迭代方法的步骤：</p><ol><li>调用该类集的<code>iterator()</code>方法获取该类集的迭代器</li><li><code>hasNext()</code>为真就进行迭代</li><li>使用<code>next()</code>取得元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;hello&quot;);</span><br><span class="line">list.add(&quot;Java&quot;);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator &#x3D; list.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    String elem &#x3D; iterator.next();</span><br><span class="line">    System.out.println(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向迭代器-ListIterator"><a href="#双向迭代器-ListIterator" class="headerlink" title="双向迭代器 ListIterator"></a>双向迭代器 ListIterator</h3><p>双向迭代器 <code>ListIterator</code> 扩展了迭代器 <code>Iterator</code>，增加了一些方法，允许双向遍历类集，并且可以修改元素</p><blockquote><p>注意：完成反向遍历前，需要先进行正向遍历，让迭代器（指针）指向类集尾部</p></blockquote><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>void add(Object obj)</code></td><td>将 obj 插入到列表</td></tr><tr><td><code>void set(Object obj)</code></td><td>将 obj 赋给当前元素</td></tr><tr><td><code>void remove()</code></td><td>删除当前元素</td></tr><tr><td><code>boolean hasNext()</code></td><td>是否有下一个元素</td></tr><tr><td><code>boolean hasPrevious()</code></td><td>是否有上一个元素</td></tr><tr><td><code>boolean next()</code></td><td>取得下一个元素</td></tr><tr><td><code>boolean previous()</code></td><td>取得上一个元素</td></tr><tr><td><code>boolean nextIndex()</code></td><td>取得下一个元素的索引</td></tr><tr><td><code>boolean previousIndex()</code></td><td>取得上一个元素的索引</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; al &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">al.add(&quot;a&quot;);</span><br><span class="line">al.add(&quot;b&quot;);</span><br><span class="line">al.add(&quot;c&quot;);</span><br><span class="line">System.out.println(al);</span><br><span class="line"></span><br><span class="line">ListIterator&lt;String&gt; listIt &#x3D; al.listIterator(); &#x2F;&#x2F; 返回该类集的双向迭代器 listIt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正向遍历</span><br><span class="line">while (listIt.hasNext()) &#123;</span><br><span class="line">    String string &#x3D; (String) listIt.next();</span><br><span class="line">    listIt.set(string + &quot;-set&quot;); &#x2F;&#x2F; 修改元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 反向遍历</span><br><span class="line">while (listIt.hasPrevious()) &#123;</span><br><span class="line">    String string &#x3D; (String) listIt.previous();</span><br><span class="line">    System.out.println(string); &#x2F;&#x2F; c-set b-set a-set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举迭代-Enumeration"><a href="#枚举迭代-Enumeration" class="headerlink" title="枚举迭代 Enumeration"></a>枚举迭代 Enumeration</h3><p>Enumeration 属于最古老的输出接口之一，==尽管没有被废弃，但是已经被迭代器 <code>Iterator</code> 所取代。==</p><p>若要取得 Enumeration 的对象，只能依靠 Vector 类。</p><p>Enumeration 接口定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Enumeration&lt;E&gt; &#123;</span><br><span class="line">    public boolean hasMoreElements();</span><br><span class="line">    public E nextElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;String&gt; al &#x3D; new Vector&lt;String&gt;();</span><br><span class="line">al.add(&quot;a&quot;);</span><br><span class="line">al.add(&quot;b&quot;);</span><br><span class="line">al.add(&quot;c&quot;);</span><br><span class="line"></span><br><span class="line">Enumeration&lt;String&gt; en &#x3D; al.elements();</span><br><span class="line">while (en.hasMoreElements()) &#123;</span><br><span class="line">    String string &#x3D; (String) en.nextElement();</span><br><span class="line">    System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for、foreach、forEach-输出"><a href="#for、foreach、forEach-输出" class="headerlink" title="for、foreach、forEach 输出"></a>for、foreach、forEach 输出</h3><p>foreach 不仅可以用来遍历数组，也可以用来遍历集合类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;hello&quot;);</span><br><span class="line">list.add(&quot;Java&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 普通 foreach</span><br><span class="line">for (String elem : list) &#123;</span><br><span class="line">    System.out.println(elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Java 8 Lambda 表达式</span><br><span class="line">list.forEach(item -&gt; &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Map-的输出和遍历"><a href="#Map-的输出和遍历" class="headerlink" title="Map 的输出和遍历"></a>Map 的输出和遍历</h2><blockquote><p>遍历技巧：如果需要在遍历过程中增加元素，可以新建一个临时map存放新增的元素，等遍历完毕，再把临时map放到原来的map中</p></blockquote><p>遍历集合类有多种方法，从最早的 Iterator，到 Java 5 支持的 foreach ，再到 Java 8 的 Lambda 表达式，让我们一起来看下具体的用法以及各自的优缺点：</p><h3 id="entrySet"><a href="#entrySet" class="headerlink" title="entrySet()"></a>entrySet()</h3><p>可以同时拿到key和value，这一种也是最常用的遍历方法，==推荐使用==。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;name&quot;, &quot;白小明&quot;);</span><br><span class="line">map.put(&quot;sex&quot;, &quot;男&quot;);</span><br><span class="line"></span><br><span class="line">for (Map.Entry&lt;String, String&gt; string : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(string.getKey());</span><br><span class="line">    System.out.println(string.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="keySet-、values"><a href="#keySet-、values" class="headerlink" title="keySet()、values()"></a>keySet()、values()</h3><p>如果只需要map的key或者value，用map的keySet或values方法无疑是最方便的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;name&quot;, &quot;白小明&quot;);</span><br><span class="line">map.put(&quot;sex&quot;, &quot;男&quot;);</span><br><span class="line"></span><br><span class="line">for (String string : map.keySet()) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (String string : map.values()) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="keySet-、get-key"><a href="#keySet-、get-key" class="headerlink" title="keySet()、get(key)"></a>keySet()、get(key)</h3><p>可以同时拿到key和value，但性能不及上一种，不推荐使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;name&quot;, &quot;白小明&quot;);</span><br><span class="line">map.put(&quot;sex&quot;, &quot;男&quot;);</span><br><span class="line"></span><br><span class="line">for (String string : map.keySet()) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">    System.out.println(map.get(string));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p>Map 接口中没有迭代器<code>iterator()</code>方法，需要先用 <code>entrySet()</code> 等转成集合才行。</p><p>使用 Iterator 的 remove 方法删除元素非常便捷，如果需要在遍历过程中删除元素推荐使用Iterator。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"白小明"</span>);</span><br><span class="line">map.put(<span class="string">"sex"</span>, <span class="string">"男"</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; set = map.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">  Map.Entry&lt;String, String&gt; entry = (Map.Entry&lt;String, String&gt;) it.next();</span><br><span class="line"></span><br><span class="line">  System.out.println(entry.getKey() + <span class="string">" = "</span> + entry.getValue());</span><br><span class="line">  <span class="comment">// it.remove(); // 删除元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-8-Lambda-表达式"><a href="#Java-8-Lambda-表达式" class="headerlink" title="Java 8  Lambda 表达式"></a>Java 8  Lambda 表达式</h3><p>Java 8 提供了 Lambda 表达式支持，语法看起来更简洁，可以同时拿到key和value，不过，经测试，性能低于 entrySet</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;name&quot;, &quot;白小明&quot;);</span><br><span class="line">map.put(&quot;sex&quot;, &quot;男&quot;);</span><br><span class="line"></span><br><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">  System.out.println(key + &quot; &#x3D; &quot; + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="关于-Map-遍历的一个简单的性能测试"><a href="#关于-Map-遍历的一个简单的性能测试" class="headerlink" title="关于 Map 遍历的一个简单的性能测试"></a>关于 Map 遍历的一个简单的性能测试</h2><p>用100万条数据，做了一个简单性能测试，该测试结果仅供参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static int sum;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">        map.put(i, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    entrySet(map); &#x2F;&#x2F; 29 31 31</span><br><span class="line">    lambda(map); &#x2F;&#x2F; 204 202 238</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void entrySet(Map&lt;Integer, Integer&gt; map) &#123;</span><br><span class="line">    long start &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    for (Map.Entry&lt;Integer, Integer&gt; integer : map.entrySet()) &#123;</span><br><span class="line">        sum +&#x3D; integer.getKey() + integer.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long end &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(end - start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void lambda(Map&lt;Integer, Integer&gt; map) &#123;</span><br><span class="line">    long start &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    map.forEach((key, value) -&gt; &#123;</span><br><span class="line">        sum +&#x3D; key + value;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    long end &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类集框架概述&quot;&gt;&lt;a href=&quot;#类集框架概述&quot; class=&quot;headerlink&quot; title=&quot;类集框架概述&quot;&gt;&lt;/a&gt;类集框架概述&lt;/h2&gt;&lt;p&gt;类集框架又叫做集合框架或集合类，是 Java 提供的一套性能优良、使用方便的接口和类，位于&lt;code&gt;java.util&lt;/code&gt;包中。类集框架本质上是对基本的数据结构（线性表、树等）和算法（查找、排序等）的封装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://bxm0927.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://bxm0927.github.io/tags/Java/"/>
    
      <category term="Collection" scheme="https://bxm0927.github.io/tags/Collection/"/>
    
      <category term="List" scheme="https://bxm0927.github.io/tags/List/"/>
    
      <category term="Set" scheme="https://bxm0927.github.io/tags/Set/"/>
    
      <category term="Map" scheme="https://bxm0927.github.io/tags/Map/"/>
    
      <category term="集合类" scheme="https://bxm0927.github.io/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
      <category term="类集框架" scheme="https://bxm0927.github.io/tags/%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常处理详细解读</title>
    <link href="https://bxm0927.github.io/2018/07/10/Java-Exception/"/>
    <id>https://bxm0927.github.io/2018/07/10/Java-Exception/</id>
    <published>2018-07-10T02:35:58.000Z</published>
    <updated>2020-09-09T12:45:15.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常概述"><a href="#异常概述" class="headerlink" title="异常概述"></a>异常概述</h2><p>异常（Exception）指的是所有可能造成计算机无法正常处理的情况。发生异常时，将阻止程序的运行，若不妥善处理异常，可能造成计算机死机。经过异常处理，可以保证程序的正常运行，我们把针对不同的异常做妥善的处理的方式叫做“异常处理机制”。</p><p>异常处理的目的：加强程序的健壮性、安全性。</p><a id="more"></a><p>Java 中，所有的异常都被封装到相应的类中，同时，用户也可以自定义异常类和自定义抛出异常。</p><ul><li>抛出异常（throw）：是指将异常提交给运行时系统的过程。</li><li>捕获异常（catch）：是指运行时系统找到发生异常的方法的过程。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/18-7-10/17076115.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="异常类-Throwable"><a href="#异常类-Throwable" class="headerlink" title="异常类 Throwable"></a>异常类 <code>Throwable</code></h2><p>异常类是指由程序抛出的异常对象所属的类。</p><p>异常可以分为两大类：<code>java.lang.Exception</code>类和<code>java.lang.Error</code>类。这两个类均继承自 <code>java.lang.Throwable</code> 类</p><ul><li>Error 类通常指的是 JVM 出错和线程死锁，用户无法在程序中处理（无法捕获）</li><li>Exception 类通常指的是可以处理的异常，分为编译时异常和运行时异常（RuntimeException），编译时异常是 Exception 下除了运行时异常以外的所有异常<ul><li>对于编译时异常，不解决编译就不会通过</li><li>对于运行时异常，可以选择性地来进行处理，如果不处理则出现异常时将交给 JVM 默认处理</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/18-7-10/42397762.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="获取异常信息的方法"><a href="#获取异常信息的方法" class="headerlink" title="获取异常信息的方法"></a>获取异常信息的方法</h3><p><img src="http://oph264zoo.bkt.clouddn.com/18-7-10/87466879.jpg" alt=""></p><h3 id="Java-中常见的异常类"><a href="#Java-中常见的异常类" class="headerlink" title="Java 中常见的异常类"></a>Java 中常见的异常类</h3><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>NullPointerException</td><td>空指向异常（空指针异常）。指的是使用了一个未初始化的对象（未开辟内存空间的对象）。</td></tr><tr><td>ArithmeticException</td><td>算术异常。如：除以零</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>数组下标越界异常。数组的索引超过了上界或下界</td></tr><tr><td>FileNotFoundException</td><td>文件未找到异常</td></tr><tr><td>OutOfMemoryExceptin</td><td>内存溢出异常（内存不足异常）。可用内存不足以分配给一个对象时抛出</td></tr><tr><td>NoSuchElementExceptin</td><td>调用了类集中不存在的元素</td></tr><tr><td>ClassCastExceptin</td><td>对象与类集中的元素不兼容</td></tr><tr><td>UnsupportedOperationExceptin</td><td>修改一个不允许修改的对象</td></tr></tbody></table><h2 id="异常处理-try-catch-finally"><a href="#异常处理-try-catch-finally" class="headerlink" title="异常处理 try-catch-finally"></a>异常处理 <code>try-catch-finally</code></h2><blockquote><p>死了都要 try，不 try 到 catch 不痛快</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/17-10-15/60958506.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当发生异常时，通常有两种处理方法：</p><ol><li>交给 Java 默认的异常处理机制做处理。这种情况 Java 会输出异常信息，然后中断程序的运行</li><li>自己编写 <code>try-catch-finally</code> 来捕获异常。这种情况可以灵活的控制程序，而且程序不会中断运行。</li></ol><p>异常处理的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    &#x2F;&#x2F; 要检查的语句</span><br><span class="line">&#125; catch (异常类 e) &#123;</span><br><span class="line">    &#x2F;&#x2F; 异常发生时的处理语句</span><br><span class="line">    e.printStackTrace(); &#x2F;&#x2F; 打印异常信息</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    &#x2F;&#x2F; 一定会运行到的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>try 语句块不可以独立存在，必须与 catch 或 finally 同存，finally 语句块可以省略</li><li>catch 区块可以有多个，此时异常类型必须子类在前，父类在后</li><li>当 try 区块捕获到异常时，不执行接下来的语句，立即进入 catch 区块</li></ul><p><img src="http://oph264zoo.bkt.clouddn.com/17-10-3/75135977.jpg" alt=""></p><h3 id="finally-语句块不会被执行的情况"><a href="#finally-语句块不会被执行的情况" class="headerlink" title="finally 语句块不会被执行的情况"></a>finally 语句块不会被执行的情况</h3><ol><li>在 finally 语句块中发生了异常</li><li>在前面的代码中使用了 System.exit() 退出程序</li><li>程序所在的线程死亡</li><li>CPU 关闭</li></ol><h3 id="异常处理的几种形式"><a href="#异常处理的几种形式" class="headerlink" title="异常处理的几种形式"></a>异常处理的几种形式</h3><h4 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/18-7-10/67665230.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/18-7-10/14424309.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="try…finally"><a href="#try…finally" class="headerlink" title="try…finally"></a>try…finally</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/18-7-10/32735647.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="向上抛出异常-throws"><a href="#向上抛出异常-throws" class="headerlink" title="向上抛出异常 throws"></a>向上抛出异常 <code>throws</code></h2><p>方法头中使用 <code>throws</code> 关键字可以表明这个方法可能存在的异常类型，此方法不处理异常，而是将该异常提交给调用这个方法的方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/18-7-10/75648718.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; new int[5];</span><br><span class="line">        try &#123;</span><br><span class="line">            setZero(arr, 10);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setZero(int[] arr, int index) throws ArrayIndexOutOfBoundsException &#123;</span><br><span class="line">        arr[index] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自行抛出异常-throw"><a href="#自行抛出异常-throw" class="headerlink" title="自行抛出异常 throw"></a>自行抛出异常 <code>throw</code></h2><p><code>throws</code>用于方法声明中，声明一个方法会抛出哪些异常，而<code>throw</code>是方法体中实际执行抛出异常的动作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw 异常类型的实例</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    throw new ArrayIndexOutOfBoundsException(&quot;我是异常信息&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>当系统提供的异常类不足以满足业务需求时，我们可以自定义异常类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 自定义异常类 extends 异常类型 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            throw new MyException(&quot;我是自定义异常类&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyException extends Exception &#123;</span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    public MyException(String msg) &#123;</span><br><span class="line">        this.msg &#x3D; msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyException [msg&#x3D;&quot; + msg + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理的经验之谈"><a href="#异常处理的经验之谈" class="headerlink" title="异常处理的经验之谈"></a>异常处理的经验之谈</h2><ul><li>不要忽略异常</li><li>只针对异常的情况才使用异常</li><li>优先使用标准异常，而不是直接在方法上 throws Exception 或 Throwable</li><li>每个方法抛出的异常都应该有文档</li><li>处理运行时异常时，采用逻辑规避同时辅助try-catch处理</li><li>在多重catch块后面，可以加上一个<code>catch(Exception)</code>来处理被遗漏的异常</li><li>对于不确定的代码，也可以加上<code>try-catch</code>，处理潜在的异常</li><li>尽量去处理异常，切忌只是简单的调用<code>printStackTrace()</code>去打印输出</li><li>尽量添加<code>finally</code>去释放占用的资源</li><li>具体如何处理异常，要根据不同的业务需求和异常类型去决定</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;异常概述&quot;&gt;&lt;a href=&quot;#异常概述&quot; class=&quot;headerlink&quot; title=&quot;异常概述&quot;&gt;&lt;/a&gt;异常概述&lt;/h2&gt;&lt;p&gt;异常（Exception）指的是所有可能造成计算机无法正常处理的情况。发生异常时，将阻止程序的运行，若不妥善处理异常，可能造成计算机死机。经过异常处理，可以保证程序的正常运行，我们把针对不同的异常做妥善的处理的方式叫做“异常处理机制”。&lt;/p&gt;
&lt;p&gt;异常处理的目的：加强程序的健壮性、安全性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://bxm0927.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://bxm0927.github.io/tags/Java/"/>
    
      <category term="Exception" scheme="https://bxm0927.github.io/tags/Exception/"/>
    
      <category term="异常处理" scheme="https://bxm0927.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 入门详细教程</title>
    <link href="https://bxm0927.github.io/2018/06/26/md/"/>
    <id>https://bxm0927.github.io/2018/06/26/md/</id>
    <published>2018-06-26T00:53:05.000Z</published>
    <updated>2020-09-09T12:45:15.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Markdown-简介"><a href="#Markdown-简介" class="headerlink" title="Markdown 简介"></a>Markdown 简介</h2><ul><li>Markdown 中文官网：<a href="http://www.markdown.cn" target="_blank" rel="noopener">http://www.markdown.cn</a></li><li>【简明版】有道云笔记Markdown指南：<a href="http://note.youdao.com/iyoudao/?p=2411" target="_blank" rel="noopener">http://note.youdao.com/iyoudao/?p=2411</a></li><li>【进阶版】有道云笔记Markdown指南：<a href="http://note.youdao.com/iyoudao/?p=2445" target="_blank" rel="noopener">http://note.youdao.com/iyoudao/?p=2445</a></li></ul><p>Markdown 是一种简单、易读易写的「标记语言」，用来写博客、做笔记非常方便，通常为程序员群体所用。</p><a id="more"></a><p>Markdown 的语法十分简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。用户可以使用一些标记符号以最小的输入代价生成极富表现力的文档（譬如您正在阅读的这份文档就是通过 Markdown 书写的）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/18-6-26/25081922.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="安利一波-Markdown-工具"><a href="#安利一波-Markdown-工具" class="headerlink" title="安利一波 Markdown 工具"></a>安利一波 Markdown 工具</h2><blockquote><p>注意：不同平台的 Markdown 语法会有些许差别。</p></blockquote><p>Markdown 编辑器（支持实时同步预览）：</p><ul><li>VSCode</li><li>Sublime + Markdown 插件（MarkdownPreview）</li></ul><p>Markdown 在线编辑器：</p><ul><li>CSDN 博客：<a href="https://blog.csdn.net" target="_blank" rel="noopener">https://blog.csdn.net</a></li><li>简书：<a href="https://www.jianshu.com" target="_blank" rel="noopener">https://www.jianshu.com</a></li><li>马克飞象：<a href="https://maxiang.io" target="_blank" rel="noopener">https://maxiang.io</a></li><li>作业部落：<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">https://www.zybuluo.com/mdeditor</a></li></ul><p>笔记工具：</p><ul><li>有道云笔记：<a href="https://note.youdao.com" target="_blank" rel="noopener">https://note.youdao.com</a></li><li>印象笔记：<a href="https://www.yinxiang.com" target="_blank" rel="noopener">https://www.yinxiang.com</a></li><li>为知笔记：<a href="http://www.wiz.cn" target="_blank" rel="noopener">http://www.wiz.cn</a></li><li>OneNote：<a href="https://www.onenote.com" target="_blank" rel="noopener">https://www.onenote.com</a></li></ul><h2 id="Markdown-基本语法"><a href="#Markdown-基本语法" class="headerlink" title="Markdown 基本语法"></a>Markdown 基本语法</h2><p>Markdown 的标记语法非常之多，并且不同平台的 Markdown 语法会有些许差别，但是常用的标记符号不超过十个，且平台间基本通用。</p><p>常用标记：标题、粗体、斜体、删除线、下划线、高亮、引用、分割线、链接与图片</p><p>不常用标记：列表、待办事项、表格、代码高亮、流程图、序列图、甘特图、数学公式</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/2-0-%E6%A0%87%E9%A2%98.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h3 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/2-3-%E7%B2%97%E4%BD%93%E6%96%9C%E4%BD%93.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/2-2%E5%BC%95%E7%94%A8.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h3 id="链接与图片"><a href="#链接与图片" class="headerlink" title="链接与图片"></a>链接与图片</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/2-4%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%9B%BE%E7%89%87.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/2-5-%E5%88%86%E5%89%B2%E7%BA%BF.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/2-1-%E5%88%97%E8%A1%A8.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h3 id="待办事项"><a href="#待办事项" class="headerlink" title="待办事项"></a>待办事项</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/1-2%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/1-3%E8%A1%A8%E6%A0%BC.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h3 id="代码高亮："><a href="#代码高亮：" class="headerlink" title="代码高亮："></a>代码高亮：</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/1-1%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h3 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://note.youdao.com/iyoudao/wp-content/uploads/2016/09/%E7%94%981.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="Markdown-使用技巧"><a href="#Markdown-使用技巧" class="headerlink" title="Markdown 使用技巧"></a>Markdown 使用技巧</h2><h3 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h3><p>可以在 HTML、Markdown 中使用下面的表情，微软自带的输入法可以输入这些表情：</p><p>📦 🚀 🐠 ✂️ 🔥 🚨 ✏️ 🛠 💅 👌 ✨ 💯 ⚛️ 📄</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/18-1-11/163002.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>有道云支持 Markdown 目录，使用 <code>[TOC]</code></p><h3 id="控制图片大小和位置"><a href="#控制图片大小和位置" class="headerlink" title="控制图片大小和位置"></a>控制图片大小和位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">  &lt;img width&#x3D;&quot;65&quot; height&#x3D;&quot;75&quot; src&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="图文混排"><a href="#图文混排" class="headerlink" title="图文混排"></a>图文混排</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;img align&#x3D;&quot;right&quot; src&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">这是一个示例图片。</span><br><span class="line"></span><br><span class="line">图片显示在 N 段文字的右边。</span><br><span class="line"></span><br><span class="line">N 与图片高度有关。</span><br><span class="line"></span><br><span class="line">刷屏行。</span><br><span class="line"></span><br><span class="line">刷屏行。</span><br><span class="line"></span><br><span class="line">到这里应该不会受影响了，本行应该延伸到了图片的正下方，所以我要足够长才能确保不同的屏幕下都看到效果。</span><br></pre></td></tr></table></figure><h3 id="在表格单元格里换行"><a href="#在表格单元格里换行" class="headerlink" title="在表格单元格里换行"></a>在表格单元格里换行</h3><p>借助于 HTML 里的 <code>&lt;br /&gt;</code> 实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| Header1 | Header2                          |</span><br><span class="line">|---------|----------------------------------|</span><br><span class="line">| item 1  | 1. one&lt;br &#x2F;&gt;2. two&lt;br &#x2F;&gt;3. three |</span><br></pre></td></tr></table></figure><h3 id="老子今天不加班-mp3"><a href="#老子今天不加班-mp3" class="headerlink" title="老子今天不加班.mp3"></a>老子今天不加班.mp3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio controls&#x3D;&quot;controls&quot; autoplay&#x3D;&quot;true&quot; src&#x3D;&quot;https:&#x2F;&#x2F;oijmns1ch.qnssl.com&#x2F;antiwork_today.mp3&quot;&gt;&lt;&#x2F;audio&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Markdown-简介&quot;&gt;&lt;a href=&quot;#Markdown-简介&quot; class=&quot;headerlink&quot; title=&quot;Markdown 简介&quot;&gt;&lt;/a&gt;Markdown 简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Markdown 中文官网：&lt;a href=&quot;http://www.markdown.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.markdown.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;【简明版】有道云笔记Markdown指南：&lt;a href=&quot;http://note.youdao.com/iyoudao/?p=2411&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://note.youdao.com/iyoudao/?p=2411&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;【进阶版】有道云笔记Markdown指南：&lt;a href=&quot;http://note.youdao.com/iyoudao/?p=2445&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://note.youdao.com/iyoudao/?p=2445&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Markdown 是一种简单、易读易写的「标记语言」，用来写博客、做笔记非常方便，通常为程序员群体所用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Skills" scheme="https://bxm0927.github.io/categories/Skills/"/>
    
    
      <category term="Markdown" scheme="https://bxm0927.github.io/tags/Markdown/"/>
    
      <category term="有道云笔记" scheme="https://bxm0927.github.io/tags/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>可能是最详细的 Hexo + GitHub Pages 搭建个人博客的教程</title>
    <link href="https://bxm0927.github.io/2018/06/24/hexo-github-blog/"/>
    <id>https://bxm0927.github.io/2018/06/24/hexo-github-blog/</id>
    <published>2018-06-24T14:00:37.000Z</published>
    <updated>2020-09-09T12:45:15.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>个人博客地址：<a href="http://www.lovebxm.com" target="_blank" rel="noopener">www.lovebxm.com</a><br>如果您在搭建的过程中遇到无法解决的问题，可与我交流探讨，QQ：80583600</p></blockquote><p>我们为什么要写博客？一方面写博客可以用来监督自己，阶段性总结归纳所学的知识点，进而达到学以致用的目的；另一方面在于分享精神，在分享与交流的过程中，你的语言表达能力会逐渐变得简洁清晰，而且带有很强的逻辑性。</p><a id="more"></a><p>所以说，写博客是一个好习惯，希望大家能够坚持下来。最近刚好有空，就把自己个人博客搭建的全过程记录下来，希望能够帮助到一些朋友。当然了，搭建个人博客的方式有很多，比如自己写前后端、WordPress、Jekyll等等，这里我是用的是免费开源、简洁高效的“Hexo + GitHub Pages”来搭建。</p><p>大概流程如下：</p><ol><li>搭建 Node.js 环境</li><li>搭建 Git 环境</li><li>GitHub 注册和配置</li><li>Hexo 安装</li><li>Hexo 配置</li><li>关联 Hexo 与 GitHub</li><li>将 GitHub Pages 地址解析到个人域名</li><li>Hexo 常规操作</li><li>结束语</li></ol><p><img src="http://img.imooc.com/568b80410001975704500260.jpg" alt="image"></p><h2 id="搭建-Node-js-环境"><a href="#搭建-Node-js-环境" class="headerlink" title="搭建 Node.js 环境"></a>搭建 Node.js 环境</h2><blockquote><p>为什么要搭建 Node.js 环境？ —- 因为 Hexo 博客系统是基于 Node.js 编写的，要运行在 Node.js 环境之上。</p></blockquote><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。</p><p>Node.js 的包管理器 npm（node package manager），是全球最大的开源库生态系统，安装 Node.js 时会自动安装 npm。我们之后要通过 npm 来安装 Hexo。</p><p>在 Node.js 官网：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 下载最新稳定版，安装时保持默认设置即可，一路Next，安装很快就结束了。</p><p>最后，打开命令提示符，输入 <code>node -v</code>、<code>npm -v</code>，出现版本号则说明 Node.js 环境配置成功，第一步完成！！！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/17-5-28/25738843.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="搭建-Git-环境"><a href="#搭建-Git-环境" class="headerlink" title="搭建 Git 环境"></a>搭建 Git 环境</h2><blockquote><p>为什么要搭建 Git 环境？ —- 因为需要把本地的网页和文章等资源提交到远程Git仓库（GitHub）上。</p></blockquote><p>Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p><p>在 Git 官网：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a> 下载安装包，安装过程如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/17-5-28/62582265.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>桌面右键，打开 <code>Git Bush Here</code>，输入 <code>git --version</code>，出现版本号则说明 Git 环境配置成功，第二步完成！！！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/17-5-28/13485948.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="GitHub-注册和配置"><a href="#GitHub-注册和配置" class="headerlink" title="GitHub 注册和配置"></a>GitHub 注册和配置</h2><p>GitHub 是什么？GitHub 又名 GayHub，全球最大的同性交友网站。</p><p>（哈哈哈，开个玩笑 <code>^_^</code>）实际上，GitHub 是一个代码托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。我们的博客最终是托管在 GitHub 上的。</p><p>Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 提供的域名 github.io 或者自定义域名来发布站点。</p><p>首先，我们需要在 Github 官网进行注册：<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.mukewang.com/57eea87a0001c62213450582.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>然后，创建仓库：Repository name 使用自己的用户名，每个用户只能建立一个，仓库名规则（注意：yourname 必须是你的用户名）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yourname&#x2F;yourname.github.io</span><br></pre></td></tr></table></figure><p>比如我的仓库是这样创建的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/17-5-28/42622869.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>最后，访问 <a href="https://yourname.github.io，比如我的是" target="_blank" rel="noopener">https://yourname.github.io，比如我的是</a> <a href="https://bxm0927.github.io，如果可以正常访问，那么" target="_blank" rel="noopener">https://bxm0927.github.io，如果可以正常访问，那么</a> Github 的配置已经结束了，第三步完成！！！</p><p>至此，搭建 Hexo 个人博客的前置环境配置已经完成，下面开始讲解 Hexo 搭建个人博客的核心操作。</p><h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><p>什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架，默认使用 Markdown 解析文章，在几秒内，即可利用靓丽的主题生成静态网页，只需一条指令即可部署到 GitHub Pages 或其他网站。</p><p>强烈建议读者花20分钟去读一读 Hexo 的官方文档：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/17-5-28/49821520.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>使用 npm 安装 Hexo（在这之前，请确保你已经成功安装了Node.js和Git）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>然后你将会看到下图所示信息，可能你会看到一个<code>WARN</code>，但是不用担心，这不会影响你的正常使用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/17-5-28/41219383.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>查看Hexo的版本，<code>hexo version</code>，正确输出如下信息则代表 Hexo 安装成功。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/17-5-29/81453389.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Hexo-配置"><a href="#Hexo-配置" class="headerlink" title="Hexo 配置"></a>Hexo 配置</h2><p>安装 Hexo 完成后，执行下列命令来初始化 Hexo，用户名改成你自己的（我的是bxm0927），Hexo 将会在指定文件夹中新建博客系统所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo init bxm0927.github.io</span><br><span class="line"></span><br><span class="line">cd bxm0927.github.io</span><br><span class="line"></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，目录如下（不同的版本可能目录有些不一样）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .deploy         <span class="comment"># 需要部署的文件</span></span><br><span class="line">├── node_modules    <span class="comment"># Hexo依赖</span></span><br><span class="line">├── public          <span class="comment"># 生成的静态网页文件</span></span><br><span class="line">├── scaffolds       <span class="comment"># 模板，当您新建文章时，Hexo 会根据 scaffold 来建立文件。</span></span><br><span class="line">├── <span class="built_in">source</span>          <span class="comment"># 博客正文和其他源文件，404、favicon、CNAME 都应该放在这里</span></span><br><span class="line">| ├── _drafts       <span class="comment">#   草稿</span></span><br><span class="line">| └── _posts        <span class="comment">#   文章</span></span><br><span class="line">├── themes          <span class="comment"># 主题，Hexo 会根据主题来生成各种各样的静态页面。</span></span><br><span class="line">├── _config.yml     <span class="comment"># 全局配置文件，您可以在此配置大部分的参数。</span></span><br><span class="line">└── package.json    <span class="comment"># npm 依赖配置文件</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/18-6-24/88056415.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>然后，在本地运行 Hexo：<code>hexo server</code>或<code>hexo s</code></p><p>您的网站会在 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 下启动，如果能够正常访问（如下图），则说明 Hexo 博客系统已经搭建起来了，但是目前只是在本地哦，别人是看不到的。</p><p>在下面步骤中，我们要把这个本地博客系统部署到 Github 上，让外网的人能够访问到你的博客。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/17-5-28/34921926.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>常见问题：执行hexo server提示找不到该指令<br>解决办法：在 Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：npm install hexo -server –save</p></blockquote><h2 id="关联-Hexo-与-GitHub"><a href="#关联-Hexo-与-GitHub" class="headerlink" title="关联 Hexo 与 GitHub"></a>关联 Hexo 与 GitHub</h2><blockquote><p>这一步对于不熟悉GitHub的朋友来说可能有些繁琐，慢慢来，不要着急~</p></blockquote><h3 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h3><ol><li>生成 SSH</li></ol><p>首先，使用SSH让本地Git项目与远程的GitHub建立起连接，方便传输文件。执行下面命令生成SSH公私钥，一路回车（记得输入你自己的邮箱地址哦~）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;80583600@qq.com&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加 SSH Key 到 GitHub</li></ol><p>用记事本打开 <code>C:\Users\bxm09\.ssh\id_rsa.pub</code>，此文件里面内容为刚才生成的公公钥，准确的复制这个文件的内容，粘贴到 <a href="https://github.com/settings/ssh" target="_blank" rel="noopener">https://github.com/settings/ssh</a> 的“new SSH key”中</p><ol start="3"><li>测试</li></ol><p>输入下面的命令，看看SSH是否配置成功，<code>git@github.com</code>的部分不要修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果是下面的反馈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes&#x2F;no)?</span><br></pre></td></tr></table></figure><p>不要紧张，输入yes就好，然后会看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi aierui! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><h3 id="配置-Git-个人信息"><a href="#配置-Git-个人信息" class="headerlink" title="配置 Git 个人信息"></a>配置 Git 个人信息</h3><p>现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。<br>Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理。</p><p>输入下面的代码进行个人信息的设置（把名称和邮箱替换成你自己的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;bxm0927&quot;</span><br><span class="line">git config --global user.email &quot;80583600@qq.com&quot;</span><br></pre></td></tr></table></figure><h3 id="配置-Deployment"><a href="#配置-Deployment" class="headerlink" title="配置 Deployment"></a>配置 Deployment</h3><p>在<code>_config.yml</code>文件中，找到<code>Deployment</code>，然后按照如下修改：</p><blockquote><p>注意：1. 用户名改成你自己的，2. 冒号后面记得空一格</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:bxm0927&#x2F;bxm0927.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h3 id="将本地文件提交到-GitHub-Pages"><a href="#将本地文件提交到-GitHub-Pages" class="headerlink" title="将本地文件提交到 GitHub Pages"></a>将本地文件提交到 GitHub Pages</h3><blockquote><p>来了来了来了~</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地预览</span></span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除旧的静态文件，即 public 文件</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成新的静态文件，即 public 文件（或者 hexo g）</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到远程站点，即 GitHub（或者 hexo d）</span></span><br><span class="line">hexo deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然你也可以执行下面的组合命令</span></span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>在浏览器中输入 <a href="https://bxm0927.github.io">https://bxm0927.github.io</a> （用户名改成你自己的），可以正常访问则说明 Hexo 与 GitHub 已经成功关联了，哇哇哇哇哇哇，开心死你了，不要忘了回来给我点赞哟 ~</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li>若上面操作失败，则需要提前安装一个扩展：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol start="2"><li>如果在执行 <code>hexo d</code> 后,出现 <code>error deployer not found:github</code> 的错误（如下），则是因为没有设置好 public key 所致，重新详细设置即可。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Permission denied (publickey).</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><ol start="3"><li>怎么避免 Markdown 文件（.md）被解析？</li></ol><p>Hexo 原理就是在执行<code>hexo generate</code>时会在本地先把博客生成的一套静态html页面，然后放到public文件夹中，再执行<code>hexo deploy</code>时将其复制到.deploy文件夹中。</p><p>Github 通常建议同时附上README.md项目说明文档，但是 hexo 默认情况下会把所有 Markdown 文件（.md）文件解析成html文件，所以即使你在线生成了 README. md，它也会在你下一次部署时被删去。</p><p>那么怎么解决呢？</p><p>在执行<code>hexo deploy</code>前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行<code>hexo deploy</code>。</p><h2 id="将-GitHub-Pages-地址解析到个人域名"><a href="#将-GitHub-Pages-地址解析到个人域名" class="headerlink" title="将 GitHub Pages 地址解析到个人域名"></a>将 GitHub Pages 地址解析到个人域名</h2><blockquote><p>其实当上一步结束之后，我们的博客也基本上完成了，能发博文，别人也能够通过外网域名访问到你的站点，但是~</p></blockquote><p>看着博客的域名是GitHub的二级域名，总有一种寄人篱下的感觉，为了让这个小窝看起来更加正式，我们可以花几十块钱去买一个自己的域名，然后将其绑定自己的域名上，进行该绑定过程，其实就是一个重定向的过程。这里我使用的是阿里云的万网域名服务：</p><p>在 GitHub 仓库的根目录下建立一个 <code>CNAME</code> 的文本文件(注意：没有扩展名)，文件里面只能输入一个你的域名，不能加<code>http://</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.xxx.com</span><br></pre></td></tr></table></figure><p>注意到时候CNAME一定是在你Github项目的master根目录下，你也可以建立一个CNAME的文本文件，放到Hexo–&gt;public目录下，因为到时候同步上去的是这个public文件夹。</p><p>进入<a href="https://dc.aliyun.com/tcparse/dns.htm" target="_blank" rel="noopener">阿里云域名解析地</a>址，添加解析：</p><ol><li>记录类型选择<code>CNAME</code></li><li>主机记录填<code>www</code></li><li>解析线路选择<code>默认</code></li><li>记录值填<code>yourname.github.io</code></li><li>TTL值为<code>10</code>分钟</li><li>再添加一个解析，记录类型<code>A</code></li><li>主机记录填<code>www</code></li><li>解析线路选择<code>默认</code></li><li>记录值填你GitHub 的ip地址（在cmd中ping：）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping bxm0927.github.com</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/17-5-29/79989003.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>点击保存，等 1 分钟，访问下你自己的域名，一切就ok了。</p><p>域名绑定成功，域名解析成功，因此你在浏览中输入 <a href="http://www.lovebxm.com，或" target="_blank" rel="noopener">www.lovebxm.com，或</a> lovebxm.com 就可以访问到博客了，输入 bxm0927.github.io 会重定向到  <a href="http://www.lovebxm.com。过程：www">www.lovebxm.com。过程：www</a> 的方式，会先解析成 <a href="http://xxxx.github.io，然后根据" target="_blank" rel="noopener">http://xxxx.github.io，然后根据</a> CNAME 再变成 www</p><p><strong>注意</strong>：CNAME文件在下次 <code>hexo deploy</code>的时候就消失了，需要重新创建，这样就很繁琐</p><p>方法一：每次 <code>hexo d</code> 之后，就去 GitHub 仓库根目录新建 CNAME文件</p><p>方法二：在 <code>hexo g</code> 之后， <code>hexo d</code> 之前，把CNAME文件复制到 “\public&quot; 目录下面，里面写入你要绑定的域名。</p><p>方法三（推荐）：将需要上传至github的内容放在source文件夹，例如CNAME、favicon.ico、images等，这样在 hexo d 之后就不会被删除了。</p><p>方法四：通过安装插件实现永久保留</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-cname --save</span><br></pre></td></tr></table></figure><p>之后在_config.yml中添加一条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugins:</span><br><span class="line">- hexo-generator-cname</span><br></pre></td></tr></table></figure><p>需要注意的是：如果是在github上建立的CNAME文件，需要先clone到本地，然后安装插件，在deploy上去即可。CNAME只允许一个域名地址。</p><p><strong>注意1</strong>：每次生成的 CNAME 都是 yoursite.com 怎么解决？</p><p>修改 _config.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url: http:&#x2F;&#x2F;www.lovebxm.com</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><h2 id="Hexo-常规操作"><a href="#Hexo-常规操作" class="headerlink" title="Hexo 常规操作"></a>Hexo 常规操作</h2><h3 id="发表一篇文章"><a href="#发表一篇文章" class="headerlink" title="发表一篇文章"></a>发表一篇文章</h3><p>运行下面的命令创建一个新文章文件，然后，会在本地博客文件夹 <code>source\_posts</code> 文件夹下我们可以看到新建的 markdown 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文章标题&quot;</span><br></pre></td></tr></table></figure><p>文章编辑好之后，可以执行本地预览、部署等命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地预览</span></span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除旧的静态文件，即 public 文件</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成新的静态文件，即 public 文件（或者 hexo g）</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到远程站点，即 GitHub（或者 hexo d）</span></span><br><span class="line">hexo deploye</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然你也可以执行下面的组合命令</span></span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><h3 id="显示部分文章内容"><a href="#显示部分文章内容" class="headerlink" title="显示部分文章内容"></a>显示部分文章内容</h3><p>如果在博客文章列表中不想全文显示，可以在文章中增加 <code>&lt;!-- more --&gt;</code>, 在这后面的内容就不会显示在列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure><h3 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h3><ul><li>官方主题库：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></li><li>有哪些好看的 Hexo 主题？：<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">https://www.zhihu.com/question/24422335</a></li></ul><p>Hexo主题非常丰富，hexo3.0使用的默认主题是landscape，我推荐搭建使用 Next 为主题，好看且文档详细。详情请阅读 Next 的官方文档（ <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a> ），5 分钟快速安装。</p><blockquote><p>再提示一点，大家可以修改一步就<code>hexo s</code>在本地看下效果。</p></blockquote><h3 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h3><p>添加 feed 插件和 sitemap 网站地图，有助于 SEO。</p><p>切换到你本地的 hexo 目录 ，输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed -save</span><br><span class="line">npm install hexo-generator-sitemap -save</span><br></pre></td></tr></table></figure><p>修改 <code>_config.yml</code>，增加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">Plugins:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">#sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br></pre></td></tr></table></figure><p>再执行以下命令，部署到远端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>配完之后，就可以访问 <a href="https://bxm0927.github.io/atom.xml">https://bxm0927.github.io/atom.xml</a> 和 <a href="https://bxm0927.github.io/sitemap.xml">https://bxm0927.github.io/sitemap.xml</a> ，发现这两个文件已经成功生成了。</p><h3 id="添加404-页面"><a href="#添加404-页面" class="headerlink" title="添加404 页面"></a>添加404 页面</h3><p>GitHub Pages 自定义404页面非常容易，直接在根目录下创建自己的<code>404.html</code>就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用<code>hexo s</code>在本机调试也是不起作用的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oph264zoo.bkt.clouddn.com/17-5-29/38118493.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其实，404页面可以做更多有意义的事，来做个404公益项目吧。</p><p>推荐使用腾讯公益404 <a href="http://www.qq.com/404/" target="_blank" rel="noopener">http://www.qq.com/404/</a> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;404&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;br&gt;&lt;!--</span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;公益404 | 不如&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">#404 Not found By Bruce</span><br><span class="line">&lt;h1&gt;404 Page Not Found&lt;&#x2F;h1&gt;</span><br><span class="line">--&gt;&lt;br&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.qq.com&#x2F;404&#x2F;search_children.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;&lt;br&gt;&lt;!--</span><br><span class="line">公益404介接入地址</span><br><span class="line">益云公益404 http:&#x2F;&#x2F;yibo.iyiyun.com&#x2F;Index&#x2F;web404</span><br><span class="line">腾讯公益404 http:&#x2F;&#x2F;www.qq.com&#x2F;404</span><br><span class="line">失蹤兒童少年資料管理中心404 http:&#x2F;&#x2F;404page.missingkids.org.tw</span><br><span class="line">--&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>复制上面代码，贴粘到目录下新建的404.html即可！</p><p>我的404页面配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8;&quot;&#x2F;&gt;</span><br><span class="line">  &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge,chrome&#x3D;1&quot; &#x2F;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;all&quot; &#x2F;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;index,follow&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;www.qq.com&#x2F;404&#x2F;search_children.js&quot;</span><br><span class="line">        charset&#x3D;&quot;utf-8&quot; homePageUrl&#x3D;&quot;gdutxiaoxu.github.io&quot;</span><br><span class="line">        homePageName&#x3D;&quot;回到我的主页&quot;&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="多PC同步管理博客"><a href="#多PC同步管理博客" class="headerlink" title="多PC同步管理博客"></a>多PC同步管理博客</h3><p>很多人可能家里一台笔记本，公司一个台式机，想两个同时管理博客，同时达到备份的博客主题、文章、配置的目的。下面就介绍一下用github来备份博客并同步博客。</p><ol><li>A电脑备份博客内容到github</li></ol><p>配置.gitignore文件。进入博客目录文件夹下，找到此文件，用sublime text 打开，在最后增加两行内容/.deploy_git和/public</p><ol start="2"><li>初始化仓库。</li></ol><p>在博客根目录下，在git bash下依次执行git init和git remote add origin <server> <server>为远程仓库地址。</p><ol start="3"><li>同步到远程仓库。</li></ol><p>gitbash下依次执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add . #添加目录下所有文件</span><br><span class="line"></span><br><span class="line">git commit -m &quot;更新说明&quot; #提交并添加更新说明</span><br><span class="line"></span><br><span class="line">git push -u origin master #推送更新到远程仓库</span><br></pre></td></tr></table></figure><ol start="4"><li>B电脑拉下远程仓库文件</li></ol><p>在B电脑上同样先安装好node、git、ssh、hexo，然后建好hexo文件夹，安装好插件，（然后选做：将备份到远程仓库的文件及文件夹删除），然后执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line"></span><br><span class="line">git remote add origin &lt;server&gt;</span><br><span class="line"></span><br><span class="line">git fetch --all</span><br><span class="line"></span><br><span class="line">git reset --hard origin&#x2F;master</span><br></pre></td></tr></table></figure><ol start="5"><li>发布博客后同步</li></ol><p>在B电脑发布完博客之后，记得将博客备份同步到远程仓库<br>执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">#可以用git master 查看更改内容</span><br><span class="line"></span><br><span class="line">git commit -m &quot;更新信息&quot;</span><br><span class="line"></span><br><span class="line">git push -u origin master  #以后每次提交可以直接git push</span><br></pre></td></tr></table></figure><p>平时同步管理<br>每次想写博客时，先执行：git pull进行同步更新。发布完文章后同样按照上面的 发布博客后同步 同步到远程仓库。</p><h3 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h3><p>在 md 文件中写中文内容，发布出来后为乱码，原因是 md 的编码不对，将 md 文件另存为<code>UTF-8</code>编码的文件即可解决问题。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>建站的系统有很多，如：</p><ul><li><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo + GitHub Pages</a></li><li><a href="http://jekyll.com.cn/" target="_blank" rel="noopener">Jekyll + GitHub Pages</a></li><li><a href="https://cn.wordpress.org/" target="_blank" rel="noopener">WordPress + 服务器 + 域名</a></li><li><a href="http://www.dedecms.com/" target="_blank" rel="noopener">DeDeCMS + 服务器 + 域名</a></li><li>…</li></ul><p>使用 Hexo + GitHub Pages 建站，有优点也有缺点：</p><ul><li>GitHub Pages 不支持数据库管理，所以你只能做静态页面的博客，不能像其他博客（如 WordPress）那样通过数据库管理自己的博客内容。</li><li>但是，GitHub Pages 无需购置服务器，免服务器费的同时还能做负载均衡，github pages有300M免费空间。</li><li>个人博客真的有必要用数据库吗？答案是否定的。博客静态化，评论记录使用第三方的 <a href="https://gentie.163.com/info.html" target="_blank" rel="noopener">网易云跟帖</a> 就可以了。静态的博客更有利于搜索引擎蜘蛛爬取，轻量化的感觉真的很好。</li><li>通过 Hexo 你可以轻松地使用 Markdown 编写文章，非常符合我的口味。Markdown 真的是专门针对程序员开发的语言啊，现在感觉没有 Markdown 什么都不想写。什么富文本编辑器，什么word，太麻烦了！而且样式都好丑！效率太低！</li></ul><p>推荐几个很好用的在线 Markdown 编辑器：</p><ul><li>作业部落：<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">https://www.zybuluo.com/mdeditor</a></li><li>马克飞象：<a href="https://maxiang.io" target="_blank" rel="noopener">https://maxiang.io</a></li></ul><p>推荐一个图床：<a href="https://jiantuku.com/#/" target="_blank" rel="noopener">极简图床 + chrome 插件 + 七牛空间</a>，七牛云储存提供10G的免费空间,以及每月10G的流量，存放个人博客外链图片最好不过了，七牛云储存还有各种图形处理功能、缩略图、视频存放速度也给力（非打广告）。</p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;个人博客地址：&lt;a href=&quot;http://www.lovebxm.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.lovebxm.com&lt;/a&gt;&lt;br&gt;如果您在搭建的过程中遇到无法解决的问题，可与我交流探讨，QQ：80583600&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们为什么要写博客？一方面写博客可以用来监督自己，阶段性总结归纳所学的知识点，进而达到学以致用的目的；另一方面在于分享精神，在分享与交流的过程中，你的语言表达能力会逐渐变得简洁清晰，而且带有很强的逻辑性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Skills" scheme="https://bxm0927.github.io/categories/Skills/"/>
    
    
      <category term="hexo" scheme="https://bxm0927.github.io/tags/hexo/"/>
    
      <category term="github" scheme="https://bxm0927.github.io/tags/github/"/>
    
      <category term="blog" scheme="https://bxm0927.github.io/tags/blog/"/>
    
      <category term="搭建个人博客" scheme="https://bxm0927.github.io/tags/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>blog-hexo</title>
    <link href="https://bxm0927.github.io/2013/07/13/blog/"/>
    <id>https://bxm0927.github.io/2013/07/13/blog/</id>
    <published>2013-07-13T12:46:25.000Z</published>
    <updated>2019-06-28T08:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><a id="more"></a><h2 id="✂️-Build-Setup"><a href="#✂️-Build-Setup" class="headerlink" title="✂️ Build Setup"></a>✂️ Build Setup</h2><p>前置条件：</p><ul><li>Node.js (Should be at least nodejs 6.9)</li><li>Git</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install Hexo</span></span><br><span class="line">$ npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line"><span class="comment">#  Create a new Hexo folder.</span></span><br><span class="line">$ hexo init &lt;blog-name&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;blog-name&gt;</span><br><span class="line">$ npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start the server.</span></span><br><span class="line">$ hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate static files.</span></span><br><span class="line">$ hexo generate <span class="comment"># hexo g</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deploy your website.</span></span><br><span class="line">$ hexo deploy <span class="comment"># hexo d</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># One-click deployment</span></span><br><span class="line">$ hexo generate --deploy <span class="comment"># hexo g -d</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/9823cde9gy1g4gy3sgql2j20k20armyb.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="✏️Q-amp-A"><a href="#✏️Q-amp-A" class="headerlink" title="✏️Q&amp;A"></a>✏️Q&amp;A</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt; 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FE" scheme="https://bxm0927.github.io/categories/FE/"/>
    
      <category term="HTML" scheme="https://bxm0927.github.io/categories/FE/HTML/"/>
    
    
      <category term="HTML" scheme="https://bxm0927.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://bxm0927.github.io/tags/CSS/"/>
    
      <category term="JS" scheme="https://bxm0927.github.io/tags/JS/"/>
    
  </entry>
  
</feed>
