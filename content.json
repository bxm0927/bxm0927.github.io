[{"title":"Chrome DevTools 调试技巧","date":"2020-05-24T05:06:08.448Z","path":"2020/05/24/chrome-devtools/","text":"前言 https://developers.google.com/web/tools/chrome-devtools/ https://juejin.im/book/5c526902e51d4543805ef35e/section/5c5269026fb9a049f1549e4a 工欲善其事必先利其器。 有些时候一个技巧可以节省我们很多的时间，也会让调试的过程变得更加简单直接。本次分享从不同的情景来说明应该如何搭配使用 Chrome DevTools 中的小技巧，让大家熟练掌握 Chrome 调试技巧，直接提升工作效率。 关于 Chrome谷歌浏览器（通常简称为 Chrome ）是由谷歌开发的网络浏览器。 它于 2008 年首次针对 Microsoft Windows 发布，后来移植到 Linux ，macOS ，iOS 和 Android 。 浏览器也是 Chrome OS 的主要组件，它可以作为 Web 应用的平台。Chrome-wikipedia 现如今，浏览器的市场已天下三分，Chorme，Safari 和 FireFox，从 2008 年 Chrome 横空出世以来，如今已经一家独大占据了半壁江山： image 关于 Chrome DevTools对于大部分人来说，Chrome 可能只是个浏览器，但是对于开发人员来说，它更是一个强大无比的工具，为了方便开发人员调试代码，主流的浏览器都内置了 DevTools， 所以无论你是前端还是后端，掌握 Chrome DevTools 的使用技巧意味着效率直接的提高。 打开方式 F12 Ctrl + Shift + I (Windows) 或 Cmd + Opt + I (Mac) 更多工具 &gt; 开发者工具 在页面元素上右键点击，选择 “检查” 面板概览Chrome DevTools 包含 1 个设备模式和 8 个常见的面板，我们还可以通过插件来增加一些面板（如：Vue-DevTools） 0. 设备模式 Device Mode 使用设备模式构建完全响应式，移动优先的网络体验。 image 1. 元素面板 Elements 使用元素面板可以自由的操作 DOM 和 CSS 来迭代布局和设计页面。 image 2. 控制台面板 Console 在开发期间，可以使用控制台面板记录诊断信息，或者使用它作为 shell 在页面上与 JavaScript 交互。 image 3. 源代码面板 Sources 在源代码面板中设置断点来调试 JavaScript ，或者通过Workspaces（工作区）连接本地文件来使用开发者工具的实时编辑器。 image 4. 网络面板 Network 使用网络面板了解请求和下载的资源文件并优化网页加载性能。 image 5. 性能面板 Performance 使用性能面板可以通过记录和查看网站生命周期内发生的各种事件来提高页面的运行时性能。 image 6. 内存面板 Memory 如果需要比内存面板提供的更多信息，可以使用内存面板，例如跟踪内存泄漏。 image 7. 应用面板 Application 使用应用面板可以检查加载的所有资源，包括 IndexedDB 与 Web SQL 数据库，本地和会话存储，cookie，应用程序缓存，图像，字体和样式表。 image 8. 安全面板 Security 使用安全面板调试混合内容问题，证书问题等等。 image 实用快捷键Ctrl + shift + D：把 DevTools 窗口切换到右边、下边 Ctrl + shift + M：切换设备模式 Ctrl + [ 和 Ctrl + ]：切换面板 上下箭头：递增/递减，可配合 Alt、Ctrl、Shift 实现不同的步长（对调整样式特别有用） Ctrl + F：在 elements， logs， sources 和 network 中查找 使用 Command我们直接可以直接看到的 DevTools 的功能，其实只是有限的一部分，怎么去探索更多的功能呢？ Command 菜单可以帮助我们快速找到那些被隐藏起来的功能，你可以使用 Ctrl + Shift + P 或 DevTools 的 dropdown 按钮打开 Command。 Command 包含下列几类命令： image 常用的 Command： 截屏：capture 切换主题：theme copying你可以通过全局的方法 copy() 在 console 里复制任何你能拿到的资源 例如：copy(location) image saving如果你在 console 中打印了一堆数据（例如一个大型数组），然后你想对这些数据做一些额外的操作，那就可以将它转换成一个全局变量，只需要右击它，并选择 “Store as global variable” (保存为全局变量) 选项。第一次使用的话，它会创建一个名为 temp1 的变量，第二次创建 temp2，以此类推。 注意：得到的 temp$ 的是原数据的引用，操作会影响原数据。 image 保存堆栈信息( Stack trace )大多数情况下都不是一个人开发一个项目，而是一个团队协作，那么 如何准确的描述问题，就成为了沟通的关键 ，这时候 console 打印出来的堆栈跟踪的信息对你和同事来说就起大作用了，可以省去很多沟通成本，所以你可以直接把堆栈跟踪的信息保存为一个文件，而不只是截图发给对方： image Snippets 代码段 如果你需要频繁地在 console 中输入某个代码段，Snippets 功能可能会帮助你。 比如，我想统计网页标签使用数量，评价网页是否语义化，我会把这段脚本赋值 Console 面板： 1234567891011/** * 统计网页标签使用数量，评价网页是否语义化的重要指标 */function getTagsMap() &#123; return [...document.querySelectorAll('*')].reduce((a, c) =&gt; &#123; let tagName = c.tagName.toLowerCase() a[tagName] = a[tagName] ? a[tagName] + 1 : 1 return a &#125;, &#123;&#125;)&#125;getTagsMap() 现在看来，即使这个脚本并没有花费我太多的精力来编写，但也只是偶尔运行一下，所以对于我来说，记住一段这样的脚本会很麻烦。 那怎么解决这个问题呢？ 这就是 Snippets 的用武之地：它允许你存放 JavaScript 代码到 DevTools 中，方便你复用这些 JavaScript 代码段： 进入到 Sources 面板，在导航栏里选中 Snippets 这栏，点击 New snippet 新建一个代码段，然后输入你的代码之后保存就可以 Run 了！ 当我在 DevTools 中预设了一组很棒的代段块以后，甚至都不必再通过 Sources 来运行它们。使用 Command Menu 才是最快的方式。只需在它的输入框中输入 !，就可以根据名字来筛选预设代码段。 image Elements 篇H 隐藏元素 Delete 删除元素 Ctrl + C 复制元素 Ctrl + Z 撤销改动 拖动 &amp; 放置 元素 使用 Ctrl 移动元素 更多操作请在元素上点击右键 image console 篇多种多样的 consoleconsole.log 普通打印 console.table 表格打印（适用于数组、类数组、对象） console.dir 查看节点属性 console.assert 断言 console.time / console.timeEnd() 计时器 console 中的 ‘$’1. $0 在 Chrome 的 Elements 面板中， $0 是对我们当前选中的 html 节点的引用。 同理，$1 是对上一次我们选择的节点的引用，一直到 $4。 你可以尝试一些相关操作，例如: $1.appendChild($0) 2. $ 和 $$ console 面板中 $ 变量如果未曾被定义过就是 document.querySelector 的别名 $$ 相当于执行 document.QuerySelectorAll 并且它返回的是一个节点的数组。 1$$('div') === Array.from(document.querySelectorAll('div')) 3. $_ $_ 是对上次执行的结果的引用 image 4. $i 在 DevTools 中使用 npm 插件！ 有时你只是想尝试下新出的 npm 包，现在不用再大费周章去建一个项目测试了，只需要在 Chrome 扩展插件: Console Importer 的帮助之下，快速的在 console 中引入和测试一些 npm 库。 运行 $i(&#39;lodash&#39;) 或者 $i(&#39;moment&#39;) 后，你就可以获取到 lodash / momentjs 了: image 断点调试 breakpoints基本用法你还在用console.log 和 alert 吗？使用断点（breakpoint）可以非常方便地调试 JavaScript 代码。 在行号上单击就设置了一个断点，然后你就可以调试了。当然这也是最最基本的打断点的方式了，当然了，相较于调试全靠 console.log 和 alert 已经高端很多了。 同时也可以通过在行号上右键点击 Add breakpoint 来设置断点。设置断点的行号上会显示一个蓝色的矩形来告诉你这里有一个断点。 image 当断点触发时，整个页面会处于暂停状态，并会切换到 Source 页断点处方便调试，直到终止该断点调试后页面才会继续运行。 快捷键： F8 F9 F10 F11 条件断点比如说你写了一个循环，该循环会执行 100 次，但是你只对第 50 次循环的结果感兴趣，又或者你只对一些满足某些条件的结果感兴趣。于是，你一手托腮，另一只手放在 F8 键上，狂按数十下下后正襟危坐，开始调试。 显然，Chrome 已经帮我们想到了这种场景，我们可以通过添加一些条件断点来避免一些无意义的断点： 右击行号，选择 Add conditional breakpoint...(添加条件断点) 或者右击一个已经设置的断点并且选择 Edit breakpoint(编辑断点) 然后输入一个执行结果为 true 或者 false 的表达式（它的值其实不需要完全为 true 或者 false 尽管那个弹出框的描述是这样说的）。在这个表达式中你可以使用任何这段代码可以获取到的值（当前行的作用域）。如果条件成立，这个断点就会生效。 image DOM 元素断点断点不仅仅可以设置在 JS 代码上，还可以在 DOM 元素上设置断点。 我们可以设置三种 DOM 元素断点 subtree modifications 子节点内容的的改变（子节点的属性修改不会触发，当前节点的修改不会触发） attribute modifications 当前节点的属性改变 node removal 当前节点被移除 当我们的脚本触发了 DOM 的修改时，devtools 会直接跳转到 Source 页并定位到修改 DOM 的那行代码上。 image 你还一层层展开 DOM？Alt + Click，快速展开所有 DOM image Network - 重新发送 XHR 的请求如何重新发送 XHR 的请求？刷新页面？太老套了，试试这么做： image 恐龙小游戏(Chrome Dino)相信在座的各位对 Google Chrome 中的一个复活节彩蛋 —— 恐龙小游戏(Chrome Dino)不会感到陌生。在与互联网断开连接时，当用户尝试访问网站，并在按下空格键后即可开始这个游戏。 Chrome 中的恐龙小游戏是一个简单的无限跑步游戏，它会让用户跳过仙人掌，并闪避障碍物，游戏为用户提供基本控制，按空格键跳跃（并开始游戏），向下箭头(↓)俯身奔跑以躲避障碍物。目标是在互联网重新开始工作之前让用户打发时间。 其实用户也可以在不打开飞行模式的情况下玩 Chrome dino 游戏。只需在 Chrome 浏览器的地址栏中输入 chrome://dino，用户就可以进入“街机模式”，在那里用户可以在全窗口环境中畅玩这款游戏。 推荐一些好用的 Chrome 扩展启动页：掘金、Infinity新标签页、Momentum 翻译：Google 翻译、有道云翻译、百度翻译、有道词典Chrome划词插件 广告屏蔽：Adblock Plus OneTab Clipboard History 2 WEB前端助手(FeHelper) JSONView Stylish-为任意网站自定义主题 tampermonkey 油猴","tags":[]},{"title":"Promise 对象","date":"2020-05-24T05:06:08.448Z","path":"2020/05/24/promise/","text":"Promise 对象简介Promise 是异步编程的一种更优的解决方案，一定程度上解决了回调函数产生的“回调地狱”的问题。Promise 最早由社区提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 ==Promise 允许将回调函数的嵌套改成链式调用，即用同步的方式去写异步代码，使异步代码看起来像是线性结构。== Promise 对象的两个特点 对象的状态不受外界影响。 Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 注意，我们一般说的 resolved，是指 Promise 对象的状态从 pending 变为 fulfilled，即异步操作成功。 Promise 对象的缺点Promise 也有一些缺点： 首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。 其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。 第三，当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 Promise 对象基本用法ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。该构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 如果调用 resolve 函数和 reject 函数时带有参数，那么它们的参数会被传递给回调函数。 123456789const promise &#x3D; new Promise(function(resolve, reject) &#123; &#x2F;&#x2F; ... some code if (&#x2F;* 异步操作成功 *&#x2F;)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。then 方法可以接受两个回调函数作为参数。 第一个回调函数是 Promise 对象的状态变为 resolved 时调用， 第二个回调函数是 Promise 对象的状态变为 rejected 时调用。 其中，第二个函数是可选的，不一定要提供。 这两个函数都接受 Promise 对象传出的值作为参数。 12345678promise.then( function(value) &#123; &#x2F;&#x2F; success &#125;, function(error) &#123; &#x2F;&#x2F; failure &#125;,) 下面是一个 Promise 对象的简单例子。 12345678910&#x2F;&#x2F; 一段时候后进行打印function timeout(ms) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(resolve, ms, &#39;done&#39;) &#125;)&#125;timeout(3000).then(value &#x3D;&gt; &#123; console.log(value)&#125;) Promise.prototype.then() Promise 实例具有 then、catch、finally 方法，也就是说，then、catch、finally 方法是定义在原型对象 Promise.prototype 上的。 then 方法的作用是为 Promise 实例添加状态改变时的回调函数。 then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用（可选）。 then 方法返回的是一个新的 Promise 实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。 123456getJSON('/post/test.json') .then(post =&gt; getJSON(post.commentURL)) .then( comments =&gt; console.log('resolved: ', comments), err =&gt; console.log('rejected: ', err) ) Promise.prototype.catch()Promise.prototype.catch 方法是 .then(null, rejection) 或 .then(undefined, rejection) 的别名，用于指定发生错误时的回调函数。 12345678promise .then(val =&gt; console.log('fulfilled:', val)) .catch(err =&gt; console.log('rejected', err))// 等同于promise .then(val =&gt; console.log('fulfilled:', val)) .then(null, err =&gt; console.log('rejected:', err)) Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。 最佳实践：一般来说，不要在 then 方法里面定义 reject 状态的回调函数（即 then 的第二个参数），总是使用 catch 方法。一般总是建议，Promise 对象后面要跟 catch 方法，这样可以处理 Promise 内部发生的错误。 123456789101112131415161718// badpromise.then( function(data) &#123; // success &#125;, function(err) &#123; // error &#125;,)// goodpromise .then(function(data) &#123; // success &#125;) .catch(function(err) &#123; // error &#125;) Promise.prototype.finally()finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 我们一般在 finally 方法中关闭服务和资源。 finally 方法的回调函数不接受任何参数，这意味着没有办法知道前面的 Promise 状态到底是 fulfilled 还是 rejected。这表明，finally 方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 1234promise .then(result =&gt; &#123;&#125;) .catch(error =&gt; &#123;&#125;) .finally(() =&gt; &#123;&#125;) finally 本质上是 then 方法的特例。如果不使用 finally 方法，同样的语句需要为成功和失败两种情况各写一次。有了 finally 方法，则只需要写一次。 123456789101112131415161718192021222324252627promise .finally(() &#x3D;&gt; &#123; &#x2F;&#x2F; 都会执行的操作 &#125;)&#x2F;&#x2F; 等同于promise.then( result &#x3D;&gt; &#123; &#x2F;&#x2F; 都会执行的操作 return result &#125;, error &#x3D;&gt; &#123; &#x2F;&#x2F; 都会执行的操作 throw error &#125;,)&#x2F;&#x2F; 等同于promise .then(result &#x3D;&gt; &#123; &#x2F;&#x2F; 都会执行的操作 return result &#125;) .catch(error &#x3D;&gt; &#123; &#x2F;&#x2F; 都会执行的操作 throw error &#125;) Promise.prototype.finally() 底层实现： 1234567Promise.prototype.finally &#x3D; function(callback) &#123; let P &#x3D; this.constructor return this.then( value &#x3D;&gt; P.resolve(callback()).then(() &#x3D;&gt; value), reason &#x3D;&gt; P.resolve(callback()).then(() &#x3D;&gt; throw reason), )&#125; Promise.all()Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例（并发请求）。 1const p = Promise.all([p1, p2, p3]); Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 实例。p 的状态由 p1、p2、p3 决定，分成两种情况。 只有p1、p2、p3的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。 只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。 123456789101112131415161718192021222324function someAsyncThing(value) &#123; return new Promise((resolve, reject) =&gt; &#123; // 这里假如是一个异步操作 value &gt; 10 ? resolve(value) : reject(value) &#125;)&#125;Promise.all([someAsyncThing(11), someAsyncThing(12)]) .then(res =&gt; &#123; console.log('sussess ' + res) &#125;) .catch(err =&gt; &#123; console.log('error ' + err) &#125;)// sussess [11,12]Promise.all([someAsyncThing(11), someAsyncThing(10)]) .then(res =&gt; &#123; console.log('sussess ' + res) &#125;) .catch(err =&gt; &#123; console.log('error ' + err) &#125;)// error 10 Promise.race() race：赛跑 Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.race([p1, p2, p3]); 上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。 Promise.resolve()Promise.resolve 方法用于将现有对象转为 Promise 对象。 Promise.race 方法的参数与 Promise.all 方法一样，如果不是 Promise 实例，就会先调用 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。 12&#x2F;&#x2F; 将 jQuery 生成的 deferred 对象，转为一个新的 Promise 对象const jsPromise &#x3D; Promise.resolve($.ajax(&#39;&#x2F;whatever.json&#39;)); 123Promise.resolve(&#39;foo&#39;)&#x2F;&#x2F; 等价于new Promise(resolve &#x3D;&gt; resolve(&#39;foo&#39;)) Promise.reject()Promise.reject(reason) 方法也会返回一个新的 Promise 实例，该实例的状态为 rejected。 Promise.try()让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API。 12345const f &#x3D; () &#x3D;&gt; console.log(&#39;now&#39;);Promise.try(f);console.log(&#39;next&#39;);&#x2F;&#x2F; now&#x2F;&#x2F; next Promise 库Bluebird：http://bluebirdjs.com/docs/api/promise.try.html Q：https://github.com/kriskowal/q when：https://github.com/cujojs/when 注意事项 Promise 新建后就会立即执行 1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise') resolve()&#125;)promise.then(function() &#123; console.log('resolved.')&#125;)console.log('Hi!')// Promise// Hi!// resolved 1234567891011121314151617setTimeout(function() &#123; console.log(1)&#125;, 0)new Promise(function executor(resolve) &#123; console.log(2) for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve() &#125; console.log(3)&#125;).then(function() &#123; console.log(4)&#125;)console.log(5)// 2 3 5 4 1 调用 resolve 或 reject 并不会终结 Promise 的参数函数的执行。 12345678new Promise((resolve, reject) =&gt; &#123; resolve(1) console.log(2)&#125;).then(r =&gt; &#123; console.log(r)&#125;)// 2// 1 一般来说，调用 resolve 或 reject 以后，Promise 的使命就完成了，后继操作应该放到 then 方法里面，而不应该直接写在 resolve 或 reject 的后面。所以，最好在它们前面加上 return 语句，这样就不会有意外。 12345new Promise((resolve, reject) &#x3D;&gt; &#123; return resolve(1) &#x2F;&#x2F; 后面的语句不会执行 console.log(2)&#125;) Promise 的 resolve 函数的参数是另一个 Promise 实例。即一个 Promise p1 的结果是返回另一个 Promise p2，那么 p1 的状态由 p2 决定。 12345678910111213const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; reject(new Error('fail')), 3000)&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2 .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error))// 表现：3s 后打印 \"Error: fail\" Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。 12345678910111213141516const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2) &#125;)&#125;someAsyncThing().then(function() &#123; console.log('everything is great')&#125;)setTimeout(() =&gt; &#123; console.log(123)&#125;, 2000)// Uncaught (in promise) ReferenceError: x is not defined// 123 如果 Promise 状态已经变成 resolved，再抛出错误是无效的，即不会被捕获。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。 12345678const promise = new Promise(function(resolve, reject) &#123; resolve('ok') throw new Error('test')&#125;)promise .then(value =&gt; console.log(value)) .catch(error =&gt; console.log(error))// ok","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bxm0927.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://bxm0927.github.io/tags/ES6/"}]},{"title":"聊聊布局","date":"2019-02-25T14:57:15.000Z","path":"2019/02/25/layout/","text":"image 布局方法过时的布局方法 表格布局（table） 传统的布局方法 定位（position） 浮动（float） 前沿的布局方法 弹性盒子布局（Flexible Box Layout） 网格布局（Grid Layout） 经验之谈布局可以从以下几个方面思考： 利用 float + margin 实现 利用 absolute 绝对定位实现 利用 BFC 实现 利用 Flexbox 实现 利用 Grid 实现 几个注意点： 移动端能用 Flex 就用 Flex，灵活方便并且功能强大，无愧为网页布局的一大利器！ 使用 float 时，注意要清除浮动，避免高度塌陷 避免使用老旧的 table 布局（如 display: table;、display: table-row;、display: table-cell;）。表格布局会使 margin 失效，设置间隔比较麻烦。 居中布局水平居中行内元素水平居中： 123456// 利用 text-align: center 可以将块级元素内部的行内元素水平居中。// 此方法对 inline、inline-block、inline-table 和 inline-flex 元素水平居中都有效。// 也可以将 block 元素设置成 inline-block，再用这种方式实现块级元素的水平居中.inline-x-center &#123; text-align: center;&#125; 单个块级元素水平居中： 1234567// 可通过将左和右外边距设置为 auto 来实现块级元素水平居中。// 此时需要设置宽度，如果宽度是 100%，则对齐没有效果。@mixin margin-auto-center($width: 80%) &#123; width: $width; margin-left: auto; margin-right: auto;&#125; 多个块级元素水平居中： 注意多个 inline-block 元素间空白字符 font-size 不为 0 的问题 12345678.parent &#123; text-align: center; /* font-size: 0; */&#125;.child &#123; display: inline-block;&#125; 垂直居中行内元素垂直居中： 1234.inline-y-center &#123; height: 40px; line-height: 40px;&#125; 垂直对齐一幅图像、字体图标： 1234// vertical-align 属性设置元素的垂直对齐方式，默认情况下，元素放置在父元素的基线(baseline)上。.img-y-center &#123; vertical-align: middle;&#125; 水平垂直居中 总结：一般情况下，水平垂直居中，我们最常用的就是绝对定位加负边距，缺点就是需要知道宽高，使用 transform 倒是可以不需要知道宽高，但是兼容性不好（IE9+） 高度宽度已知： 12345678910// Negative margin@mixin margin-center($width, $height) &#123; position: absolute; top: 50%; left: 50%; width: $width; height: $height; margin-left: -($width / 2); margin-top: -($height / 2);&#125; 高度宽度未知： 123456789// Transform centering// Horizontally and vertically centers a child element within a parent element using `position: absolute` and `transform: translate()`.// Similar to `flexbox`, this method does not require you to know the height or width of your parent or child so it is ideal for responsive applications..transform-center &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 1234567// Flexbox centering// Horizontally and vertically centers a child element within a parent element using `flexbox`..flexbox-center &#123; display: flex; // enables flexbox. align-items: center; // centers the child vertically. justify-content: center; // centers the child horizontally.&#125; 1234567// Grid centering// Horizontally and vertically centers a child element within a parent element using `grid`..grid-center &#123; display: grid; // enables grid. align-items: center; // centers the child vertically. justify-content: center; // centers the child horizontally.&#125; 两列布局 image 左列定宽，右列自适应 利用 float + margin 实现： 12345678.left &#123; float: left; width: 100px;&#125;.right &#123; margin-left: 120px; /* 大于等于 `.left` 的宽度 */&#125; 利用 BFC 实现： BFC（Block fomatting context）：块级元素格式化上下文，它决定了其子元素将如何定位，以及和其他元素的相互关系。 BFC 在页面上是一个独立的容器，与其他元素互不影响 12345678.left &#123; float: left; width: 100px;&#125;.right &#123; overflow: hidden; /* 触发 BFC 达到自适应 */&#125; 利用 absolute 绝对定位实现： 1234567891011121314151617.parent &#123; position: relative;&#125;.left &#123; position: absolute; top: 0; left: 0; width: 100px;&#125;.right &#123; position: absolute; top: 0; left: 100px; /* 大于等于 `.left` 的宽度 */ right: 0;&#125; 利用 Flexbox 实现： 123456789101112.parent &#123; display: flex;&#125;.left &#123; width: 100px; flex: 0 0 100px;&#125;.right &#123; flex: 1; /* 均分了父元素剩余空间 */&#125; 利用 Grid 实现： 12345.parent &#123; display: grid; grid-template-columns: 100px auto; /* 设定 2 列就 ok 了, auto 换成 1fr 也行 */ width: 100%;&#125; 左列自适应，右列定宽 利用 float + margin 实现： 123456789101112131415.parent &#123; height: 500px; padding-left: 100px; /* 抵消 left 的 margin-left 以达到 parent 水平居中 */&#125;.left &#123; float: left; margin-left: -100px; /* 正值等于 right 的宽度 */ width: 100%;&#125;.right &#123; float: right; width: 100px;&#125; 利用 BFC 实现： 123456789101112131415&lt;style&gt; .left &#123; overflow: hidden; /* 触发 BFC 达到自适应 */ &#125; .right &#123; float: right; margin-left: 10px; /* margin 需要定义在 right 上 */ width: 100px; &#125;&lt;/style&gt;&lt;!-- right 先渲染 --&gt;&lt;div id=\"right\"&gt;右列定宽&lt;/div&gt;&lt;div id=\"left\"&gt;左列自适应&lt;/div&gt; 利用 absolute 绝对定位实现： 1234567891011121314151617.parent &#123; position: relative;&#125;.left &#123; position: absolute; top: 0; left: 0; right: 100px; /* 大于等于 `.right` 的宽度 */&#125;.right &#123; position: absolute; top: 0; right: 0; width: 100px;&#125; 利用 Flexbox 实现： 123456789101112.parent &#123; display: flex;&#125;.left &#123; flex: 1; /* 均分了父元素剩余空间 */&#125;.right &#123; width: 100px; flex: 0 0 100px;&#125; 利用 Grid 实现： 12345.parent &#123; display: grid; grid-template-columns: auto 100px; /* 设定 2 列就 ok 了, auto 换成 1fr 也行 */ width: 100%;&#125; 一列不定，一列自适应 盒子宽度随着内容增加或减少发生变化，另一个盒子自适应 这里演示左列不定宽，右列自适应。左列自适应，右列不定宽同理。 利用 BFC 实现： 12345678.left &#123; float: left; /* 只设置浮动，不设宽度 */ margin-right: 10px;&#125;.right &#123; overflow: hidden; /* 触发 BFC */&#125; 利用 Flexbox 实现： 123456789101112.parent &#123; display: flex;&#125;.left &#123; /* 不设宽度 */ margin-right: 10px;&#125;.right &#123; flex: 1; /* 均分 parent 剩余的部分 */&#125; 利用 Grid 实现： 12345678.parent &#123; display: grid; grid-template-columns: auto 1fr; /* auto 和 1fr 换一下顺序就是“左列自适应，右列不定宽”了 */&#125;.left &#123; margin-right: 10px;&#125; 三列布局两列定宽，一列自适应 利用 float + margin 实现： 123456789101112131415161718.parent &#123; min-width: 310px; /* 100 + 10 + 200，防止宽度不够，子元素换行*/&#125;.left &#123; float: left; margin-right: 10px; /* left 和 center 间隔 */ width: 100px;&#125;.center &#123; float: left; width: 200px;&#125;.right &#123; margin-left: 320px; /* 等于 left 和 center 的宽度之和加上间隔，多出来的就是 right 和 center 的间隔 */&#125; 利用 BFC 实现： 12345678910111213141516171819.parent &#123; min-width: 320px; /* 防止宽度不够，子元素换行 */&#125;.left &#123; float: left; margin-right: 10px; width: 100px;&#125;.center &#123; float: left; margin-right: 10px; /* 在此定义和 right 的间隔 */ width: 200px;&#125;.right &#123; overflow: hidden;&#125; 利用 Flexbox 实现： 1234567891011121314151617.parent &#123; display: flex;&#125;.left &#123; margin-right: 10px; width: 100px;&#125;.center &#123; margin-right: 10px; width: 200px;&#125;.right &#123; flex: 1;&#125; 利用 Grid 实现： 1234.parent &#123; display: grid; grid-template-columns: 100px 200px auto; /* 设置3列，固定第一第二列的宽度，第三列 auto 或者 1fr */&#125; 左右定宽，中间自适应 image 利用 Flexbox 实现123456789101112131415.parent &#123; display: flex;&#125;.left &#123; width: 100px;&#125;.center &#123; flex: 1;&#125;.right &#123; width: 200px;&#125; 利用 absolute 绝对定位实现12345678910111213141516171819202122.parent &#123; position: relative;&#125;.left &#123; position: absolute; top: 0; left: 0; width: 100px;&#125;.center &#123; margin-left: 100px; /* 大于等于 left 的宽度，或者给 parent 添加同样大小的 padding-left */ margin-right: 200px; /* 大于等于 right 的宽度，或者给 parent 添加同样大小的 padding-right */&#125;.right &#123; position: absolute; top: 0; right: 0; width: 200px;&#125; 圣杯布局圣杯布局又叫做固比固布局，即两边固定宽度，中间自适应的三栏布局。 具体操作是三栏全部浮动，左右两栏负 margin 让其跟中间栏并排。 注意：中间栏要在放在文档流前面以优先渲染。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div class=\"grail\"&gt; &lt;!-- 中间盒子优先渲染 --&gt; &lt;div class=\"middle\"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Qui, ut.&lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .grail &#123; box-sizing: border-box; width: 100%; min-width: 1024px; height: 400px; /* 让中间自适应的盒子安全显示 */ padding: 0 300px; background-color: darkseagreen; &#125; .middle &#123; float: left; width: 100%; height: 300px; background-color: deepskyblue; &#125; .left &#123; float: left; position: relative; left: -300px; width: 300px; height: 300px; /* 左侧盒子上浮; */ margin-left: -100%; background-color: red; &#125; .right &#123; float: left; position: relative; right: -300px; width: 300px; height: 300px; /* 右侧盒子上浮 */ margin-left: -300px; background-color: red; &#125;&lt;/style&gt; 双飞翼布局事实上，圣杯布局和双飞翼布局是一回事，它们实现的都是三栏布局，但是双飞翼布局可以更好地解决中栏内容超出的情景。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div class=\"grail\"&gt; &lt;div class=\"middle-wrapper\"&gt; &lt;div class=\"middle\"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Qui, ut.&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .grail &#123; width: 100%; min-width: 1024px; height: 400px; background-color: darkseagreen; &#125; .middle-wrapper &#123; float: left; width: 100%; height: 300px; background-color: deepskyblue; &#125; .middle &#123; height: 300px; margin-left: 300px; margin-right: 300px; background-color: yellowgreen; &#125; .left &#123; float: left; width: 300px; height: 300px; margin-left: -100%; background-color: red; &#125; .right &#123; float: left; width: 300px; height: 300px; margin-left: -300px; background-color: red; &#125;&lt;/style&gt; 多列布局等宽布局 浮动等宽布局： 1234.column &#123; float: left; width: 25%; /* 100 ÷ 列数，得出百分比 */&#125; 弹性盒子等宽布局： 1234567.parent &#123; display: flex;&#125;.column &#123; flex: 1;&#125; 网格等宽布局： 1234.parent &#123; display: grid; grid-template-columns: repeat(6, 1fr); /* 6 就是列数 */&#125; 九宫格布局 image DOM结构： 1234567891011121314151617&lt;div class=\"parent\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"item\"&gt;1&lt;/div&gt; &lt;div class=\"item\"&gt;2&lt;/div&gt; &lt;div class=\"item\"&gt;3&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"item\"&gt;4&lt;/div&gt; &lt;div class=\"item\"&gt;5&lt;/div&gt; &lt;div class=\"item\"&gt;6&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"item\"&gt;7&lt;/div&gt; &lt;div class=\"item\"&gt;8&lt;/div&gt; &lt;div class=\"item\"&gt;9&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 使用 table 表格布局实现： display:table 相当于 table 标签 display:table-row 相当于 tr 标签 display:table-cell 相当于 td 标签 123456789.parent &#123; display: table;&#125;.row &#123; display: table-row;&#125;.item &#123; display: table-cell;&#125; 使用 Flex 弹性盒子布局实现： 1234567891011.parent &#123; display: flex; flex-direction: column;&#125;.row &#123; display: flex; flex: 1;&#125;.item &#123; flex: 1;&#125; 使用 Grid 网格布局实现： 12345.parent &#123; display: grid; grid-template-columns: repeat(3, 1fr); /* 等同于 1fr 1fr 1fr，此为重复的合并写法 */ grid-template-rows: repeat(3, 1fr); /* 等同于 1fr 1fr 1fr，此为重复的合并写法 */&#125; 栅格系统12345678910111213141516171819202122232425262728293031323334@media screen and (max-width: 768px) &#123; .column-xs-1 &#123; width: 8.33333333%; &#125; .column-xs-2 &#123; width: 16.66666667%; &#125; .column-xs-3 &#123; width: 25%; &#125; .column-xs-4 &#123; width: 33.33333333%; &#125; .column-xs-5 &#123; width: 41.66666667%; &#125; .column-xs-6 &#123; width: 50%; &#125; .column-xs-7 &#123; width: 58.33333333%; &#125; .column-xs-8 &#123; width: 66.66666667%; &#125; .column-xs-9 &#123; width: 75%; &#125; .column-xs-10 &#123; width: 83.33333333%; &#125; .column-xs-11 &#123; width: 91.66666667%; &#125; .column-xs-12 &#123; width: 100%; &#125;&#125;@media screen and (min-width: 768px) &#123; .column-sm-1 &#123; width: 8.33333333%; &#125; .column-sm-2 &#123; width: 16.66666667%; &#125; .column-sm-3 &#123; width: 25%; &#125; .column-sm-4 &#123; width: 33.33333333%; &#125; .column-sm-5 &#123; width: 41.66666667%; &#125; .column-sm-6 &#123; width: 50%; &#125; .column-sm-7 &#123; width: 58.33333333%; &#125; .column-sm-8 &#123; width: 66.66666667%; &#125; .column-sm-9 &#123; width: 75%; &#125; .column-sm-10 &#123; width: 83.33333333%; &#125; .column-sm-11 &#123; width: 91.66666667%; &#125; .column-sm-12 &#123; width: 100%; &#125;&#125;div[class^=\"column-xs-\"]&#123; float: left;&#125;div[class^=\"column-sm-\"]&#123; float: left;&#125; 滚动场景横向滚动：overflow-x: auto; 纵向滚动：overflow-y: auto; 横向、纵向滚动：overflow: auto; 更复杂的滚动场景可以借助第三方库实现，如 better-scroll","tags":[{"name":"HTML","slug":"HTML","permalink":"https://bxm0927.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://bxm0927.github.io/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://bxm0927.github.io/tags/JavaScript/"},{"name":"Layout","slug":"Layout","permalink":"https://bxm0927.github.io/tags/Layout/"}]},{"title":"Java 文件 I/O 流详细解读","date":"2018-07-11T13:31:05.000Z","path":"2018/07/11/Java-io/","text":"I/O 概述利用 Java 的 I/O（input/output，输入和输出）技术可以将数据保存到文本文件、二进制文件甚至是压缩包之中，以达到永久性保存数据的要求。I/O 通常使用“流”的方式进行数据传输，一个流必须有源和目的地，他们通常是磁盘文件，但也可以是键盘、鼠标、显示器、内存甚至是网络等设备。 Java 语言定义了许多类专门负责各种形式的输入和输出，这些类被放在java.io包中，他们根据数据形态可分为：流式部分和非流式部分。 Java I/O 机制提供了一套简单的标准化 API，以方便从不同的数据源读取和写入字符数据或字节数据。 非流式部分File 类文件自身操作类，是 java.io 包中唯一一个与文件本身有关的操作类。File 类用于处理文件和文件系统，如创建、删除、重命名文件等操作，以路径名的形式代表一个文件。 File 类的构造方法： 123File(String filePath) &#x2F;&#x2F; 创建指定文件路径的 File 对象File(String filePath, String fileName) &#x2F;&#x2F; 创建指定文件路径和指定文件名的 File 对象File(File dirObj, String fileName) 123File f1 &#x3D; new File(&quot;&#x2F;&quot;);File f2 &#x3D; new File(&quot;&#x2F;&quot;, &quot;a.txt&quot;);File f3 &#x3D; new File(f1, &quot;a.txt&quot;); 注意： File 类不支持文件内容的读写操作。 路径（filePath）分为相对路径和绝对路径，相对路径是相对于项目根目录而言的。 File 类常用方法 文件路径分隔符：/、\\\\或File.separator 方法 描述 length() 文件的长度（字节 Byte） getName() 返回文件名 getParent() 返回父目录名 exists() 判断文件（或目录）是否存在 canRead() 判断文件是否可读 canWrite() 判断文件是否可写 isFile() 是否是一个文件 delete() 删除文件 getPath() 返回相对路径 getAbsolutePath() 返回绝对路径 getCanonicalPath() 返回路径名的规范格式？？ isDirectory() 是否是目录 isAbsolute() 是否是绝对路径名 isHidden() 是否是隐藏文件 lastModified() 最后修改时间 list()、list(filter) 返回当前目录下的文件和目录的列表（String[]） listFiles() 返回直接子目录(文件)的抽象 createNewFile() 创建文件 mkdir() 创建单级目录 mkdirs() 创建多级目录 renameTo() 重命名 12345678910111213141516171819202122232425File f1 &#x3D; new File(&quot;e:&quot; + File.separator + &quot;test.txt&quot;);if (f1.exists()) &#123; f1.delete(); System.out.println(&quot;文件删除成功&quot;);&#125; else &#123; try &#123; f1.createNewFile(); System.out.println(&quot;文件创建成功&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;System.out.println(f1.getName()); &#x2F;&#x2F; test.txtSystem.out.println(f1.getPath()); &#x2F;&#x2F; e:\\test.txtSystem.out.println(f1.getAbsolutePath()); &#x2F;&#x2F; e:\\test.txtSystem.out.println(f1.getParent()); &#x2F;&#x2F; e:\\System.out.println(f1.canRead()); &#x2F;&#x2F; trueSystem.out.println(f1.canWrite()); &#x2F;&#x2F; trueSystem.out.println(f1.isDirectory()); &#x2F;&#x2F; falseSystem.out.println(f1.isFile()); &#x2F;&#x2F; trueSystem.out.println(f1.isAbsolute()); &#x2F;&#x2F; trueSystem.out.println(f1.lastModified()); &#x2F;&#x2F; 1519556856932System.out.println(f1.length() + &quot;Byte&quot;); &#x2F;&#x2F; 0Byte RandomAccessFile 类文件随机访问类，即可以跳转到文件的任意位置处进行读写操作。RandomAccessFile 对象有一个位置指示器，指向当前读写处的位置。该类仅限于操作文件，不能访问其他 IO 设备，如网络、内存映象等等。 RandomAccessFile 类的构造方法： 12RandomAccessFile(File file, String mode) &#x2F;&#x2F; 创建一个随机访问文件流，文件属性由 File 参数指定RandomAccessFile(String name, String mode) &#x2F;&#x2F; 创建一个随机访问文件流，文件名由 name 参数指定 mode 决定了随机访问文件流的操作模式： value meaning r read，以只读方式打开，调用该对象的任何写方法都会导致 IOException 异常 rw read-write，以读、写方式打开，若文件不存在，则创建之 rws read-write-synchronized，以读、写方式打开，且文件内容同步更新 rwd 类似 rws RandomAccessFile 类常用方法 方法 描述 close() 关闭此随机访问文件流 length() 返回此文件的长度 read() 从这个文件读取一个字节的数据 write(byte[] b) 写 b.length 字节到文件中 getFilePointer() 返回此文件中的当前偏移量（位置指示器） seek(long pos) 设置文件指针偏移量（位置指示器） skipBytes(int n) 跳过指定字节 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.io.File;import java.io.RandomAccessFile;&#x2F;&#x2F; 向文件中写入三个员工的信息，并读出public class Test &#123; public static void main(String[] args) throws Exception &#123; Employee person1 &#x3D; new Employee(&quot;zhangsan&quot;, 18); Employee person2 &#x3D; new Employee(&quot;lisi&quot;, 20); File file &#x3D; new File(&quot;C:&#x2F;Users&#x2F;bxm09&#x2F;Desktop&#x2F;test.txt&quot;); if (file.exists()) &#123; file.delete(); &#125; RandomAccessFile f1 &#x3D; new RandomAccessFile(&quot;C:&#x2F;Users&#x2F;bxm09&#x2F;Desktop&#x2F;test.txt&quot;, &quot;rw&quot;); f1.write(person1.name.getBytes()); f1.writeInt(person1.age); f1.write(person2.name.getBytes()); f1.writeInt(person2.age); f1.close(); RandomAccessFile f2 &#x3D; new RandomAccessFile(&quot;C:&#x2F;Users&#x2F;bxm09&#x2F;Desktop&#x2F;test.txt&quot;, &quot;r&quot;); System.out.println(&quot;第 2 个员工的信息：&quot;); f2.skipBytes(12); &#x2F;&#x2F; 跳过指定字节 String p1Name &#x3D; &quot;&quot;; for (int i &#x3D; 0; i &lt; 8; i++) &#123; p1Name +&#x3D; (char) f2.readByte(); &#125; System.out.println(&quot;name：&quot; + p1Name); System.out.println(&quot;age：&quot; + f2.readInt()); System.out.println(&quot;第 1 个员工的信息：&quot;); f2.seek(0); &#x2F;&#x2F; 设置文件指针偏移量 String p2Name &#x3D; &quot;&quot;; for (int i &#x3D; 0; i &lt; 8; i++) &#123; p2Name +&#x3D; (char) f2.readByte(); &#125; System.out.println(&quot;name：&quot; + p2Name); System.out.println(&quot;age：&quot; + f2.readInt()); f2.close(); &#125;&#125;&#x2F;&#x2F; 员工类class Employee &#123; String name; &#x2F;&#x2F; 员工姓名 int age; &#x2F;&#x2F; 员工年龄 final static int LENGTH &#x3D; 8; &#x2F;&#x2F; 规定 name 为 8 个字符，方便读取。8 个字符 &#x3D; 8个汉字 &#x3D; 8个数字 &#x3D; 8个字母 public Employee(String name, int age) &#123; if (name.length() &gt; LENGTH) &#123; name &#x3D; name.substring(0, LENGTH); &#x2F;&#x2F; 超八位则截取 &#125; else &#123; while (name.length() &lt; LENGTH) &#123; name +&#x3D; &quot;\\u0000&quot;; &#x2F;&#x2F; 不足八位用空格代替 &#125; &#125; this.name &#x3D; name; this.age &#x3D; age; &#125;&#125; 流式部分在 Java 中，所有的 I/O 机制都是基于数据“流”方式完成的，而操作流的对象都封装到了 java.io 包中。 I/O 流的分类： 按操作数据的内容形态划分：字节流（InputStream、OutputStream）和字符流（Reader、Writer） 按流的功能流向划分：输入流（InputStream、Reader）和输出流（OutputStream、Writer） 1234public abstract class InputStream implements Closeable &#123; ... &#125;public abstract class OutputStream implements Closeable, Flushable &#123; ... &#125;public abstract class Reader implements Readable, Closeable &#123; ... &#125;public abstract class Writer implements Appendable, Closeable, Flushable &#123; ... &#125; 字节流类和字符流类的 API 大致相同 流属于资源，使用后要关闭之（记得擦屁股 - - !） 字符流字符流又叫做文本流，是用于操作字符数据的 I/O 流，==通常用来处理字符或字符串数据（汉字、多国语言等）==。 Reader 字符输入流 Writer 字符输出流 每个字节存放一个 ASCII 码，代表一个字符（而对于 Unicode 编码来说，每两个字节表示一个字符）。 1234567891011File file &#x3D; new File(&quot;C:&#x2F;Users&#x2F;bxm09&#x2F;Desktop&#x2F;test.txt&quot;);Writer out &#x3D; new FileWriter(file);out.write(&quot;hello world!&quot;);out.close();Reader in &#x3D; new FileReader(file);char[] accept &#x3D; new char[1024]; &#x2F;&#x2F; 此数组用于存放读取到的数据int len &#x3D; in.read(accept);System.out.println(new String(accept, 0, len)); &#x2F;&#x2F; 将字符数组转化为字符串in.close(); 字节流字节流又叫做二进制流，是用于操作字节数据的 I/O 流，==通常用来处理二进制数据（多媒体数据、网络传输数据等）==。 InputStream 字节输入流 OutputStream 字节输出流 字节流在输入输出时，与内存中的存储形式相同，以单个字节（Byte）为读写单位。用字节流来处理数据可以节省内存空间和转化时间，但一个字节并不代表一个字符，所以不能直接输出字符形式。 一般在操作文件流时，不管是字节流还是字符流，都可以按照如下的流程进行： 使用 File 类找到一个要操作的文件对象。 使用 File 类的对象去实例化字节流类或字符流类的子类 使用字节/字符的读写操作 关闭 IO 流资源 1234567891011121314File file = new File(\"C:/Users/bxm09/Desktop/test.txt\");// 写文件OutputStream out = new FileOutputStream(file);byte[] b = \"hello world!\".getBytes();out.write(b);out.close();// 读文件InputStream in = new FileInputStream(file);byte[] accept = new byte[1024]; // 此数组用于存放读取到的数据int len = in.read(accept);System.out.println(new String(accept, 0, len)); // 将字节数组转化为字符串in.close(); 文件流使用文件流可以将数据永久保存在文件中。 FileInputStream 字节文件输入流 FileOutputStream 字节文件输出流 FileReader 字符文件输入流 FileWriter 字符文件输出流 123456789101112131415161718192021222324252627&#x2F;&#x2F; 文件流初体验&#x2F;&#x2F; 使用 FileInputStream 向文件写入数据，然后使用 FileOutputStream 读取文件中的数据File file &#x3D; new File(&quot;hello.txt&quot;);&#x2F;&#x2F; 写文件try &#123; OutputStream out &#x3D; new FileOutputStream(file); out.write(&quot;HELLO WORLD&quot;.getBytes()); out.flush(); &#x2F;&#x2F; 记得擦屁股 out.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#x2F;&#x2F; 读文件try &#123; InputStream in &#x3D; new FileInputStream(file); byte[] data &#x3D; new byte[1024]; &#x2F;&#x2F; 用于存储读取到的数据 int len &#x3D; in.read(data); System.out.println(new String(data, 0, len)); in.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 缓冲流为了达到较高的转换效率，建议不要直接使用 InputStream、OutputStream 来进行读写，而应尽量使用缓冲流类来对数据进行缓存处理。 BufferedReader 字符缓冲输入流 BufferedWriter 字符缓冲输出流 InputStreamReader 字节缓冲输入流 OutputStreamWriter 字节缓冲输出流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#x2F;&#x2F; 缓冲流初体验，性能对比，复制一首歌曲public static void main(String[] args) throws IOException &#123; InputStream in &#x3D; new FileInputStream(&quot;爱我中华.mp3&quot;); &#x2F;&#x2F; 指定需要复制的文件路径 OutputStream out &#x3D; new FileOutputStream(&quot;爱我中华2.mp3&quot;); &#x2F;&#x2F; 指定文件复制后的输出路径 &#x2F;&#x2F; copyOfByte(in, out); &#x2F;&#x2F; 耗时18599毫秒 &#x2F;&#x2F; copyOfByteArray(in, out); &#x2F;&#x2F; 耗时40毫秒 copyOfBuffer(in, out); &#x2F;&#x2F; 耗时14毫秒&#125;&#x2F;&#x2F; 1. 使用字节读写private static void copyOfByte(InputStream in, OutputStream out) throws IOException &#123; long startTime &#x3D; System.currentTimeMillis(); int data &#x3D; 0; while (data !&#x3D; -1) &#123; data &#x3D; in.read(); &#x2F;&#x2F; read 方法返回 -1 表示要读的文件已经到了尽头 out.write(data); &#125; in.close(); out.flush(); out.close(); long endTime &#x3D; System.currentTimeMillis(); System.out.println(&quot;耗时&quot; + (endTime - startTime) + &quot;毫秒&quot;);&#125;&#x2F;&#x2F; 2. 使用字节数组读写private static void copyOfByteArray(InputStream in, OutputStream out) throws IOException &#123; long startTime &#x3D; System.currentTimeMillis(); byte[] bytes &#x3D; new byte[1024]; int data &#x3D; 0; while (data !&#x3D; -1) &#123; data &#x3D; in.read(bytes); out.write(bytes); &#125; in.close(); out.flush(); out.close(); long endTime &#x3D; System.currentTimeMillis(); System.out.println(&quot;耗时&quot; + (endTime - startTime) + &quot;毫秒&quot;);&#125;&#x2F;&#x2F; 3. 使用缓冲流来读写private static void copyOfBuffer(InputStream in, OutputStream out) throws IOException &#123; long startTime &#x3D; System.currentTimeMillis(); InputStream buffIn &#x3D; new BufferedInputStream(in); OutputStream buffOut &#x3D; new BufferedOutputStream(out); byte[] bytes &#x3D; new byte[1024]; int data; while ((data &#x3D; buffIn.read(bytes)) !&#x3D; -1) &#123; buffOut.write(bytes, 0, data); &#125; in.close(); out.flush(); out.close(); long endTime &#x3D; System.currentTimeMillis(); System.out.println(&quot;耗时&quot; + (endTime - startTime) + &quot;毫秒&quot;);&#125; 转换流字符流对字节流进行了包装，使其可以接受字符串的输入，字符流在输入时在其底层将字符转化为字节，读取时又将字节转化为字符。如果要将字节显示为字符，就需要用到字节与字符的转换。 InputStreamReader：字节输入流转为字符输入流 OutputStreamWriter：字节输出流转为字符输出流 12345&#x2F;&#x2F; 读取来自控制台的输入BufferedReader buffIn &#x3D; new BufferedReader(new InputStreamReader(System.in));BufferedWriter buffOut &#x3D; new BufferedWriter(new OutputStreamWriter(System.out));String readLine &#x3D; buffIn.readLine(); &#x2F;&#x2F; 读取键盘上输入的一整行字符 JDK 5 后的版本我们也可以使用 Java Scanner 类来获取控制台的输入。 管道流管道：将一个程序的输出当做另一个程序的输入。 管道流主要用于连接两个线程间的通讯。 管道流分为两组： 字节管道操作流：PipedInputStream、PipedOutputStream 字符管道操作流：PipedReader、PipedWriter 一个 PipedInputStream 对象必须和一个 PipedOutputStream 对象进行连接，才能产生一个通信管道。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.io.IOException;import java.io.PipedInputStream;import java.io.PipedOutputStream;&#x2F;&#x2F; 管道流public class Test &#123; public static void main(String[] args) throws Exception &#123; Sender sender &#x3D; new Sender(); Receiver receiver &#x3D; new Receiver(); PipedOutputStream out &#x3D; sender.getPipedOutputStream(); &#x2F;&#x2F; 返回各自的管道流 PipedInputStream in &#x3D; receiver.getPipedInputStream(); out.connect(in); &#x2F;&#x2F; 管道连接 new Thread(sender).start(); &#x2F;&#x2F; 启动线程 new Thread(receiver).start(); &#125;&#125;&#x2F;&#x2F; 消息发送方class Sender implements Runnable &#123; PipedOutputStream out &#x3D; new PipedOutputStream(); public PipedOutputStream getPipedOutputStream() &#123; return out; &#125; @Override public void run() &#123; String str &#x3D; &quot;hello world!&quot;; try &#123; out.write(str.getBytes()); out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;&#x2F;&#x2F; 消息接受方class Receiver implements Runnable &#123; PipedInputStream in &#x3D; new PipedInputStream(); public PipedInputStream getPipedInputStream() &#123; return in; &#125; @Override public void run() &#123; byte[] accept &#x3D; new byte[1024]; try &#123; int len &#x3D; in.read(accept); System.out.println(&quot;Receiver：&quot; + new String(accept, 0, len)); in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 打印流打印流是一个输出信息最方便的流类，==如果由程序向一个终端输出数据时，一定要使用打印流==。 打印流特点： 不抛出 IO 异常 自动刷新 打印流分为两组： 字节打印流：PrintStream 字符打印流：PrintWriter PrintStream 类提供了一系列重载的 print 和 println 方法，用来将基本数据类型的格式转换为字符串进行输出，对于一个非基本数据类型的对象，print 和 println 方法会默认调用对象的 toString 方法。 PrintStream 继承了 OutputStream类，并且实现了方法 write()，但是 write() 方法不经常使用，因为 print() 和 println() 方法用起来更为方便。 打印流使用的是“装饰设计模式”，即：将一个不是很完善的功能，添加一些代码后将其完善起来。 System.out.prinln 语句中的 System.out 就是 PrintStream 类的一个实例化对象。 12345678910&#x2F;&#x2F; 向屏幕输出信息PrintWriter out &#x3D; new PrintWriter(System.out);out.println(&quot;hello&quot;);out.close();&#x2F;&#x2F; 向文件输出信息File f &#x3D; new File(&quot;C:&#x2F;Users&#x2F;bxm09&#x2F;Desktop&#x2F;test.txt&quot;);PrintWriter out &#x3D; new PrintWriter(new FileWriter(f));out.println(&quot;hello&quot;);out.close(); 打印流的格式化输出类似C语言的 printf 函数，即用一些占位标记来暂时代替输出。 占位标记 含义 %s 字符串 %S 字符串（大写形式） %c 字符 %d 整数（十进制） %o 整数（八进制） %x 整数（十六进制） %X 整数（十六进制大写形式） %f 小数 %.nf 小数（限制小数位数） %e 科学计数法 %E 科学计数法（大写形式） %n 换行 %b 布尔值 1System.out.printf(&quot;字符串：%s，小数：%.2f&quot;, &quot;hello&quot;, 20.123); &#x2F;&#x2F; 字符串：hello，小数：20.12 内存操作流在内存中读写数据，而不是在文件中。此时，内存作为源和目的地。 内存操作流分为两组： 字节内存操作流：ByteArrayInputStream、ByteArrayOutputStream 字符内存操作流：CharArrayReade、CharArrayWriter 合并流（序列流）SequenceInputStream 类可以将多个输入流按顺序连接起来，也可以实现多个文件的合并操作。 1234567891011121314151617181920&#x2F;&#x2F; 两个文件的合并为一个文件File f1 &#x3D; new File(&quot;e:&#x2F;1.txt&quot;);File f2 &#x3D; new File(&quot;e:&#x2F;2.txt&quot;);File f3 &#x3D; new File(&quot;e:&#x2F;3.txt&quot;);FileInputStream in1 &#x3D; new FileInputStream(f1); &#x2F;&#x2F; 文件输入流FileInputStream in2 &#x3D; new FileInputStream(f2); &#x2F;&#x2F; 文件输入流SequenceInputStream s &#x3D; new SequenceInputStream(in1, in2); &#x2F;&#x2F; 将两个输入流合并为一个输入流FileOutputStream out &#x3D; new FileOutputStream(f3); &#x2F;&#x2F; 文件输出流int len;while ((len &#x3D; s.read()) !&#x3D; -1) &#123; out.write(len);&#125;in1.close();in2.close();out.close(); 对象流（对象序列化）对象序列化是指将内存中保存的对象转化为二进制数据流的形式的一种操作。通过对象序列化，可以方便的地实现对象的存储和读取。 对象反序列化就是使用 ObjectInputStream 类将序列化的对象读取出来。 在 Java 中，并不是所有类的对象都可以被序列化，会报NotSerializableException异常，只有实现了 java.io.Serializable 接口的类的对象可以被序列化，Serializable 接口中没有任何成员，是一个标识接口。 有两个类用于对象序列化操作： 对象输入流：ObjectInputStream 对象输出流：ObjectOutputStream transient 关键字阻止对象序列化 在默认情况下，当一个类的对象序列化时，会将这个类的所有属性都保存下来，如果不希望类中的某个属性被序列化，就需要加上 transient 关键字。 1234567891011121314151617181920212223242526272829303132333435363738394041public class Test &#123; public static void main(String[] args) throws Exception &#123; File file &#x3D; new File(&quot;.&#x2F;test&quot;); serializ(file); deserializ(file); &#125; &#x2F;&#x2F; 对象序列化：存储 private static void serializ(File file) throws Exception &#123; OutputStream out &#x3D; new FileOutputStream(file); ObjectOutputStream cout &#x3D; new ObjectOutputStream(out); cout.writeObject(new Person(&quot;白小明&quot;)); &#x2F;&#x2F; 写对象 cout.close(); &#125; &#x2F;&#x2F; 对象反序列化：读取 private static void deserializ(File file) throws Exception &#123; InputStream in &#x3D; new FileInputStream(file); ObjectInputStream cin &#x3D; new ObjectInputStream(in); Person p &#x3D; (Person) cin.readObject(); &#x2F;&#x2F; 读对象 System.out.println(p.getName()); &#x2F;&#x2F; null cin.close(); &#125;&#125;@SuppressWarnings(&quot;serial&quot;)class Person implements Serializable &#123; private transient String name; &#x2F;&#x2F; 该属性不想被序列化 public Person(String name) &#123; this.name &#x3D; name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://bxm0927.github.io/tags/Java/"},{"name":"IO","slug":"IO","permalink":"https://bxm0927.github.io/tags/IO/"}]},{"title":"Java 类集框架详细解读","date":"2018-07-11T05:48:05.000Z","path":"2018/07/11/Java-Collection/","text":"类集框架概述类集框架又叫做集合框架或集合类，是 Java 提供的一套性能优良、使用方便的接口和类，位于java.util包中。类集框架本质上是对基本的数据结构（线性表、树等）和算法（查找、排序等）的封装。 由于基本数据类型不能保存一系列的数据，对其进行扩展便形成了数组；又由于数组长度不可更改，缺乏灵活性，对数组进一步扩展便形成了功能更强大的“类集框架”。数组和类集框架都是一种“容器”，不同的是： 数组的长度时固定的，集合类的长度时可变的； 数组用来存放基本数据类型，集合类用来存储对象的引用，不能存储基本数据类型，存储的基本数据类型会进行自动类型转换。 12345678910// 集合类初体验public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); System.out.println(list.size()); // 2 System.out.println(list); // [1, 2] list.forEach(item -&gt; System.out.print(item + \" \")); // 1 2&#125; 类集框架体系结构类集框架最上层定义了两个接口，Collection 和 Map，Collection 叫做集合接口，每次只保存一个对象；Map 叫做映射接口，每次保存一对对象： 12public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; ... &#125;public interface Map&lt;K,V&gt; &#123; ... &#125; 在类集框架的类中，有一些是上层接口，有一些是抽象类（如：AbstractCollection、AbstractList、AbstractSet、AbstractMap等），提供了接口的部分实现，还有一些是具体实现类，这些类可以直接拿来使用。 123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; ... &#125;public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; ... &#125;public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; ... &#125; CollectionCollection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素。Collection 接口很少在开发中直接去使用，且没有直接实现它的标准类，通常都会用它的子接口 List 和 Set。 Collection 接口中定义的常用抽象方法： 方法 描述 int size() 类集中元素的个数 boolean add(Object obj) 将 obj 添加到类集中 boolean addAll(Collection c) 将 c 中的所有元素添加到类集中 boolean remove(Object obj) 从类集中删除 obj boolean removeAll(Collection c) 从类集中删除 c 中的所有元素 boolean retainAll(Collection c) 从类集中删除除了包含在 c 中的所有的元素 void clear() 清空类集中的元素 boolean contains(Object obj) obj 是否属于该类集 boolean containsAll(Collection c) c 中所有元素是否都属于该类集 boolean isEmpty() 类集是否为空 Object[] toArray() 将类集中的元素以数组的形式返回 Object[] toArray(Object array[]) 将类集中指定类型的元素以数组的形式返回 Iterator iterator() 调用类集的迭代器 ListList 接口是实现了 Collection 接口的子接口，是数据结构中的线性表的体现，List 接口下还有一些实现它的标准类：ArrayList、LinkedList，其中： ArrayList 是顺序表的体现 LinkedList 是链表的体现 123public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; ... &#125;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; ... &#125;public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; ... &#125; List 集合的特点是： List 集合中的元素允许重复 List 集合中存储的元素在逻辑上是有序的，因此能够通过索引来访问 List 中的元素，能够精确的控制每个元素插入的位置 List 接口对 Collection 接口进行了扩充，增加了一些方法： 方法 描述 Object set(int index, Object obj) 对列表中指定索引处的对象进行赋值 Object get(int index) 查找列表中指定索引处的对象（根据索引找对象） int indexOf(Object obj) 查找列表中 obj 第一次出现的索引，没有则返回 -1（根据对象找索引） int lastIndexOf(Object obj) 查找列表中 obj 最后一次出现的索引，没有则返回 -1（根据对象找索引） void add(int index, Object obj) 将 obj 插入到列表的 index 索引处（列表动态扩容） boolean addAll(int index, Collection c) 将 c 中的所有元素插入到列表的 index 索引处 Object remove(int index) 删除列表中指定索引处的对象（列表动态压缩） List subList(int start, int end) 返回一个子列表 ListIterator listIterator() 调用列表开始的迭代器 ListIterator listIterator(int index) 调用列表指定索引处开始的迭代器 ArrayList 可以这么说，Java 中最常用的两个类就是 String 和 ArrayList 了 ArrayList 是 List 接口的实现类，是数据结构中顺序表的体现，相当于一个动态数组（长度可变的数组）。ArrayList 的底层是Object[]，String 底层是 char[] 数组。 除了上层 List 给予的特性外，ArrayList 集合类还具有以下的特性： 允许有 null 元素 不同步，非线程安全 访问快（查找、遍历），时间复杂度是O(1)；更新慢（插入、删除），时间复杂度为O(n)。当 ArrayLIst 里有大量数据时，这时候去频繁插入或删除元素，会触发底层数组频繁拷贝，效率很低，还会造成内存空间的浪费。 ArrayList 类的构造方法： 123ArrayList(); &#x2F;&#x2F; 初始容量为 10ArrayList(int initialCapacity); &#x2F;&#x2F; 指定初始容量为 initialCapacity 大小ArrayList(Collection c); &#x2F;&#x2F; 由 c 中的元素初始化 注意：虽然初始化数组的长度是10，但是size是0，size是实际长度，并不是数组的容量 LinkedListLinkedList 是 List 接口的实现类，是数据结构中链表（双向循环链表）的体现。链表在物理存储上通常是非连续的，数据元素的逻辑顺序通过链表中的指针引用来实现。 除了上层 List 给予的特性外，LinkedList 集合类还具有以下的特性： 允许有 null 元素 不同步，非线程安全 访问慢（查找、遍历），更新快（插入、删除），因为插入和删除时不会触发底层数组的复制 LinkedList 类的构造方法： 12LinkedList(); &#x2F;&#x2F; 初始容量为 10LinkedList(Collection c); &#x2F;&#x2F; 由 c 中的元素初始化 12345678910111213141516&#x2F;&#x2F; LinkedList 初体验LinkedList&lt;Integer&gt; linkedList &#x3D; new LinkedList&lt;Integer&gt;();System.out.println(linkedList); &#x2F;&#x2F; []linkedList.addFirst(1); &#x2F;&#x2F; 这里会自动装箱 int -&gt; IntegerlinkedList.addFirst(2);linkedList.addLast(3);linkedList.addLast(4);System.out.println(linkedList); &#x2F;&#x2F; [2, 1, 3, 4]linkedList.removeFirst();linkedList.removeLast();System.out.println(linkedList); &#x2F;&#x2F; [1, 3]linkedList.set(1, 9527);System.out.println(linkedList.get(1)); &#x2F;&#x2F; 9527 SetSet 接口也是 Collection 接口的子接口，它并没有对 Collection 接口进行了扩充，而是完整的继承了 Collection 接口。Set 接口下也有一些实现它的标准类：HashSet、TreeSet、SortedSet。 123public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123; ... &#125;public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; ... &#125;public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable &#123; ... &#125; Set 集合的特点是： Set 集合中的元素不可重复 Set 集合中的元素是无序的的，因此不能通过索引来访问 Set 中的元素，但是删除和插入效率较高，因为插入和删除不会引起元素位置改变 HashSetHashSet 类使用哈希表实现了 Set 接口。 除了上层 Set 给予的特性外，HashSet 集合类还具有以下的特性： 允许有 null 元素，但最多只能一个 不同步，非线程安全 不保证元素的迭代顺序，同 HashMap 所谓无序，就是 Java 语言没有规定 HashSet 按什么顺序遍历。你应该知道，有好多种 Java 虚拟机，有的运行在Windows上，有的运行在 Linux上。即使在同一个平台上，也会有好几种虚拟机。每种虚拟机对 HashSet 的实现都是不一样的，所以每种虚拟机对 HashSet 的遍历顺序可能都不太一样。但对同一种虚拟机来说，你的遍历输出都是一样的。 Java 是跨平台的，你写的程序可能会在不同的平台上运行，这些平台上的虚拟机都是不一样的。如果你选用了 HashSet，就要明白，在不同的平台上，遍历顺序可能会不一样。如果你对遍历顺序有要求，就要考虑使用有序的，或排序的容器。 HashSet 类的构造方法： 1234HashSet(); &#x2F;&#x2F; 初始化一个哈希表HashSet(Collection c); &#x2F;&#x2F; 由 c 中的元素初始化HashSet(int capacity); &#x2F;&#x2F; 初始容量为 capacityHashSet(int capacity, float fillRatio); &#x2F;&#x2F; 初始容量为 capacity，填充比 fillRatio，默认 0.75 1234567891011121314&#x2F;&#x2F; HashSet 初体验HashSet&lt;String&gt; hs &#x3D; new HashSet&lt;String&gt;();hs.add(&quot;F&quot;);hs.add(&quot;C&quot;);hs.add(&quot;B&quot;);hs.add(&quot;E&quot;);hs.add(&quot;D&quot;);hs.add(&quot;A&quot;);System.out.println(hs.size()); &#x2F;&#x2F; 6System.out.println(hs.add(&quot;C&quot;)); &#x2F;&#x2F; falsehs.remove(&quot;C&quot;);System.out.println(hs.add(&quot;C&quot;)); &#x2F;&#x2F; trueSystem.out.println(hs); &#x2F;&#x2F; [A, B, C, D, E, F] TreeSetTreeSet 类使用树（二叉树）实现 了Set 接口。 除了上层 Set 给予的特性外，TreeSet 集合类还具有以下的特性： 对象默认按升序存储，检索很快 适用于存储大量需要检索的信息 TreeSet 类的构造方法： 1234TreeSet(); &#x2F;&#x2F; 初始化一个空的 TreeSetTreeSet(Collection c); &#x2F;&#x2F; 由 c 中的元素初始化TreeSet(Comparator comp); &#x2F;&#x2F; 通过比较器（Comparator）自定义比较规则TreeSet(SortedSet ss); TreeSet 类扩充的方法： first()：返回第一个元素 last()：返回最后一个元素 1234567891011&#x2F;&#x2F; TreeSet 初体验TreeSet&lt;String&gt; ts &#x3D; new TreeSet&lt;&gt;();ts.add(&quot;1&quot;);ts.add(&quot;3&quot;);ts.add(&quot;2&quot;);ts.add(&quot;C&quot;);ts.add(&quot;a&quot;);ts.add(&quot;B&quot;);System.out.println(ts.first()); &#x2F;&#x2F; 1System.out.println(ts); &#x2F;&#x2F; [1, 2, 3, B, C, a] SortedSetSortedSet 类也实现了 Set 接口，保存有序的集合。 QueueQueue 接口是数据结构中队列的实现，与 List、Set 同一级别，都是继承了 Collection 接口。LinkedList 类实现了 Queue 接口。 队列有两个基本操作：在队列尾部加入一个元素（入队），和从队列头部移除一个元素（出队） 方法 描述 boolean add(E e) 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常 boolean offer(E e) 添加一个元素并返回true，如果队列已满，则返回false E remove() 移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 E poll() 移除并返问队列头部的元素，如果队列为空，则返回null E element() 返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 E peek() 返回队列头部的元素，如果队列为空，则返回null MapMap 叫做映射接口，它存储的是一系列形如&lt;K, V&gt;的“键值对”元素，提供 key 到 value 的映射，通过 key 就能找到对应的 value，key 必须是唯一的，value 可以相同。 Map 接口下也有一些实现它的标准类：HashMap、TreeMap、SortedMap 等 123public interface Map&lt;K,V&gt; &#123; ... &#125;public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; ... &#125;public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; ... &#125; Map 接口中常用的方法： 方法 描述 int size() 返回“键值对”的个数 Object get(Object k) 通过 key 获取 value Object put(Object k, Object v) 添加一对对象到映射中，同时改写原来 key 所对应 value（如果存在的话） Object putAll(Map m) 将映射 m 添加到调用的映射中 void remove(Object k) 删除关键字为 k 的那一对对象 void clear() 清空映射 boolean containsKey() 映射中是否存在该 key boolean containsValue() 映射中是否存在该 value boolean isTmpty() 映射是否为空 Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() 将 Map 变为 Collection 返回 Set&lt;k&gt; keySet() 得到键的“类集视图” Collection values() 得到值的“类集视图” 需要注意的是，Map 并不属于 Collection，他们没有任何亲缘关系。但可以通过一些方法获得映射的类集视图：entrySet()、keySet() 和 values()，“类集视图”是将映射集成到类集框架内的手段。 HashMapHashMap 类使用哈希表实现 Map 接口 HashMap 集合类的特点： 允许有 null 元素，但 key 最多有一个 null，value 不限制 不同步，非线程安全 更新快（插入、删除元素） 不保证元素的迭代顺序，同 HashSet HashMap 类的构造方法： 1234HashMap(); &#x2F;&#x2F; 初始化一个散列映射HashMap(Map m); &#x2F;&#x2F; 由 m 中的元素初始化HashMap(int capacity); &#x2F;&#x2F; 初始容量为 capacityHashMap(int capacity, float fillRatio); &#x2F;&#x2F; 初始容量为 capacity，填充比 fillRatio，默认 0.75 12345678910111213141516171819HashMap&lt;String, Double&gt; hm &#x3D; new HashMap&lt;&gt;();System.out.println(hm); &#x2F;&#x2F; &#123;&#125;hm.put(&quot;苹果&quot;, 19.8);hm.put(&quot;橘子&quot;, 15.0);hm.put(&quot;香蕉&quot;, 13.5);hm.put(&quot;香蕉&quot;, 14.5); &#x2F;&#x2F; 修改元素System.out.println(hm); &#x2F;&#x2F; &#123;苹果&#x3D;19.8, 香蕉&#x3D;14.5, 橘子&#x3D;15.0&#125;&#x2F;&#x2F; 将 Map 转换为 SetSet&lt;Entry&lt;String, Double&gt;&gt; set &#x3D; hm.entrySet();Iterator&lt;Entry&lt;String, Double&gt;&gt; it &#x3D; set.iterator();while (it.hasNext()) &#123; Map.Entry&lt;String, Double&gt; entry &#x3D; (Map.Entry&lt;String, Double&gt;) it.next(); System.out.println(entry); &#x2F;&#x2F; 苹果&#x3D;19.8 香蕉&#x3D;14.5 橘子&#x3D;15.0 System.out.println(entry.getKey()); System.out.println(entry.getValue());&#125; TreeMapTreeMap 类使用树（二叉树）来实现 Map 接口。 TreeMap 集合类的特点： key 和 value 都不允许有 null 元素 元素按升序排序 更新和访问的效率不如 HashMap TreeMap 类的构造方法： 1234TreeMap(); &#x2F;&#x2F; 初始化一个空的树映射TreeMap(Comparator comp); &#x2F;&#x2F; 通过比较器（Comparator）自定义比较规则TreeMap(Map m); &#x2F;&#x2F; 由 m 中的元素初始化TreeMap(sortedMap sm); &#x2F;&#x2F; 由 sm 中的元素初始化 1234567891011121314151617181920TreeMap&lt;String, Double&gt; tm &#x3D; new TreeMap&lt;String, Double&gt;();System.out.println(tm); &#x2F;&#x2F; &#123;&#125;tm.put(&quot;苹果&quot;, 19.8);tm.put(&quot;橘子&quot;, 15.0);tm.put(&quot;香蕉&quot;, 13.5);Set&lt;String&gt; set &#x3D; tm.keySet();Iterator&lt;String&gt; it &#x3D; set.iterator();while (it.hasNext()) &#123; String string &#x3D; (String) it.next(); System.out.println(string);&#125;Collection&lt;Double&gt; coll &#x3D; tm.values();Iterator&lt;Double&gt; it2 &#x3D; coll.iterator();while (it2.hasNext()) &#123; Double double1 &#x3D; (Double) it2.next(); System.out.println(double1);&#125; SortedMapSortedMap 类也实现了 Map 接口，使 Key 保持在升序排列。 Map.Entry 接口java.util.Map.Entry 接口描述了在一个 Map 中的一个元素（键/值对），其中有两个重要的方法： getKey() getValue() Collection 的输出和遍历迭代器 IteratorIterator 是标准的类集输出方式。 迭代器（Iterator）是一种设计模式，Java 把它封装成了一个接口，利用这个接口的迭代方法iterator()可以实现类集的遍历。 每一个 Collection 接口的标准实现类都提供一个迭代方法iterator()，调用这个方法返回一个该类集的迭代器（类似 C 语言中的指针），用来遍历该类集的每一个元素。 Iterator 接口定义如下： 12345public interface Iterator&lt;E&gt; &#123; public boolean hasNext(); public E next(); public void remove();&#125; hasNext：判断是否有下一个元素 next：取得下一个元素 remove：删除当前元素（需要先通过next取得元素） 使用迭代方法的步骤： 调用该类集的iterator()方法获取该类集的迭代器 hasNext()为真就进行迭代 使用next()取得元素 123456789List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(&quot;hello&quot;);list.add(&quot;Java&quot;);Iterator&lt;String&gt; iterator &#x3D; list.iterator();while (iterator.hasNext()) &#123; String elem &#x3D; iterator.next(); System.out.println(elem);&#125; 双向迭代器 ListIterator双向迭代器 ListIterator 扩展了迭代器 Iterator，增加了一些方法，允许双向遍历类集，并且可以修改元素 注意：完成反向遍历前，需要先进行正向遍历，让迭代器（指针）指向类集尾部 方法 描述 void add(Object obj) 将 obj 插入到列表 void set(Object obj) 将 obj 赋给当前元素 void remove() 删除当前元素 boolean hasNext() 是否有下一个元素 boolean hasPrevious() 是否有上一个元素 boolean next() 取得下一个元素 boolean previous() 取得上一个元素 boolean nextIndex() 取得下一个元素的索引 boolean previousIndex() 取得上一个元素的索引 12345678910111213141516171819ArrayList&lt;String&gt; al &#x3D; new ArrayList&lt;String&gt;();al.add(&quot;a&quot;);al.add(&quot;b&quot;);al.add(&quot;c&quot;);System.out.println(al);ListIterator&lt;String&gt; listIt &#x3D; al.listIterator(); &#x2F;&#x2F; 返回该类集的双向迭代器 listIt&#x2F;&#x2F; 正向遍历while (listIt.hasNext()) &#123; String string &#x3D; (String) listIt.next(); listIt.set(string + &quot;-set&quot;); &#x2F;&#x2F; 修改元素&#125;&#x2F;&#x2F; 反向遍历while (listIt.hasPrevious()) &#123; String string &#x3D; (String) listIt.previous(); System.out.println(string); &#x2F;&#x2F; c-set b-set a-set&#125; 枚举迭代 EnumerationEnumeration 属于最古老的输出接口之一，==尽管没有被废弃，但是已经被迭代器 Iterator 所取代。== 若要取得 Enumeration 的对象，只能依靠 Vector 类。 Enumeration 接口定义如下： 1234public interface Enumeration&lt;E&gt; &#123; public boolean hasMoreElements(); public E nextElement();&#125; 12345678910Vector&lt;String&gt; al &#x3D; new Vector&lt;String&gt;();al.add(&quot;a&quot;);al.add(&quot;b&quot;);al.add(&quot;c&quot;);Enumeration&lt;String&gt; en &#x3D; al.elements();while (en.hasMoreElements()) &#123; String string &#x3D; (String) en.nextElement(); System.out.println(string);&#125; for、foreach、forEach 输出foreach 不仅可以用来遍历数组，也可以用来遍历集合类。 12345678910111213List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(&quot;hello&quot;);list.add(&quot;Java&quot;);&#x2F;&#x2F; 普通 foreachfor (String elem : list) &#123; System.out.println(elem);&#125;&#x2F;&#x2F; Java 8 Lambda 表达式list.forEach(item -&gt; &#123; System.out.println(item);&#125;); Map 的输出和遍历 遍历技巧：如果需要在遍历过程中增加元素，可以新建一个临时map存放新增的元素，等遍历完毕，再把临时map放到原来的map中 遍历集合类有多种方法，从最早的 Iterator，到 Java 5 支持的 foreach ，再到 Java 8 的 Lambda 表达式，让我们一起来看下具体的用法以及各自的优缺点： entrySet()可以同时拿到key和value，这一种也是最常用的遍历方法，==推荐使用==。 12345678Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(&quot;name&quot;, &quot;白小明&quot;);map.put(&quot;sex&quot;, &quot;男&quot;);for (Map.Entry&lt;String, String&gt; string : map.entrySet()) &#123; System.out.println(string.getKey()); System.out.println(string.getValue());&#125; keySet()、values()如果只需要map的key或者value，用map的keySet或values方法无疑是最方便的。 1234567891011Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(&quot;name&quot;, &quot;白小明&quot;);map.put(&quot;sex&quot;, &quot;男&quot;);for (String string : map.keySet()) &#123; System.out.println(string);&#125;for (String string : map.values()) &#123; System.out.println(string);&#125; keySet()、get(key)可以同时拿到key和value，但性能不及上一种，不推荐使用 12345678Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(&quot;name&quot;, &quot;白小明&quot;);map.put(&quot;sex&quot;, &quot;男&quot;);for (String string : map.keySet()) &#123; System.out.println(string); System.out.println(map.get(string));&#125; IteratorMap 接口中没有迭代器iterator()方法，需要先用 entrySet() 等转成集合才行。 使用 Iterator 的 remove 方法删除元素非常便捷，如果需要在遍历过程中删除元素推荐使用Iterator。 123456789101112Map&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(\"name\", \"白小明\");map.put(\"sex\", \"男\");Set&lt;Map.Entry&lt;String, String&gt;&gt; set = map.entrySet();Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = set.iterator();while (it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = (Map.Entry&lt;String, String&gt;) it.next(); System.out.println(entry.getKey() + \" = \" + entry.getValue()); // it.remove(); // 删除元素&#125; Java 8 Lambda 表达式Java 8 提供了 Lambda 表达式支持，语法看起来更简洁，可以同时拿到key和value，不过，经测试，性能低于 entrySet 1234567Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(&quot;name&quot;, &quot;白小明&quot;);map.put(&quot;sex&quot;, &quot;男&quot;);map.forEach((key, value) -&gt; &#123; System.out.println(key + &quot; &#x3D; &quot; + value);&#125;); 关于 Map 遍历的一个简单的性能测试用100万条数据，做了一个简单性能测试，该测试结果仅供参考 1234567891011121314151617181920212223242526272829303132333435private static int sum;public static void main(String[] args) &#123; Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;(); for (int i &#x3D; 0; i &lt; 1000000; i++) &#123; map.put(i, 1); &#125; entrySet(map); &#x2F;&#x2F; 29 31 31 lambda(map); &#x2F;&#x2F; 204 202 238&#125;private static void entrySet(Map&lt;Integer, Integer&gt; map) &#123; long start &#x3D; System.currentTimeMillis(); for (Map.Entry&lt;Integer, Integer&gt; integer : map.entrySet()) &#123; sum +&#x3D; integer.getKey() + integer.getValue(); &#125; long end &#x3D; System.currentTimeMillis(); System.out.println(end - start);&#125;private static void lambda(Map&lt;Integer, Integer&gt; map) &#123; long start &#x3D; System.currentTimeMillis(); map.forEach((key, value) -&gt; &#123; sum +&#x3D; key + value; &#125;); long end &#x3D; System.currentTimeMillis(); System.out.println(end - start);&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://bxm0927.github.io/tags/Java/"},{"name":"Collection","slug":"Collection","permalink":"https://bxm0927.github.io/tags/Collection/"},{"name":"List","slug":"List","permalink":"https://bxm0927.github.io/tags/List/"},{"name":"Set","slug":"Set","permalink":"https://bxm0927.github.io/tags/Set/"},{"name":"Map","slug":"Map","permalink":"https://bxm0927.github.io/tags/Map/"},{"name":"集合类","slug":"集合类","permalink":"https://bxm0927.github.io/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"},{"name":"类集框架","slug":"类集框架","permalink":"https://bxm0927.github.io/tags/%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6/"}]},{"title":"Java 异常处理详细解读","date":"2018-07-10T02:35:58.000Z","path":"2018/07/10/Java-Exception/","text":"异常概述异常（Exception）指的是所有可能造成计算机无法正常处理的情况。发生异常时，将阻止程序的运行，若不妥善处理异常，可能造成计算机死机。经过异常处理，可以保证程序的正常运行，我们把针对不同的异常做妥善的处理的方式叫做“异常处理机制”。 异常处理的目的：加强程序的健壮性、安全性。 Java 中，所有的异常都被封装到相应的类中，同时，用户也可以自定义异常类和自定义抛出异常。 抛出异常（throw）：是指将异常提交给运行时系统的过程。 捕获异常（catch）：是指运行时系统找到发生异常的方法的过程。 异常类 Throwable异常类是指由程序抛出的异常对象所属的类。 异常可以分为两大类：java.lang.Exception类和java.lang.Error类。这两个类均继承自 java.lang.Throwable 类 Error 类通常指的是 JVM 出错和线程死锁，用户无法在程序中处理（无法捕获） Exception 类通常指的是可以处理的异常，分为编译时异常和运行时异常（RuntimeException），编译时异常是 Exception 下除了运行时异常以外的所有异常 对于编译时异常，不解决编译就不会通过 对于运行时异常，可以选择性地来进行处理，如果不处理则出现异常时将交给 JVM 默认处理 获取异常信息的方法 Java 中常见的异常类 异常 描述 NullPointerException 空指向异常（空指针异常）。指的是使用了一个未初始化的对象（未开辟内存空间的对象）。 ArithmeticException 算术异常。如：除以零 ArrayIndexOutOfBoundsException 数组下标越界异常。数组的索引超过了上界或下界 FileNotFoundException 文件未找到异常 OutOfMemoryExceptin 内存溢出异常（内存不足异常）。可用内存不足以分配给一个对象时抛出 NoSuchElementExceptin 调用了类集中不存在的元素 ClassCastExceptin 对象与类集中的元素不兼容 UnsupportedOperationExceptin 修改一个不允许修改的对象 异常处理 try-catch-finally 死了都要 try，不 try 到 catch 不痛快 当发生异常时，通常有两种处理方法： 交给 Java 默认的异常处理机制做处理。这种情况 Java 会输出异常信息，然后中断程序的运行 自己编写 try-catch-finally 来捕获异常。这种情况可以灵活的控制程序，而且程序不会中断运行。 异常处理的语法： 12345678try &#123; &#x2F;&#x2F; 要检查的语句&#125; catch (异常类 e) &#123; &#x2F;&#x2F; 异常发生时的处理语句 e.printStackTrace(); &#x2F;&#x2F; 打印异常信息&#125; finally &#123; &#x2F;&#x2F; 一定会运行到的语句&#125; try 语句块不可以独立存在，必须与 catch 或 finally 同存，finally 语句块可以省略 catch 区块可以有多个，此时异常类型必须子类在前，父类在后 当 try 区块捕获到异常时，不执行接下来的语句，立即进入 catch 区块 finally 语句块不会被执行的情况 在 finally 语句块中发生了异常 在前面的代码中使用了 System.exit() 退出程序 程序所在的线程死亡 CPU 关闭 异常处理的几种形式try…catch try…catch…finally try…finally 向上抛出异常 throws方法头中使用 throws 关键字可以表明这个方法可能存在的异常类型，此方法不处理异常，而是将该异常提交给调用这个方法的方法。 123456789101112131415public class Test &#123; public static void main(String[] args) &#123; int[] arr &#x3D; new int[5]; try &#123; setZero(arr, 10); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;end&quot;); &#125; public static void setZero(int[] arr, int index) throws ArrayIndexOutOfBoundsException &#123; arr[index] &#x3D; 0; &#125;&#125; 自行抛出异常 throwthrows用于方法声明中，声明一个方法会抛出哪些异常，而throw是方法体中实际执行抛出异常的动作。 1throw 异常类型的实例 12345try &#123; throw new ArrayIndexOutOfBoundsException(&quot;我是异常信息&quot;);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 自定义异常类当系统提供的异常类不足以满足业务需求时，我们可以自定义异常类 123class 自定义异常类 extends 异常类型 &#123;&#125; 12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; try &#123; throw new MyException(&quot;我是自定义异常类&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class MyException extends Exception &#123; private String msg; public MyException(String msg) &#123; this.msg &#x3D; msg; &#125; @Override public String toString() &#123; return &quot;MyException [msg&#x3D;&quot; + msg + &quot;]&quot;; &#125;&#125; 异常处理的经验之谈 不要忽略异常 只针对异常的情况才使用异常 优先使用标准异常，而不是直接在方法上 throws Exception 或 Throwable 每个方法抛出的异常都应该有文档 处理运行时异常时，采用逻辑规避同时辅助try-catch处理 在多重catch块后面，可以加上一个catch(Exception)来处理被遗漏的异常 对于不确定的代码，也可以加上try-catch，处理潜在的异常 尽量去处理异常，切忌只是简单的调用printStackTrace()去打印输出 尽量添加finally去释放占用的资源 具体如何处理异常，要根据不同的业务需求和异常类型去决定","tags":[{"name":"Java","slug":"Java","permalink":"https://bxm0927.github.io/tags/Java/"},{"name":"Exception","slug":"Exception","permalink":"https://bxm0927.github.io/tags/Exception/"},{"name":"异常处理","slug":"异常处理","permalink":"https://bxm0927.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"Markdown 入门详细教程","date":"2018-06-26T00:53:05.000Z","path":"2018/06/26/md/","text":"Markdown 简介 Markdown 中文官网：http://www.markdown.cn 【简明版】有道云笔记Markdown指南：http://note.youdao.com/iyoudao/?p=2411 【进阶版】有道云笔记Markdown指南：http://note.youdao.com/iyoudao/?p=2445 Markdown 是一种简单、易读易写的「标记语言」，用来写博客、做笔记非常方便，通常为程序员群体所用。 Markdown 的语法十分简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。用户可以使用一些标记符号以最小的输入代价生成极富表现力的文档（譬如您正在阅读的这份文档就是通过 Markdown 书写的）。 安利一波 Markdown 工具 注意：不同平台的 Markdown 语法会有些许差别。 Markdown 编辑器（支持实时同步预览）： VSCode Sublime + Markdown 插件（MarkdownPreview） Markdown 在线编辑器： CSDN 博客：https://blog.csdn.net 简书：https://www.jianshu.com 马克飞象：https://maxiang.io 作业部落：https://www.zybuluo.com/mdeditor 笔记工具： 有道云笔记：https://note.youdao.com 印象笔记：https://www.yinxiang.com 为知笔记：http://www.wiz.cn OneNote：https://www.onenote.com Markdown 基本语法Markdown 的标记语法非常之多，并且不同平台的 Markdown 语法会有些许差别，但是常用的标记符号不超过十个，且平台间基本通用。 常用标记：标题、粗体、斜体、删除线、下划线、高亮、引用、分割线、链接与图片 不常用标记：列表、待办事项、表格、代码高亮、流程图、序列图、甘特图、数学公式 标题 image 粗体和斜体 image 引用 image 链接与图片 image 分割线 image 列表 image 待办事项 image 表格 image 代码高亮： image 流程图 image 甘特图 image Markdown 使用技巧表情可以在 HTML、Markdown 中使用下面的表情，微软自带的输入法可以输入这些表情： 📦 🚀 🐠 ✂️ 🔥 🚨 ✏️ 🛠 💅 👌 ✨ 💯 ⚛️ 📄 目录有道云支持 Markdown 目录，使用 [TOC] 控制图片大小和位置123&lt;div align&#x3D;&quot;center&quot;&gt; &lt;img width&#x3D;&quot;65&quot; height&#x3D;&quot;75&quot; src&#x3D;&quot;&quot;&#x2F;&gt;&lt;&#x2F;div&gt; 图文混排12345678910111213&lt;img align&#x3D;&quot;right&quot; src&#x3D;&quot;&quot;&#x2F;&gt;这是一个示例图片。图片显示在 N 段文字的右边。N 与图片高度有关。刷屏行。刷屏行。到这里应该不会受影响了，本行应该延伸到了图片的正下方，所以我要足够长才能确保不同的屏幕下都看到效果。 在表格单元格里换行借助于 HTML 里的 &lt;br /&gt; 实现。 123| Header1 | Header2 ||---------|----------------------------------|| item 1 | 1. one&lt;br &#x2F;&gt;2. two&lt;br &#x2F;&gt;3. three | 老子今天不加班.mp31&lt;audio controls&#x3D;&quot;controls&quot; autoplay&#x3D;&quot;true&quot; src&#x3D;&quot;https:&#x2F;&#x2F;oijmns1ch.qnssl.com&#x2F;antiwork_today.mp3&quot;&gt;&lt;&#x2F;audio&gt;","tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://bxm0927.github.io/tags/Markdown/"},{"name":"有道云笔记","slug":"有道云笔记","permalink":"https://bxm0927.github.io/tags/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0/"}]},{"title":"可能是最详细的 Hexo + GitHub Pages 搭建个人博客的教程","date":"2018-06-24T14:00:37.000Z","path":"2018/06/24/hexo-github-blog/","text":"前言 个人博客地址：www.lovebxm.com如果您在搭建的过程中遇到无法解决的问题，可与我交流探讨，QQ：80583600 我们为什么要写博客？一方面写博客可以用来监督自己，阶段性总结归纳所学的知识点，进而达到学以致用的目的；另一方面在于分享精神，在分享与交流的过程中，你的语言表达能力会逐渐变得简洁清晰，而且带有很强的逻辑性。 所以说，写博客是一个好习惯，希望大家能够坚持下来。最近刚好有空，就把自己个人博客搭建的全过程记录下来，希望能够帮助到一些朋友。当然了，搭建个人博客的方式有很多，比如自己写前后端、WordPress、Jekyll等等，这里我是用的是免费开源、简洁高效的“Hexo + GitHub Pages”来搭建。 大概流程如下： 搭建 Node.js 环境 搭建 Git 环境 GitHub 注册和配置 Hexo 安装 Hexo 配置 关联 Hexo 与 GitHub 将 GitHub Pages 地址解析到个人域名 Hexo 常规操作 结束语 搭建 Node.js 环境 为什么要搭建 Node.js 环境？ —- 因为 Hexo 博客系统是基于 Node.js 编写的，要运行在 Node.js 环境之上。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。 Node.js 的包管理器 npm（node package manager），是全球最大的开源库生态系统，安装 Node.js 时会自动安装 npm。我们之后要通过 npm 来安装 Hexo。 在 Node.js 官网：https://nodejs.org/en/ 下载最新稳定版，安装时保持默认设置即可，一路Next，安装很快就结束了。 最后，打开命令提示符，输入 node -v、npm -v，出现版本号则说明 Node.js 环境配置成功，第一步完成！！！ 搭建 Git 环境 为什么要搭建 Git 环境？ —- 因为需要把本地的网页和文章等资源提交到远程Git仓库（GitHub）上。 Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 在 Git 官网：https://git-scm.com/ 下载安装包，安装过程如下： 桌面右键，打开 Git Bush Here，输入 git --version，出现版本号则说明 Git 环境配置成功，第二步完成！！！ GitHub 注册和配置GitHub 是什么？GitHub 又名 GayHub，全球最大的同性交友网站。 （哈哈哈，开个玩笑 ^_^）实际上，GitHub 是一个代码托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。我们的博客最终是托管在 GitHub 上的。 Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 提供的域名 github.io 或者自定义域名来发布站点。 首先，我们需要在 Github 官网进行注册：https://github.com image 然后，创建仓库：Repository name 使用自己的用户名，每个用户只能建立一个，仓库名规则（注意：yourname 必须是你的用户名）： 1yourname&#x2F;yourname.github.io 比如我的仓库是这样创建的： 最后，访问 https://yourname.github.io，比如我的是 https://bxm0927.github.io，如果可以正常访问，那么 Github 的配置已经结束了，第三步完成！！！ 至此，搭建 Hexo 个人博客的前置环境配置已经完成，下面开始讲解 Hexo 搭建个人博客的核心操作。 Hexo 安装什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架，默认使用 Markdown 解析文章，在几秒内，即可利用靓丽的主题生成静态网页，只需一条指令即可部署到 GitHub Pages 或其他网站。 强烈建议读者花20分钟去读一读 Hexo 的官方文档：https://hexo.io/zh-cn/ 使用 npm 安装 Hexo（在这之前，请确保你已经成功安装了Node.js和Git）： 1npm install hexo-cli -g 然后你将会看到下图所示信息，可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。 查看Hexo的版本，hexo version，正确输出如下信息则代表 Hexo 安装成功。 Hexo 配置安装 Hexo 完成后，执行下列命令来初始化 Hexo，用户名改成你自己的（我的是bxm0927），Hexo 将会在指定文件夹中新建博客系统所需要的文件。 12345hexo init bxm0927.github.iocd bxm0927.github.ionpm install 新建完成后，目录如下（不同的版本可能目录有些不一样）： 1234567891011.├── .deploy # 需要部署的文件├── node_modules # Hexo依赖├── public # 生成的静态网页文件├── scaffolds # 模板，当您新建文章时，Hexo 会根据 scaffold 来建立文件。├── source # 博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts # 草稿| └── _posts # 文章├── themes # 主题，Hexo 会根据主题来生成各种各样的静态页面。├── _config.yml # 全局配置文件，您可以在此配置大部分的参数。└── package.json # npm 依赖配置文件 然后，在本地运行 Hexo：hexo server或hexo s 您的网站会在 http://localhost:4000 下启动，如果能够正常访问（如下图），则说明 Hexo 博客系统已经搭建起来了，但是目前只是在本地哦，别人是看不到的。 在下面步骤中，我们要把这个本地博客系统部署到 Github 上，让外网的人能够访问到你的博客。 常见问题：执行hexo server提示找不到该指令解决办法：在 Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：npm install hexo -server –save 关联 Hexo 与 GitHub 这一步对于不熟悉GitHub的朋友来说可能有些繁琐，慢慢来，不要着急~ 配置 SSH 生成 SSH 首先，使用SSH让本地Git项目与远程的GitHub建立起连接，方便传输文件。执行下面命令生成SSH公私钥，一路回车（记得输入你自己的邮箱地址哦~）： 1ssh-keygen -t rsa -C &quot;80583600@qq.com&quot; 添加 SSH Key 到 GitHub 用记事本打开 C:\\Users\\bxm09\\.ssh\\id_rsa.pub，此文件里面内容为刚才生成的公公钥，准确的复制这个文件的内容，粘贴到 https://github.com/settings/ssh 的“new SSH key”中 测试 输入下面的命令，看看SSH是否配置成功，git@github.com的部分不要修改： 1ssh -T git@github.com 如果是下面的反馈： 123The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes&#x2F;no)? 不要紧张，输入yes就好，然后会看到： 1Hi aierui! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 配置 Git 个人信息现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理。 输入下面的代码进行个人信息的设置（把名称和邮箱替换成你自己的）： 12git config --global user.name &quot;bxm0927&quot;git config --global user.email &quot;80583600@qq.com&quot; 配置 Deployment在_config.yml文件中，找到Deployment，然后按照如下修改： 注意：1. 用户名改成你自己的，2. 冒号后面记得空一格 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.htmldeploy: type: git repo: git@github.com:bxm0927&#x2F;bxm0927.github.io.git branch: master 将本地文件提交到 GitHub Pages 来了来了来了~ 1234567891011121314# 本地预览hexo s# 删除旧的静态文件，即 public 文件hexo clean# 生成新的静态文件，即 public 文件（或者 hexo g）hexo generate# 部署到远程站点，即 GitHub（或者 hexo d）hexo deploy# 当然你也可以执行下面的组合命令hexo d -g 在浏览器中输入 https://bxm0927.github.io （用户名改成你自己的），可以正常访问则说明 Hexo 与 GitHub 已经成功关联了，哇哇哇哇哇哇，开心死你了，不要忘了回来给我点赞哟 ~ 常见问题 若上面操作失败，则需要提前安装一个扩展： 1npm install hexo-deployer-git --save 如果在执行 hexo d 后,出现 error deployer not found:github 的错误（如下），则是因为没有设置好 public key 所致，重新详细设置即可。 1234Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 怎么避免 Markdown 文件（.md）被解析？ Hexo 原理就是在执行hexo generate时会在本地先把博客生成的一套静态html页面，然后放到public文件夹中，再执行hexo deploy时将其复制到.deploy文件夹中。 Github 通常建议同时附上README.md项目说明文档，但是 hexo 默认情况下会把所有 Markdown 文件（.md）文件解析成html文件，所以即使你在线生成了 README. md，它也会在你下一次部署时被删去。 那么怎么解决呢？ 在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。 将 GitHub Pages 地址解析到个人域名 其实当上一步结束之后，我们的博客也基本上完成了，能发博文，别人也能够通过外网域名访问到你的站点，但是~ 看着博客的域名是GitHub的二级域名，总有一种寄人篱下的感觉，为了让这个小窝看起来更加正式，我们可以花几十块钱去买一个自己的域名，然后将其绑定自己的域名上，进行该绑定过程，其实就是一个重定向的过程。这里我使用的是阿里云的万网域名服务： 在 GitHub 仓库的根目录下建立一个 CNAME 的文本文件(注意：没有扩展名)，文件里面只能输入一个你的域名，不能加http:// 1www.xxx.com 注意到时候CNAME一定是在你Github项目的master根目录下，你也可以建立一个CNAME的文本文件，放到Hexo–&gt;public目录下，因为到时候同步上去的是这个public文件夹。 进入阿里云域名解析地址，添加解析： 记录类型选择CNAME 主机记录填www 解析线路选择默认 记录值填yourname.github.io TTL值为10分钟 再添加一个解析，记录类型A 主机记录填www 解析线路选择默认 记录值填你GitHub 的ip地址（在cmd中ping：） 1ping bxm0927.github.com 点击保存，等 1 分钟，访问下你自己的域名，一切就ok了。 域名绑定成功，域名解析成功，因此你在浏览中输入 www.lovebxm.com，或 lovebxm.com 就可以访问到博客了，输入 bxm0927.github.io 会重定向到 www.lovebxm.com。过程：www 的方式，会先解析成 http://xxxx.github.io，然后根据 CNAME 再变成 www 注意：CNAME文件在下次 hexo deploy的时候就消失了，需要重新创建，这样就很繁琐 方法一：每次 hexo d 之后，就去 GitHub 仓库根目录新建 CNAME文件 方法二：在 hexo g 之后， hexo d 之前，把CNAME文件复制到 “\\public&quot; 目录下面，里面写入你要绑定的域名。 方法三（推荐）：将需要上传至github的内容放在source文件夹，例如CNAME、favicon.ico、images等，这样在 hexo d 之后就不会被删除了。 方法四：通过安装插件实现永久保留 1$ npm install hexo-generator-cname --save 之后在_config.yml中添加一条 12plugins:- hexo-generator-cname 需要注意的是：如果是在github上建立的CNAME文件，需要先clone到本地，然后安装插件，在deploy上去即可。CNAME只允许一个域名地址。 注意1：每次生成的 CNAME 都是 yoursite.com 怎么解决？ 修改 _config.yml 1234url: http:&#x2F;&#x2F;www.lovebxm.comroot: &#x2F;permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;permalink_defaults: Hexo 常规操作发表一篇文章运行下面的命令创建一个新文章文件，然后，会在本地博客文件夹 source\\_posts 文件夹下我们可以看到新建的 markdown 文件。 1hexo new &quot;文章标题&quot; 文章编辑好之后，可以执行本地预览、部署等命令： 1234567891011121314# 本地预览hexo s# 删除旧的静态文件，即 public 文件hexo clean# 生成新的静态文件，即 public 文件（或者 hexo g）hexo generate# 部署到远程站点，即 GitHub（或者 hexo d）hexo deploye# 当然你也可以执行下面的组合命令hexo d -g 显示部分文章内容如果在博客文章列表中不想全文显示，可以在文章中增加 &lt;!-- more --&gt;, 在这后面的内容就不会显示在列表。 1&lt;!-- more --&gt; 更改主题 官方主题库：https://hexo.io/themes/ 有哪些好看的 Hexo 主题？：https://www.zhihu.com/question/24422335 Hexo主题非常丰富，hexo3.0使用的默认主题是landscape，我推荐搭建使用 Next 为主题，好看且文档详细。详情请阅读 Next 的官方文档（ http://theme-next.iissnan.com/ ），5 分钟快速安装。 再提示一点，大家可以修改一步就hexo s在本地看下效果。 添加插件添加 feed 插件和 sitemap 网站地图，有助于 SEO。 切换到你本地的 hexo 目录 ，输入以下命令 12npm install hexo-generator-feed -savenpm install hexo-generator-sitemap -save 修改 _config.yml，增加以下内容 123456789101112# ExtensionsPlugins:- hexo-generator-feed- hexo-generator-sitemap#Feed Atomfeed: type: atom path: atom.xml limit: 20#sitemapsitemap: path: sitemap.xml 再执行以下命令，部署到远端： 1hexo d -g 配完之后，就可以访问 https://bxm0927.github.io/atom.xml 和 https://bxm0927.github.io/sitemap.xml ，发现这两个文件已经成功生成了。 添加404 页面GitHub Pages 自定义404页面非常容易，直接在根目录下创建自己的404.html就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo s在本机调试也是不起作用的。 其实，404页面可以做更多有意义的事，来做个404公益项目吧。 推荐使用腾讯公益404 http://www.qq.com/404/ ： 12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;404&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;br&gt;&lt;!--&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt; &lt;title&gt;公益404 | 不如&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;#404 Not found By Bruce&lt;h1&gt;404 Page Not Found&lt;&#x2F;h1&gt;--&gt;&lt;br&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.qq.com&#x2F;404&#x2F;search_children.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;&lt;br&gt;&lt;!--公益404介接入地址益云公益404 http:&#x2F;&#x2F;yibo.iyiyun.com&#x2F;Index&#x2F;web404腾讯公益404 http:&#x2F;&#x2F;www.qq.com&#x2F;404失蹤兒童少年資料管理中心404 http:&#x2F;&#x2F;404page.missingkids.org.tw--&gt;&lt;br&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 复制上面代码，贴粘到目录下新建的404.html即可！ 我的404页面配置如下： 12345678910111213141516&lt;html&gt;&lt;head&gt; &lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8;&quot;&#x2F;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge,chrome&#x3D;1&quot; &#x2F;&gt; &lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;all&quot; &#x2F;&gt; &lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;index,follow&quot;&#x2F;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;www.qq.com&#x2F;404&#x2F;search_children.js&quot; charset&#x3D;&quot;utf-8&quot; homePageUrl&#x3D;&quot;gdutxiaoxu.github.io&quot; homePageName&#x3D;&quot;回到我的主页&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 多PC同步管理博客很多人可能家里一台笔记本，公司一个台式机，想两个同时管理博客，同时达到备份的博客主题、文章、配置的目的。下面就介绍一下用github来备份博客并同步博客。 A电脑备份博客内容到github 配置.gitignore文件。进入博客目录文件夹下，找到此文件，用sublime text 打开，在最后增加两行内容/.deploy_git和/public 初始化仓库。 在博客根目录下，在git bash下依次执行git init和git remote add origin 为远程仓库地址。 同步到远程仓库。 gitbash下依次执行以下命令 12345git add . #添加目录下所有文件git commit -m &quot;更新说明&quot; #提交并添加更新说明git push -u origin master #推送更新到远程仓库 B电脑拉下远程仓库文件 在B电脑上同样先安装好node、git、ssh、hexo，然后建好hexo文件夹，安装好插件，（然后选做：将备份到远程仓库的文件及文件夹删除），然后执行以下命令： 1234567git initgit remote add origin &lt;server&gt;git fetch --allgit reset --hard origin&#x2F;master 发布博客后同步 在B电脑发布完博客之后，记得将博客备份同步到远程仓库执行以下命令： 1234567git add .#可以用git master 查看更改内容git commit -m &quot;更新信息&quot;git push -u origin master #以后每次提交可以直接git push 平时同步管理每次想写博客时，先执行：git pull进行同步更新。发布完文章后同样按照上面的 发布博客后同步 同步到远程仓库。 中文乱码问题在 md 文件中写中文内容，发布出来后为乱码，原因是 md 的编码不对，将 md 文件另存为UTF-8编码的文件即可解决问题。 结束语建站的系统有很多，如： Hexo + GitHub Pages Jekyll + GitHub Pages WordPress + 服务器 + 域名 DeDeCMS + 服务器 + 域名 … 使用 Hexo + GitHub Pages 建站，有优点也有缺点： GitHub Pages 不支持数据库管理，所以你只能做静态页面的博客，不能像其他博客（如 WordPress）那样通过数据库管理自己的博客内容。 但是，GitHub Pages 无需购置服务器，免服务器费的同时还能做负载均衡，github pages有300M免费空间。 个人博客真的有必要用数据库吗？答案是否定的。博客静态化，评论记录使用第三方的 网易云跟帖 就可以了。静态的博客更有利于搜索引擎蜘蛛爬取，轻量化的感觉真的很好。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，非常符合我的口味。Markdown 真的是专门针对程序员开发的语言啊，现在感觉没有 Markdown 什么都不想写。什么富文本编辑器，什么word，太麻烦了！而且样式都好丑！效率太低！ 推荐几个很好用的在线 Markdown 编辑器： 作业部落：https://www.zybuluo.com/mdeditor 马克飞象：https://maxiang.io 推荐一个图床：极简图床 + chrome 插件 + 七牛空间，七牛云储存提供10G的免费空间,以及每月10G的流量，存放个人博客外链图片最好不过了，七牛云储存还有各种图形处理功能、缩略图、视频存放速度也给力（非打广告）。 以上。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://bxm0927.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://bxm0927.github.io/tags/github/"},{"name":"blog","slug":"blog","permalink":"https://bxm0927.github.io/tags/blog/"},{"name":"搭建个人博客","slug":"搭建个人博客","permalink":"https://bxm0927.github.io/tags/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"blog-hexo","date":"2013-07-13T12:46:25.000Z","path":"2013/07/13/blog/","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 ✂️ Build Setup前置条件： Node.js (Should be at least nodejs 6.9) Git 12345678910111213141516171819# install Hexo$ npm install hexo-cli -g# Create a new Hexo folder.$ hexo init &lt;blog-name&gt;$ cd &lt;blog-name&gt;$ npm install# Start the server.$ hexo server# Generate static files.$ hexo generate # hexo g# Deploy your website.$ hexo deploy # hexo d# One-click deployment$ hexo generate --deploy # hexo g -d ✏️Q&amp;A","tags":[{"name":"HTML","slug":"HTML","permalink":"https://bxm0927.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://bxm0927.github.io/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://bxm0927.github.io/tags/JS/"}]}]