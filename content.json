[{"title":"Chrome DevTools 调试技巧","date":"2020-05-24T05:06:08.448Z","path":"2020/05/24/chrome-devtools/","text":"前言工欲善其事必先利其器。 有些时候一个技巧可以节省我们很多的时间，也会让调试的过程变得更加简单直接。本次分享从不同的情景来说明应该如何搭配使用 Chrome DevTools 中的小技巧，让大家熟练掌握 Chrome 调试技巧，直接提升工作效率。 关于 Chrome谷歌浏览器（通常简称为 Chrome ）是由谷歌开发的网络浏览器。 它于 2008 年首次针对 Microsoft Windows 发布，后来移植到 Linux ，macOS ，iOS 和 Android 。 浏览器也是 Chrome OS 的主要组件，它可以作为 Web 应用的平台。Chrome-wikipedia 现如今，浏览器的市场已天下三分，Chorme，Safari 和 FireFox，从 2008 年 Chrome 横空出世以来，如今已经一家独大占据了半壁江山： image 关于 Chrome DevTools对于大部分人来说，Chrome 可能只是个浏览器，但是对于开发人员来说，它更是一个强大无比的工具，为了方便开发人员调试代码，主流的浏览器都内置了 DevTools， 所以无论你是前端还是后端，掌握 Chrome DevTools 的使用技巧意味着效率直接的提高。 打开方式 F12 Ctrl + Shift + I (Windows) 或 Cmd + Opt + I (Mac) 更多工具 &gt; 开发者工具 在页面元素上右键点击，选择 “检查” 面板概览Chrome DevTools 包含 1 个设备模式和 8 个常见的面板，我们还可以通过插件来增加一些面板（如：Vue-DevTools） 0. 设备模式 Device Mode 使用设备模式构建完全响应式，移动优先的网络体验。 image 1. 元素面板 Elements 使用元素面板可以自由的操作 DOM 和 CSS 来迭代布局和设计页面。 image 2. 控制台面板 Console 在开发期间，可以使用控制台面板记录诊断信息，或者使用它作为 shell 在页面上与 JavaScript 交互。 image 3. 源代码面板 Sources 在源代码面板中设置断点来调试 JavaScript ，或者通过Workspaces（工作区）连接本地文件来使用开发者工具的实时编辑器。 image 4. 网络面板 Network 使用网络面板了解请求和下载的资源文件并优化网页加载性能。 image 5. 性能面板 Performance 使用性能面板可以通过记录和查看网站生命周期内发生的各种事件来提高页面的运行时性能。 image 6. 内存面板 Memory 如果需要比内存面板提供的更多信息，可以使用内存面板，例如跟踪内存泄漏。 image 7. 应用面板 Application 使用应用面板可以检查加载的所有资源，包括 IndexedDB 与 Web SQL 数据库，本地和会话存储，cookie，应用程序缓存，图像，字体和样式表。 image 8. 安全面板 Security 使用安全面板调试混合内容问题，证书问题等等。 image 实用快捷键Ctrl + shift + D：把 DevTools 窗口切换到右边、下边 Ctrl + shift + M：切换设备模式 Ctrl + [ 和 Ctrl + ]：切换面板 上下箭头：递增/递减，可配合 Alt、Ctrl、Shift 实现不同的步长（对调整样式特别有用） Ctrl + F：在 elements， logs， sources 和 network 中查找 使用 Command我们直接可以直接看到的 DevTools 的功能，其实只是有限的一部分，怎么去探索更多的功能呢？ Command 菜单可以帮助我们快速找到那些被隐藏起来的功能，你可以使用 Ctrl + Shift + P 或 DevTools 的 dropdown 按钮打开 Command。 Command 包含下列几类命令： image 常用的 Command： 截屏：capture 切换主题：theme copying你可以通过全局的方法 copy() 在 console 里复制任何你能拿到的资源 例如：copy(location) image saving如果你在 console 中打印了一堆数据（例如一个大型数组），然后你想对这些数据做一些额外的操作，那就可以将它转换成一个全局变量，只需要右击它，并选择 “Store as global variable” (保存为全局变量) 选项。第一次使用的话，它会创建一个名为 temp1 的变量，第二次创建 temp2，以此类推。 注意：得到的 temp$ 的是原数据的引用，操作会影响原数据。 image 保存堆栈信息( Stack trace )大多数情况下都不是一个人开发一个项目，而是一个团队协作，那么 如何准确的描述问题，就成为了沟通的关键 ，这时候 console 打印出来的堆栈跟踪的信息对你和同事来说就起大作用了，可以省去很多沟通成本，所以你可以直接把堆栈跟踪的信息保存为一个文件，而不只是截图发给对方： image Snippets 代码段 如果你需要频繁地在 console 中输入某个代码段，Snippets 功能可能会帮助你。 比如，我想统计网页标签使用数量，评价网页是否语义化，我会把这段脚本赋值 Console 面板： 1234567891011/** * 统计网页标签使用数量，评价网页是否语义化的重要指标 */function getTagsMap() &#123; return [...document.querySelectorAll('*')].reduce((a, c) =&gt; &#123; let tagName = c.tagName.toLowerCase() a[tagName] = a[tagName] ? a[tagName] + 1 : 1 return a &#125;, &#123;&#125;)&#125;getTagsMap() 现在看来，即使这个脚本并没有花费我太多的精力来编写，但也只是偶尔运行一下，所以对于我来说，记住一段这样的脚本会很麻烦。 那怎么解决这个问题呢？ 这就是 Snippets 的用武之地：它允许你存放 JavaScript 代码到 DevTools 中，方便你复用这些 JavaScript 代码段： 进入到 Sources 面板，在导航栏里选中 Snippets 这栏，点击 New snippet 新建一个代码段，然后输入你的代码之后保存就可以 Run 了！ 当我在 DevTools 中预设了一组很棒的代段块以后，甚至都不必再通过 Sources 来运行它们。使用 Command Menu 才是最快的方式。只需在它的输入框中输入 !，就可以根据名字来筛选预设代码段。 image Elements 篇H 隐藏元素 Delete 删除元素 Ctrl + C 复制元素 Ctrl + Z 撤销改动 拖动 &amp; 放置 元素 使用 Ctrl 移动元素 更多操作请在元素上点击右键 image console 篇多种多样的 consoleconsole.log 普通打印 console.table 表格打印（适用于数组、类数组、对象） console.dir 查看节点属性 console.assert 断言 console.time / console.timeEnd() 计时器 console 中的 ‘$’1. $0 在 Chrome 的 Elements 面板中， $0 是对我们当前选中的 html 节点的引用。 同理，$1 是对上一次我们选择的节点的引用，一直到 $4。 你可以尝试一些相关操作，例如: $1.appendChild($0) 2. $ 和 $$ console 面板中 $ 变量如果未曾被定义过就是 document.querySelector 的别名 $$ 相当于执行 document.QuerySelectorAll 并且它返回的是一个节点的数组。 1$$('div') === Array.from(document.querySelectorAll('div')) 3. $_ $_ 是对上次执行的结果的引用 image 4. $i 在 DevTools 中使用 npm 插件！ 有时你只是想尝试下新出的 npm 包，现在不用再大费周章去建一个项目测试了，只需要在 Chrome 扩展插件: Console Importer 的帮助之下，快速的在 console 中引入和测试一些 npm 库。 运行 $i(&#39;lodash&#39;) 或者 $i(&#39;moment&#39;) 后，你就可以获取到 lodash / momentjs 了: image 断点调试 breakpoints基本用法你还在用console.log 和 alert 吗？使用断点（breakpoint）可以非常方便地调试 JavaScript 代码。 在行号上单击就设置了一个断点，然后你就可以调试了。当然这也是最最基本的打断点的方式了，当然了，相较于调试全靠 console.log 和 alert 已经高端很多了。 同时也可以通过在行号上右键点击 Add breakpoint 来设置断点。设置断点的行号上会显示一个蓝色的矩形来告诉你这里有一个断点。 image 当断点触发时，整个页面会处于暂停状态，并会切换到 Source 页断点处方便调试，直到终止该断点调试后页面才会继续运行。 快捷键： F8 F9 F10 F11 条件断点比如说你写了一个循环，该循环会执行 100 次，但是你只对第 50 次循环的结果感兴趣，又或者你只对一些满足某些条件的结果感兴趣。于是，你一手托腮，另一只手放在 F8 键上，狂按数十下下后正襟危坐，开始调试。 显然，Chrome 已经帮我们想到了这种场景，我们可以通过添加一些条件断点来避免一些无意义的断点： 右击行号，选择 Add conditional breakpoint...(添加条件断点) 或者右击一个已经设置的断点并且选择 Edit breakpoint(编辑断点) 然后输入一个执行结果为 true 或者 false 的表达式（它的值其实不需要完全为 true 或者 false 尽管那个弹出框的描述是这样说的）。在这个表达式中你可以使用任何这段代码可以获取到的值（当前行的作用域）。如果条件成立，这个断点就会生效。 image DOM 元素断点断点不仅仅可以设置在 JS 代码上，还可以在 DOM 元素上设置断点。 我们可以设置三种 DOM 元素断点 subtree modifications 子节点内容的的改变（子节点的属性修改不会触发，当前节点的修改不会触发） attribute modifications 当前节点的属性改变 node removal 当前节点被移除 当我们的脚本触发了 DOM 的修改时，devtools 会直接跳转到 Source 页并定位到修改 DOM 的那行代码上。 image 你还一层层展开 DOM？Alt + Click，快速展开所有 DOM image Network - 重新发送 XHR 的请求如何重新发送 XHR 的请求？刷新页面？太老套了，试试这么做： image 恐龙小游戏(Chrome Dino)相信在座的各位对 Google Chrome 中的一个复活节彩蛋 —— 恐龙小游戏(Chrome Dino)不会感到陌生。在与互联网断开连接时，当用户尝试访问网站，并在按下空格键后即可开始这个游戏。 Chrome 中的恐龙小游戏是一个简单的无限跑步游戏，它会让用户跳过仙人掌，并闪避障碍物，游戏为用户提供基本控制，按空格键跳跃（并开始游戏），向下箭头(↓)俯身奔跑以躲避障碍物。目标是在互联网重新开始工作之前让用户打发时间。 其实用户也可以在不打开飞行模式的情况下玩 Chrome dino 游戏。只需在 Chrome 浏览器的地址栏中输入 chrome://dino，用户就可以进入“街机模式”，在那里用户可以在全窗口环境中畅玩这款游戏。 推荐一些好用的 Chrome 扩展启动页：掘金、Infinity新标签页、Momentum 翻译：Google 翻译、有道云翻译、百度翻译、有道词典Chrome划词插件 广告屏蔽：Adblock Plus OneTab Clipboard History 2 WEB前端助手(FeHelper) JSONView Stylish-为任意网站自定义主题 tampermonkey 油猴","tags":[]},{"title":"Promise 对象","date":"2020-05-24T05:06:08.448Z","path":"2020/05/24/promise/","text":"Promise 对象简介Promise 是异步编程的一种更优的解决方案，一定程度上解决了回调函数产生的“回调地狱”的问题。Promise 最早由社区提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 ==Promise 允许将回调函数的嵌套改成链式调用，即用同步的方式去写异步代码，使异步代码看起来像是线性结构。== Promise 对象的两个特点 对象的状态不受外界影响。 Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 注意，我们一般说的 resolved，是指 Promise 对象的状态从 pending 变为 fulfilled，即异步操作成功。 Promise 对象的缺点Promise 也有一些缺点： 首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。 其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。 第三，当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 Promise 对象基本用法ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。该构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 如果调用 resolve 函数和 reject 函数时带有参数，那么它们的参数会被传递给回调函数。 123456789const promise &#x3D; new Promise(function(resolve, reject) &#123; &#x2F;&#x2F; ... some code if (&#x2F;* 异步操作成功 *&#x2F;)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。then 方法可以接受两个回调函数作为参数。 第一个回调函数是 Promise 对象的状态变为 resolved 时调用， 第二个回调函数是 Promise 对象的状态变为 rejected 时调用。 其中，第二个函数是可选的，不一定要提供。 这两个函数都接受 Promise 对象传出的值作为参数。 12345678promise.then( function(value) &#123; &#x2F;&#x2F; success &#125;, function(error) &#123; &#x2F;&#x2F; failure &#125;,) 下面是一个 Promise 对象的简单例子。 12345678910&#x2F;&#x2F; 一段时候后进行打印function timeout(ms) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(resolve, ms, &#39;done&#39;) &#125;)&#125;timeout(3000).then(value &#x3D;&gt; &#123; console.log(value)&#125;) Promise.prototype.then() Promise 实例具有 then、catch、finally 方法，也就是说，then、catch、finally 方法是定义在原型对象 Promise.prototype 上的。 then 方法的作用是为 Promise 实例添加状态改变时的回调函数。 then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用（可选）。 then 方法返回的是一个新的 Promise 实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。 123456getJSON('/post/test.json') .then(post =&gt; getJSON(post.commentURL)) .then( comments =&gt; console.log('resolved: ', comments), err =&gt; console.log('rejected: ', err) ) Promise.prototype.catch()Promise.prototype.catch 方法是 .then(null, rejection) 或 .then(undefined, rejection) 的别名，用于指定发生错误时的回调函数。 12345678promise .then(val =&gt; console.log('fulfilled:', val)) .catch(err =&gt; console.log('rejected', err))// 等同于promise .then(val =&gt; console.log('fulfilled:', val)) .then(null, err =&gt; console.log('rejected:', err)) Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。 最佳实践：一般来说，不要在 then 方法里面定义 reject 状态的回调函数（即 then 的第二个参数），总是使用 catch 方法。一般总是建议，Promise 对象后面要跟 catch 方法，这样可以处理 Promise 内部发生的错误。 123456789101112131415161718// badpromise.then( function(data) &#123; // success &#125;, function(err) &#123; // error &#125;,)// goodpromise .then(function(data) &#123; // success &#125;) .catch(function(err) &#123; // error &#125;) Promise.prototype.finally()finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 我们一般在 finally 方法中关闭服务和资源。 finally 方法的回调函数不接受任何参数，这意味着没有办法知道前面的 Promise 状态到底是 fulfilled 还是 rejected。这表明，finally 方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 1234promise .then(result =&gt; &#123;&#125;) .catch(error =&gt; &#123;&#125;) .finally(() =&gt; &#123;&#125;) finally 本质上是 then 方法的特例。如果不使用 finally 方法，同样的语句需要为成功和失败两种情况各写一次。有了 finally 方法，则只需要写一次。 123456789101112131415161718192021222324252627promise .finally(() &#x3D;&gt; &#123; &#x2F;&#x2F; 都会执行的操作 &#125;)&#x2F;&#x2F; 等同于promise.then( result &#x3D;&gt; &#123; &#x2F;&#x2F; 都会执行的操作 return result &#125;, error &#x3D;&gt; &#123; &#x2F;&#x2F; 都会执行的操作 throw error &#125;,)&#x2F;&#x2F; 等同于promise .then(result &#x3D;&gt; &#123; &#x2F;&#x2F; 都会执行的操作 return result &#125;) .catch(error &#x3D;&gt; &#123; &#x2F;&#x2F; 都会执行的操作 throw error &#125;) Promise.prototype.finally() 底层实现： 1234567Promise.prototype.finally &#x3D; function(callback) &#123; let P &#x3D; this.constructor return this.then( value &#x3D;&gt; P.resolve(callback()).then(() &#x3D;&gt; value), reason &#x3D;&gt; P.resolve(callback()).then(() &#x3D;&gt; throw reason), )&#125; Promise.all()Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例（并发请求）。 1const p = Promise.all([p1, p2, p3]); Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 实例。p 的状态由 p1、p2、p3 决定，分成两种情况。 只有p1、p2、p3的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。 只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。 123456789101112131415161718192021222324function someAsyncThing(value) &#123; return new Promise((resolve, reject) =&gt; &#123; // 这里假如是一个异步操作 value &gt; 10 ? resolve(value) : reject(value) &#125;)&#125;Promise.all([someAsyncThing(11), someAsyncThing(12)]) .then(res =&gt; &#123; console.log('sussess ' + res) &#125;) .catch(err =&gt; &#123; console.log('error ' + err) &#125;)// sussess [11,12]Promise.all([someAsyncThing(11), someAsyncThing(10)]) .then(res =&gt; &#123; console.log('sussess ' + res) &#125;) .catch(err =&gt; &#123; console.log('error ' + err) &#125;)// error 10 Promise.race() race：赛跑 Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.race([p1, p2, p3]); 上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。 Promise.resolve()Promise.resolve 方法用于将现有对象转为 Promise 对象。 Promise.race 方法的参数与 Promise.all 方法一样，如果不是 Promise 实例，就会先调用 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。 12&#x2F;&#x2F; 将 jQuery 生成的 deferred 对象，转为一个新的 Promise 对象const jsPromise &#x3D; Promise.resolve($.ajax(&#39;&#x2F;whatever.json&#39;)); 123Promise.resolve(&#39;foo&#39;)&#x2F;&#x2F; 等价于new Promise(resolve &#x3D;&gt; resolve(&#39;foo&#39;)) Promise.reject()Promise.reject(reason) 方法也会返回一个新的 Promise 实例，该实例的状态为 rejected。 Promise.try()让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API。 12345const f &#x3D; () &#x3D;&gt; console.log(&#39;now&#39;);Promise.try(f);console.log(&#39;next&#39;);&#x2F;&#x2F; now&#x2F;&#x2F; next Promise 库Bluebird：http://bluebirdjs.com/docs/api/promise.try.html Q：https://github.com/kriskowal/q when：https://github.com/cujojs/when 注意事项 Promise 新建后就会立即执行 1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise') resolve()&#125;)promise.then(function() &#123; console.log('resolved.')&#125;)console.log('Hi!')// Promise// Hi!// resolved 1234567891011121314151617setTimeout(function() &#123; console.log(1)&#125;, 0)new Promise(function executor(resolve) &#123; console.log(2) for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve() &#125; console.log(3)&#125;).then(function() &#123; console.log(4)&#125;)console.log(5)// 2 3 5 4 1 调用 resolve 或 reject 并不会终结 Promise 的参数函数的执行。 12345678new Promise((resolve, reject) =&gt; &#123; resolve(1) console.log(2)&#125;).then(r =&gt; &#123; console.log(r)&#125;)// 2// 1 一般来说，调用 resolve 或 reject 以后，Promise 的使命就完成了，后继操作应该放到 then 方法里面，而不应该直接写在 resolve 或 reject 的后面。所以，最好在它们前面加上 return 语句，这样就不会有意外。 12345new Promise((resolve, reject) &#x3D;&gt; &#123; return resolve(1) &#x2F;&#x2F; 后面的语句不会执行 console.log(2)&#125;) Promise 的 resolve 函数的参数是另一个 Promise 实例。即一个 Promise p1 的结果是返回另一个 Promise p2，那么 p1 的状态由 p2 决定。 12345678910111213const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; reject(new Error('fail')), 3000)&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2 .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error))// 表现：3s 后打印 \"Error: fail\" Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。 12345678910111213141516const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2) &#125;)&#125;someAsyncThing().then(function() &#123; console.log('everything is great')&#125;)setTimeout(() =&gt; &#123; console.log(123)&#125;, 2000)// Uncaught (in promise) ReferenceError: x is not defined// 123 如果 Promise 状态已经变成 resolved，再抛出错误是无效的，即不会被捕获。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。 12345678const promise = new Promise(function(resolve, reject) &#123; resolve('ok') throw new Error('test')&#125;)promise .then(value =&gt; console.log(value)) .catch(error =&gt; console.log(error))// ok","tags":[{"name":"ES6","slug":"ES6","permalink":"https://bxm0927.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://bxm0927.github.io/tags/JavaScript/"}]},{"title":"ES6 学习笔记（下）","date":"2019-04-16T13:03:22.000Z","path":"2019/04/16/blog/","text":"[toc] Symbol==ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型。== 12let s &#x3D; Symbol();typeof s &#x2F;&#x2F; &quot;symbol&quot; 调用 Symbol() 方法将创建一个新的 Symbol 类型的值，并且该值不与其它任何值相等，每个 Symbol 都是独一无二的 123456789&#x2F;&#x2F; 没有参数的情况let s1 &#x3D; Symbol();let s2 &#x3D; Symbol();s1 &#x3D;&#x3D;&#x3D; s2 &#x2F;&#x2F; false&#x2F;&#x2F; 有参数的情况let s1 &#x3D; Symbol(&#39;foo&#39;);let s2 &#x3D; Symbol(&#39;foo&#39;);s1 &#x3D;&#x3D;&#x3D; s2 &#x2F;&#x2F; false 用途： 扩展对象属性名：ES5 的对象属性名都是字符串，这容易造成属性名的冲突。 Set 和 Map 数据结构ES6 提供了新的数据结构 Set、Map 来弥补 ES5 在数据结构上的不足，类似 Java 的 Map 和 Set。 JS 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了 Map 和 Set，这样就有了四种数据集合。 SetSet 类似于数组，但是成员的值都是唯一的，没有重复的值。 ==使用建议：若每一个集合中的元素都是唯一的，这时就用 Set 不用 Array。== Set 结构的实例有以下属性。 Set.prototype.constructor：构造函数，默认就是 Set 函数。 Set.prototype.size：返回 Set 实例的成员总数。 Set 实例的操作方法: add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为 Set 的成员。 clear()：清除所有成员，没有返回值。 Set 实例的遍历方法: keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 123const s &#x3D; new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x &#x3D;&gt; s.add(x));s &#x2F;&#x2F; Set(4) &#123;2, 3, 5, 4&#125; 123456789101112131415161718192021222324252627282930313233let list &#x3D; new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x &#x3D;&gt; list.add(x));for (let i of list) &#123; console.log(i); &#x2F;&#x2F; 2 3 5 4&#125;&#x2F;&#x2F; 添加list.add(x)&#x2F;&#x2F; 获取 Set 的长度list.size&#x2F;&#x2F; 判断是否存在某值list.has(3)&#x2F;&#x2F; 删除list.delete(1)&#x2F;&#x2F; 清空list.clear()&#x2F;&#x2F; 遍历for (let i of list) &#123; console.log(i);&#125;for (let [key, value] of list.entries()) &#123; console.log(&#96;$&#123;key&#125;,$&#123;value&#125;&#96;);&#125;list.forEach((item) &#x3D;&gt; &#123; console.log(item);&#125;); Set 用途： 数组去重 MapMap 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 ==使用建议：一般的，只有在模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value形式的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。== Map 操作方法： size set(key, value) get(key) has(key) delete(key) clear() 123456789101112131415161718192021222324252627282930313233343536&#x2F;&#x2F; 声明、添加let list &#x3D; new Map();list.set(&#39;key&#39;,&#39;value&#39;);console.log(list); &#x2F;&#x2F; &#123;&quot;key&quot; &#x3D;&gt; &quot;value&quot;&#125;let arr &#x3D; [[&#39;k1&#39;, &#39;v1&#39;], [&#39;k2&#39;, &#39;v2&#39;], [&#39;k3&#39;, &#39;v3&#39;]];let list &#x3D; new Map(arr);console.log(list); &#x2F;&#x2F; &#123;&quot;k1&quot; &#x3D;&gt; &quot;v1&quot;, &quot;k2&quot; &#x3D;&gt; &quot;v2&quot;, &quot;k3&quot; &#x3D;&gt; &quot;v3&quot;&#125;&#x2F;&#x2F; 获取 Map 的长度list.size&#x2F;&#x2F; 获取list.get(&#39;key&#39;); &#x2F;&#x2F; value&#x2F;&#x2F; 判断是否存在某值list.has(&#39;key&#39;); &#x2F;&#x2F; true&#x2F;&#x2F; 删除list.delete(&#39;key&#39;); &#x2F;&#x2F; true&#x2F;&#x2F; 清空list.clear();&#x2F;&#x2F; 遍历for (let i of list) &#123; console.log(i);&#125;for (let [key, value] of list.entries()) &#123; console.log(&#96;$&#123;key&#125;,$&#123;value&#125;&#96;);&#125;list.forEach((item) &#x3D;&gt; &#123; console.log(item);&#125;); Proxy 代理器 代理（Proxy）和反射（Reflect）是 Java 框架的底层原理。 代理(Proxy)是一种设计模式，提供了对目标对象另外的访问方式，即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。核心思想：不要随意去修改别人已经写好的代码或者方法，如果需改修改，可以通过代理的方式来扩展该方法 JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 java 语言的反射机制 Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，即用自己的定义覆盖了语言的原始定义。所以 Proxy 属于一种“元编程”（meta programming），即对编程语言进行编程。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截。 1234&#x2F;&#x2F; new Proxy() 表示生成一个Proxy实例&#x2F;&#x2F; target 参数表示所要拦截的目标对象&#x2F;&#x2F; handler 参数也是一个对象，用来定制拦截行为。var proxy &#x3D; new Proxy(target, handler); 123456789var proxy &#x3D; new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time &#x2F;&#x2F; 35proxy.name &#x2F;&#x2F; 35proxy.title &#x2F;&#x2F; 35 123456789101112131415161718192021222324252627&#x2F;&#x2F; 原始对象let obj &#x3D; &#123; name: &#39;白小明&#39;, age: 22&#125;;&#x2F;&#x2F; 新建一个 Proxy 实例let objProxy &#x3D; new Proxy(obj, &#123; &#x2F;&#x2F; 拦截对象属性的读取 get(target, key) &#123; return target[key].replace(&#39;白小明&#39;, &#39;小明&#39;); &#125;, &#x2F;&#x2F; 拦截对象设置属性 set(target, key, value) &#123; if (key &#x3D;&#x3D;&#x3D; &#39;name&#39;) &#123; return (target[key] &#x3D; value); &#125; else &#123; return target[key]; &#125; &#125;&#125;);console.log(objProxy.name); &#x2F;&#x2F; 小明objProxy.name &#x3D; &#39;小白&#39;;objProxy.age &#x3D; 18;console.log(objProxy); &#x2F;&#x2F; Proxy &#123;name: &quot;小白&quot;, age: 22&#125; Reflect 反射器Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API。 Reflect 对象的方法与 Proxy 对象的方法一一对应，只是 Reflect 不用 new 12Reflect.get(target, key) &#123;&#125;Reflect.set(target, key, value) &#123;&#125; Reflect 对象的设计目的有这样几个。 将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。也就是说，从 Reflect 对象上可以拿到语言内部的方法。 修改某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false。 12345&#x2F;&#x2F; 老写法&#39;assign&#39; in Object &#x2F;&#x2F; true&#x2F;&#x2F; 新写法Reflect.has(Object, &#39;assign&#39;) &#x2F;&#x2F; true Decorator 装饰器Decorator 是一个函数，用来修改类的行为。许多面向对象的语言都有修饰器的特性，如 Java 的注解机制。 目前，该功能还是一个提案。可以使用一个 babel 插件来让 babel 支持 Decorator 函数，并设置 .babelrc 1npm i babel-plugin-transform-decorators-legacy --save-dev 12345678&#123; &quot;presets&quot;: [ &quot;es2015&quot; ], &quot;plugins&quot;: [ &quot;babel-plugin-transform-decorators-legacy&quot; ]&#125; 实例：使用 Decorator 函数限制某个属性是只读的12345678910111213141516171819202122232425&#x2F;** * 实例：使用 Decorator 函数限制某个属性是只读的 * @param &#123;*&#125; target 修改的类 * @param &#123;*&#125; name 修改的类的属性 * @param &#123;*&#125; descriptor 该属性的描述对象 *&#x2F;let readOnly &#x3D; (target, name, descriptor) &#x3D;&gt; &#123; descriptor.writable &#x3D; false; return descriptor;&#125;class Test &#123; @readOnly say() &#123; console.log(&quot;hello&quot;); &#125;&#125;let t &#x3D; new Test();t.say();&#x2F;&#x2F; hellot.say &#x3D; () &#x3D;&gt; &#123; console.log(&quot;hello2&quot;); &#125;&#x2F;&#x2F; Uncaught TypeError: Cannot assign to read only property &#39;say&#39; of object &#39;#&lt;Test&gt;&#39; 实例：使用 Decorator 函数实现前端埋点将埋点逻辑与业务逻辑解耦 123456789101112131415161718192021222324252627282930313233&#x2F;** * 实例：使用 Decorator 函数实现前端日志埋点 * @param &#123;*&#125; target 修改的类 * @param &#123;*&#125; name 修改的类的属性 * @param &#123;*&#125; descriptor 该属性的描述对象 *&#x2F;let logBurying &#x3D; (type) &#x3D;&gt; &#123; return (target, name, descriptor) &#x3D;&gt; &#123; let originMethod &#x3D; descriptor.value; &#x2F;&#x2F; 原始函数体 descriptor.value &#x3D; (...args) &#x3D;&gt; &#123; originMethod.apply(target, args); console.info(&#96;logBurying $&#123;type&#125;&#96;); &#x2F;&#x2F; 模拟埋点 &#125; &#125;&#125;class AD &#123; @logBurying(&quot;show&quot;) show() &#123; console.log(&quot;show&quot;); &#125; @logBurying(&quot;click&quot;) click() &#123; console.log(&quot;click&quot;); &#125;&#125;let t &#x3D; new AD();t.show(); &#x2F;&#x2F; show, logBurying showt.click(); &#x2F;&#x2F; click, logBurying click core-decoratorscore-decorators 是一个第三方库，实现了许多实用的 Decorator 函数。 https://github.com/jayphelps/core-decorators Iterator 迭代器 ==Iterator（迭代器）的概念== JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了 Map 和 Set，这样就有了四种数据集合。 Iterator（迭代器）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员），我们就称这种数据结构是“可遍历的”（iterable）。 原生具备 Iterator 接口的数据结构如下：Array、Map、Set、String、TypedArray、函数的 arguments 对象、NodeList 对象 123456789101112131415161718192021&#x2F;&#x2F; 字符串let str &#x3D; &quot;hello&quot;;for (let s of str) &#123; console.log(s); &#x2F;&#x2F; h e l l o&#125;&#x2F;&#x2F; DOM NodeList对象let paras &#x3D; document.querySelectorAll(&quot;p&quot;);for (let p of paras) &#123; p.classList.add(&quot;test&quot;);&#125;&#x2F;&#x2F; arguments对象function printArgs() &#123; for (let x of arguments) &#123; console.log(x); &#125;&#125;printArgs(&#39;a&#39;, &#39;b&#39;);&#x2F;&#x2F; &#39;a&#39;&#x2F;&#x2F; &#39;b&#39; 扩展运算符会默认调用 Iterator 接口，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。 12345678&#x2F;&#x2F; 例一var str &#x3D; &#39;hello&#39;;[...str] &#x2F;&#x2F; [&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;]&#x2F;&#x2F; 例二let arr &#x3D; [&#39;b&#39;, &#39;c&#39;];[&#39;a&#39;, ...arr, &#39;d&#39;]&#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费。Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即 for…of 循环 12345const arr &#x3D; [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;];for(let v of arr) &#123; console.log(v); &#x2F;&#x2F; red green blue&#125; for…of 循环可以代替数组实例的 forEach 方法。 12345678910const arr &#x3D; [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;];for(let v of arr) &#123; console.log(v); &#x2F;&#x2F; red green blue&#125;arr.forEach(function (element, index) &#123; console.log(element); &#x2F;&#x2F; red green blue console.log(index); &#x2F;&#x2F; 0 1 2&#125;); Promise 对象 参考《前端通讯——异步编程 · 解决方案》 Generator 状态机 参考《前端通讯——异步编程 · 解决方案》 async/await 参考《前端通讯——异步编程 · 解决方案》 Class 类 参考《JavaScript 面向对象》 Module 模块化 参考前端模块化","tags":[{"name":"HTML","slug":"HTML","permalink":"https://bxm0927.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://bxm0927.github.io/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://bxm0927.github.io/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://bxm0927.github.io/tags/ES6/"}]},{"title":"ES6 学习笔记（上）","date":"2019-04-15T14:43:29.000Z","path":"2019/04/15/blog/","text":"字符串的扩展ES6 加强了对 Unicode 的支持，并且扩展了 String 字符串对象，解决了 ES5 在字符串功能上的痛点。 最佳实践：静态字符串一律使用单引号，不使用双引号。动态字符串使用模板字符串。 模板字符串模板字符串第一个用途：字符串拼接。将表达式嵌入字符串中进行拼接，用 ``和\\${}来界定。这使得事情变得更简单，代码更容易阅读。你可以在花括号内放置任何东西：变量、方程式或函数调用。 1234567&#x2F;&#x2F; es5var name1 &#x3D; &quot;bai&quot;;console.log(&#39;hello &#39; + name1);&#x2F;&#x2F; es6const name2 &#x3D; &quot;ming&quot;;console.log(&#96;hello $&#123;name2&#125;&#96;); 模板字符串第二个用途：在 ES5 时我们通过反斜杠来做多行字符串拼接。ES6 模板字符串直接搞定。 12345678&#x2F;&#x2F; es5var msg &#x3D; &quot;Hi \\man!&quot;;&#x2F;&#x2F; es6const template &#x3D; &#96;&lt;div&gt; &lt;span&gt;hello world&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&#96;; 模板字符串之中还能调用函数： 12345function fn() &#123; return &quot;Hello World&quot;;&#125;console.log(&#96;输出值为：$&#123;fn()&#125;&#96;) &#x2F;&#x2F; &quot;输出值为：Hello World&quot; 字符串扩展方法传统上，JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 includes()：返回布尔值，判断数组、字符串是否包含某个元素。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 includes() 可以代替 indexOf()，endsWith() 可以用来检测文件后缀 1234567891011121314151617&#x2F;&#x2F; includes: 判断是否包含然后返回布尔值&#39;hahah&#39;.includes(&#39;y&#39;) &#x2F;&#x2F; false[&#39;1&#39;,&#39;y&#39;].includes(&#39;y&#39;) &#x2F;&#x2F; true&#x2F;&#x2F; ES5 indexOflet arr &#x3D; [&#39;react&#39;, &#39;angular&#39;, &#39;vue&#39;];if (arr.indexOf(&#39;react&#39;) !&#x3D;&#x3D; -1) &#123; console.log(&#39;React存在&#39;);&#125;&#x2F;&#x2F; ES6 includeslet arr &#x3D; [&#39;react&#39;, &#39;angular&#39;, &#39;vue&#39;];if (arr.includes(&#39;react&#39;)) &#123; console.log(&#39;React存在&#39;);&#125; 1234567891011121314151617181920212223242526&#x2F;&#x2F; repeat: 字符串重复n次console.log(&#39;he&#39;.repeat(3)); &#x2F;&#x2F; &#39;hehehe&#39;&#x2F;&#x2F; 开始字符console.log(&#39;abcd&#39;.startsWith(&#39;aa&#39;)); &#x2F;&#x2F; false&#x2F;&#x2F; 结束字符console.log(&#39;abcd&#39;.endsWith(&#39;cd&#39;)); &#x2F;&#x2F; true&#x2F;&#x2F; padStart、padEnd 长度不足就补let date &#x3D; new Date();let month &#x3D; date.getMonth() + 1;console.log(month.toString().padStart(2, &#39;0&#39;)); &#x2F;&#x2F; 06console.log(&#39;123&#39;.padStart(11, &#39;0&#39;)); &#x2F;&#x2F; 00000000123console.log(&#39;123&#39;.padEnd(11, &#39;0&#39;)); &#x2F;&#x2F; 12300000000&#x2F;&#x2F; padStart ES5实现padStart(num, n &#x3D; 2, str &#x3D; &#39;0&#39;) &#123; let len &#x3D; num.toString().length while (len &lt; n) &#123; num &#x3D; str + num len++ &#125; return num&#125; 正则的扩展y 修饰符y 修饰符的作用与 g 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配必须从剩余的第一个位置开始 12345let s&#x3D; &#39;bbb_bb_b&#39;;let reg1 &#x3D; &#x2F;b+&#x2F;g;let reg2 &#x3D; &#x2F;b+&#x2F;y;console.log(reg1.exec(s), reg2.exec(s)); &#x2F;&#x2F; [&quot;bbb&quot;, index: 0, input: &quot;bbb_bb_b&quot;] [&quot;bbb&quot;, index: 0, input: &quot;bbb_bb_b&quot;]console.log(reg1.exec(s), reg2.exec(s)); &#x2F;&#x2F; [&quot;bb&quot;, index: 4, input: &quot;bbb_bb_b&quot;] null u 修饰符含义为“Unicode 模式”，用来正确处理大于\\uFFFF 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 12&#x2F;^\\uD83D&#x2F;u.test(&#39;\\uD83D\\uDC2A&#39;) &#x2F;&#x2F; false&#x2F;^\\uD83D&#x2F;.test(&#39;\\uD83D\\uDC2A&#39;) &#x2F;&#x2F; true s 修饰符dotAll 模式 数值的扩展Number 新增数值方法注意 Number.isFinite() 和 Number.isNaN() 与传统的全局方法 isFinite() 和 isNaN() 的区别。 123456789&#x2F;&#x2F; isFinite: 判断一个数值是否是有尽的console.log(Number.isFinite(100)); &#x2F;&#x2F; trueconsole.log(Number.isFinite(100 &#x2F; 0)); &#x2F;&#x2F; falseconsole.log(Number.isFinite(NaN)); &#x2F;&#x2F; false&#x2F;&#x2F; isNaN: 判断一个数值是否是一个非数值console.log(Number.isNaN(NaN)); &#x2F;&#x2F; trueconsole.log(Number.isNaN(100)); &#x2F;&#x2F; falseconsole.log(Number.isNaN(100 &#x2F; 0)); &#x2F;&#x2F; false Number.parseInt(), Number.parseFloat() ES6 将全局方法 parseInt() 和 parseFloat()，移植到 Number 对象上面，行为完全保持不变。 Number.isInteger()：用来判断一个数值是否为整数 1234&#x2F;&#x2F; isInteger: 判断一个数值是否是一个整数console.log(Number.isInteger(100)); &#x2F;&#x2F; trueconsole.log(Number.isInteger(100.0)); &#x2F;&#x2F; trueconsole.log(Number.isInteger(100.5)); &#x2F;&#x2F; false Math 新增数学方法ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。 Math.trunc 方法用于去除一个数的小数部分，返回整数部分。 Math.sign 方法用来判断一个数到底是正数、负数、还是零。 Math.cbrt 方法用于计算一个数的立方根。 Math.hypot 方法返回所有参数的平方和的平方根。 ES6 新增了 4 个对数相关方法。 ES6 新增了 6 个双曲函数方法。 12345678910&#x2F;&#x2F; trunc: 返回整数部分console.log(Math.trunc(4)); &#x2F;&#x2F; 4console.log(Math.trunc(4.1)); &#x2F;&#x2F; 4console.log(Math.trunc(-1.9)); &#x2F;&#x2F; -1&#x2F;&#x2F; 返回数值符号console.log(Math.sign(-5)); &#x2F;&#x2F; -1console.log(Math.sign(0)); &#x2F;&#x2F; 0console.log(Math.sign(5)); &#x2F;&#x2F; 1console.log(Math.sign(&#39;abc&#39;)); &#x2F;&#x2F; NaN 指数运算符ES2016 新增了一个指数运算符（**），类似 Math.pow 12345&#x2F;&#x2F; ES5Math.pow(2, 3) &#x2F;&#x2F; 8&#x2F;&#x2F; ES62 ** 3 &#x2F;&#x2F; 8 指数运算符可以与赋值运算符结合，形成一个新的赋值运算符（**=）。 1234567let a &#x3D; 1.5;a **&#x3D; 2;&#x2F;&#x2F; 等同于 a &#x3D; a * a;let b &#x3D; 4;b **&#x3D; 3;&#x2F;&#x2F; 等同于 b &#x3D; b * b * b; 数组的扩展扩展运算符扩展运算符是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 ==rest 参数可以理解为聚拢，扩展运算符可以理解为“展开”==。 12345function foo(...args) &#123; console.log(...args);&#125;foo(1, 2, 3); &#x2F;&#x2F; 1, 2, 3 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 1const [first, ...rest] &#x3D; [1, 2, 3, 4, 5]; 用途：数组合并的新写法 123456789const arr1 = ['a', 'b']const arr2 = ['c']const arr3 = ['d', 'e']// ES5 的合并数组arr1.concat(arr2, arr3) // [ 'a', 'b', 'c', 'd', 'e' ]// ES6 的合并数组;[...arr1, ...arr2, ...arr3] // [ 'a', 'b', 'c', 'd', 'e' ] 用途：复制数组的新写法 1234567891011const a1 &#x3D; [1, 2];&#x2F;&#x2F; 写法一const a2 &#x3D; [...a1];a2[0] &#x3D; 2;a1 &#x2F;&#x2F; [1, 2]&#x2F;&#x2F; 写法二const [...a2] &#x3D; a1;a2[0] &#x3D; 2;a1 &#x2F;&#x2F; [1, 2] 用途：获取数组除了某几项的其他项 123let num &#x3D; [1, 3, 5, 7, 9];let [first, second, ...rest] &#x3D; num;rest; &#x2F;&#x2F; [5, 7, 9] 用途：函数调用 123456function add(x, y) &#123; return x + y;&#125;var numbers &#x3D; [4, 38];add(...numbers) &#x2F;&#x2F; 42 数组扩展方法Array.from 方法用于将两类对象转为真正的数组： 类似数组的对象（如 String、NodeList、arguments），所谓类似数组的对象，本质特征只有一点，即必须有 length 属性。 可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 123456789101112let arrayLike = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3,&#125;// ES5的写法var arr1 = [].slice.call(arrayLike) // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike) // ['a', 'b', 'c'] Array.of 方法用于将一组值，转换为数组。Array.of 基本上可以用来替代 Array()或 new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。 12console.log(Array.of()); &#x2F;&#x2F; []console.log(Array.of(1, 3, 5, 7, 9)); &#x2F;&#x2F; [1, 3, 5, 7, 9] 数组实例的 find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined 数组实例的 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 12console.log([1, 4, -5, -1, 10].find((n) &#x3D;&gt; n &lt; 0)); &#x2F;&#x2F; -5console.log([1, 4, -5, -1, 10].findIndex((n) &#x3D;&gt; n &lt; 0)); &#x2F;&#x2F; 2 fill 方法使用给定值，填充一个数组。常用于空数组的初始化。 12console.log([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)); &#x2F;&#x2F; [7, 7, 7]console.log(new Array(3).fill(7)); &#x2F;&#x2F; [7, 7, 7] entries()，keys()和 values()——用于遍历数组，它们都返回一个遍历器对象。keys()是对键名（索引）的遍历、values()是对键值的遍历，entries()是对键值对的遍历。可以配合 for…of 循环进行遍历。 1234567891011for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) &#123; console.log(index); &#x2F;&#x2F; 0 1&#125;for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) &#123; console.log(elem); &#x2F;&#x2F; a b&#125;for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) &#123; console.log(index, elem); &#x2F;&#x2F; 0 &quot;a&quot; 1 &quot;b&quot;&#125; Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 includes 方法类似。 123console.log([1, 2, 3].includes(2)); &#x2F;&#x2F; trueconsole.log([1, 2, 3].includes(4)); &#x2F;&#x2F; falseconsole.log([1, 2, NaN].includes(NaN)); &#x2F;&#x2F; true Array.prototype.flat 方法用于将嵌套的数组“拉平”，变成一维的数组。 对象的扩展对象属性的简洁表示法ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 1234567891011121314151617181920212223&#x2F;&#x2F; ES5var o &#x3D; 1, k &#x3D; 2;var obj1 &#x3D; &#123; o: o, k: k, name: &#39;bxm&#39;, getName: function() &#123; console.log(this.name); &#125;&#125;;&#x2F;&#x2F; ES6let c &#x3D; 1, n &#x3D; 2;let obj2 &#x3D; &#123; c, &#x2F;&#x2F; 等同于 c: c n, name: &#39;bai&#39;, getName() &#123; &#x2F;&#x2F; 等同于 getName: function() &#123;&#125; console.log(this.name); &#125;&#125;; 用途： 用于函数的返回值 CommonJS 模块、ES6 模块输出一组变量 12345function getPoint() &#123; const x &#x3D; 1; const y &#x3D; 10; return &#123;x, y&#125;;&#125; 1module.exports &#x3D; &#123; getItem, setItem, clear &#125;; 属性表达式现在，对象的属性可以是一个变量或表达式 1234567891011for (let i = 0; i &lt; 5; i++) &#123; let obj = &#123; [i]: 'value', &#125; console.log(obj)&#125;// Object &#123;0: \"value\"&#125;// Object &#123;1: \"value\"&#125;// Object &#123;2: \"value\"&#125;// Object &#123;3: \"value\"&#125;// Object &#123;4: \"value\"&#125; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。 12345678910111213// badconst obj = &#123; id: 5, name: 'San Francisco',&#125;obj[getKey('enabled')] = true// goodconst obj = &#123; id: 5, name: 'San Francisco', [getKey('enabled')]: true,&#125; 对象遍历Object.keys()，Object.values()，Object.entries() Object.assign()Object.assign() 又叫做==浅拷贝==，用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign() 的第一个参数是目标对象，后面的参数都是源对象。 1Object.assign(&#123; a: '1' &#125;, &#123; b: '2' &#125;) // Object &#123;a: \"1\", b: \"2\"&#125; 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 123456const target = &#123; a: 1 &#125;const source1 = &#123; b: 2 &#125;const source2 = &#123; c: 3 &#125;Object.assign(target, source1, source2)target // &#123;a:1, b:2, c:3&#125; 最佳实践：在实际项目中，我们为了不改变源对象，一般会把目标对象传为{} 1234const obj = Object.assign(&#123;&#125;, objA, objB)// 给对象添加属性this.seller = Object.assign(&#123;&#125;, this.seller, response.data) 小技巧：扩展运算符也可以实现 Object.assign() 的功能： 1234567let aClone = &#123; ...a &#125;// 等同于let aClone = Object.assign(&#123;&#125;, a)let ab = &#123; ...a, ...b &#125;// 等同于let ab = Object.assign(&#123;&#125;, a, b) 用途： ==为属性指定默认值，然后用来覆盖默认的配置选项（config）== 为对象添加属性和方法 合并多个对象 对象浅克隆 1options = Object.assign(&#123;&#125;, defaultConfig, options) Object.getOwnPropertyDescriptors()ES2017 返回指定对象的某个指定属性的属性描述符，该属性必须是对象自己定义而不是继承自原型链 Object.getOwnPropertyDescriptors()相当于Object.getOwnPropertyDescriptor()的复数形式，可以获取对象的所有自身属性的描述符 123456789101112131415[object Object] &#123; configurable：当该值为true时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。 enumerable：当且仅当该属性的 enumerable 为 true时，该属性才能够出现在对象的枚举属性中。默认为 false。 value writable get set&#125;[object Object] &#123; configurable: true, enumerable: true, value: [&quot;React Quickly&quot;], writable:&#125; 函数的扩展函数参数的默认值ES5 给函数定义参数默认值，使用的是短路运算，有一定缺陷和冗余。 12345678910&#x2F;&#x2F; ES5function foo(num) &#123; num &#x3D; num || 200; return num;&#125;&#x2F;&#x2F; ES6function foo(num &#x3D; 200) &#123; return num;&#125; 参数默认值可以与解构赋值的默认值，结合起来使用。 12345function foo(&#123;x, y &#x3D; 5&#125; &#x3D; &#123;&#125;) &#123; console.log(x, y);&#125;foo() &#x2F;&#x2F; undefined 5 通常情况下，默认值后面不能再有没有默认值的参数，即定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 另外，可以将参数默认值设为 undefined，表明这个参数是可以省略的。 1function foo(optional &#x3D; undefined) &#123; ··· &#125; rest 参数ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 1234function rest(...args) &#123; console.log(args); &#125;rest(); &#x2F;&#x2F; []rest(1); &#x2F;&#x2F; [1]rest(1,2); &#x2F;&#x2F; [1, 2] 1234function foo(x, y, ...rest) &#123; return ((x + y) * rest.length);&#125;foo(1, 2, &#39;hello&#39;, true, 7); &#x2F;&#x2F; 9 最佳实践：不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。 12345678910&#x2F;&#x2F; badfunction concatenateAll() &#123; const args &#x3D; Array.prototype.slice.call(arguments); return args.join(&#39;&#39;);&#125;&#x2F;&#x2F; goodfunction concatenateAll(...args) &#123; return args.join(&#39;&#39;);&#125; 箭头函数ES6 允许使用“箭头”（=&gt;）定义函数，箭头函数是函数的快捷写法，使得表达更加简洁，有以下特性。 不需要 function 关键字来创建函数 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分； 而当你的函数有且仅有一个参数的时候，是可以省略掉括号()的 当你函数中有且仅有一个表达式的时候，可以省略return语句和大括号{}； 而如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。 123456789101112131415&#x2F;&#x2F; ES5var arr1 &#x3D; [1, 2, 3];var newArr1 &#x3D; arr1.map(function(x) &#123; return x + 1; &#125;);&#x2F;&#x2F; ES6let arr2 &#x3D; [1, 2, 3];let newArr2 &#x3D; arr2.map((x) &#x3D;&gt; &#123; x + 1 &#125;);&#x2F;&#x2F; 箭头函数使得表达更加简洁let isEven &#x3D; n &#x3D;&gt; n % 2 &#x3D;&#x3D; 0;let square &#x3D; n &#x3D;&gt; n * n;let f &#x3D; () &#x3D;&gt; 5; &#x2F;&#x2F; 等同于 let f &#x3D; function () &#123; return 5 &#125;;let f &#x3D; v &#x3D;&gt; v; &#x2F;&#x2F; 等同于 let f &#x3D; function (v) &#123; return v; &#125;;let sum &#x3D; (num1, num2) &#x3D;&gt; num1 + num2; &#x2F;&#x2F; 等同于 let sum &#x3D; function(num1, num2) &#123; return num1 + num2; &#125;;[1,2,3].map(x &#x3D;&gt; x * x); &#x2F;&#x2F; 等同于 [1,2,3].map(function (x) &#123; return x * x; &#125;); 立即执行函数可以写成箭头函数的形式。 123(() &#x3D;&gt; &#123; console.log(&#39;Welcome to the Internet.&#39;);&#125;)(); 箭头函数中的 this 绑定箭头函数让复杂的 this 变得清晰： ==箭头函数内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。即，this 对象的指向是可变的，但是在箭头函数中，它是固定的。== 箭头函数中的 this 继承当前上下文的 this 关键字，即箭头函数中 this 的作用域和外面是一样的，==并不产生新的作用域==。 本质上，箭头函数里面根本没有自己的 this，而是引用外层的 this。 箭头函数可以绑定 this 对象，大大减少了显式绑定 this 对象的写法（call、apply、bind）。 箭头函数取代 Function.prototype.bind，不应再用 self/_this/that 绑定 this。 1234567891011121314151617181920212223242526272829303132333435363738&#x2F;&#x2F; 。运行下面的代码会报错，这是因为setTimeout中的this指向的是全局对象。class Animal &#123; constructor() &#123; this.type &#x3D; &#39;animal&#39;; &#125; says(say) &#123; setTimeout(function() &#123; console.log(this.type + &#39; says &#39; + say); &#125;, 1000); &#125;&#125;var animal &#x3D; new Animal();animal.says(&#39;hi&#39;); &#x2F;&#x2F;undefined says hi&#x2F;&#x2F; 解决办法：&#x2F;&#x2F; 传统方法1: 将this传给self,再用self来指代thissays(say) &#123; var self &#x3D; this; setTimeout(function() &#123; console.log(self.type + &#39; says &#39; + say); &#125;, 1000);&#125;&#x2F;&#x2F; 传统方法2: 用bind(this),即says(say) &#123; setTimeout(function() &#123; console.log(this.type + &#39; says &#39; + say); &#125;.bind(this), 1000);&#125;&#x2F;&#x2F; ES6: 箭头函数says(say) &#123; setTimeout(() &#x3D;&gt; &#123; console.log(this.type + &#39; says &#39; + say); &#125;, 1000);&#125; 函数参数的尾逗号现在，函数参数与数组和对象的尾逗号规则，保持一致了。函数定义和调用时，尾部允许有一个逗号。这样可以避免一些不必要的报错。 123456789function clownsEverywhere( param1, param2) &#123; &#x2F;* ... *&#x2F; &#125;clownsEverywhere( &#39;foo&#39;, &#39;bar&#39;); 编程风格：单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾，方便扩展。 12345678910111213// badconst a = &#123; k1: v1, k2: v2 &#125;const b = &#123; k1: v1, k2: v2,&#125;// goodconst a = &#123; k1: v1, k2: v2 &#125;const b = &#123; k1: v1, k2: v2,&#125; 尾调用优化递归性能","tags":[{"name":"HTML","slug":"HTML","permalink":"https://bxm0927.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://bxm0927.github.io/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://bxm0927.github.io/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://bxm0927.github.io/tags/ES6/"}]},{"title":"ES6 学习笔记（中）","date":"2019-04-13T15:46:21.000Z","path":"2019/04/13/blog/","text":"ECMAScript 简介ECMAScript 是一种由 ECMA 国际的组织（European Computer Manufacturers Association，欧洲计算机制造商协会），通过 ECMA-262 标准化的脚本程序设计语言。而 JavaScript 是 ECMA-262 标准的实现和扩展。浏览器为 JavaScript 增加了 DOM 和 BOM 功能。 ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。 ECMA-262 规定了 ECMAScript 语言的几个重要组成部分： 基本语法 数据类型 语句 关键字 操作符 内置对象 image ECMAScript 版本ECMAScript 3 是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript 语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习 JavaScript，其实就是在学 3.0 版的语法。 ECMAScript 6 从开始制定到最后发布，整整用了 15 年。 版本号 发布时间 内容 ECMAScript 1 1997 年 06 月 首版 ECMAScript 2 1998 年 6 月 格式修正，以使得其形式与 ISO/IEC16262 国际标准一致 ECMAScript 3 1999 年 12 月 正则表达式，新的控制指令，异常处理，错误定义更加明确及其它改变 ECMAScript 4 2007 年 10 月 由于过于激进，各方对于是否通过这个标准，发生了严重分歧，最终没有发布通过。 ECMAScript 5 2009 年 12 月 和第 3 版标准不大，引进了一些夭折的 ECMAScript 4 的一些功能 ECMAscript 5.1 2011 年 6 月 成为 ISO 国际标准（ISO/IEC 16262:2011）。 ECMAScript 2015（ES2015、ES6） 2015 年 6 月 17 日 ECMAScript 的第六版修订，于 2015 年完成标准化。 ECMAScript 2016（ES2016） 2016 年 6 月 在 ES2015 基础上进行小幅修订 ECMAScript 2017（ES2017） 2017 年 6 月 ECMAScript 2018（ES2018） 2018 年 6 月 ECMAScript 2019（ES2019） 2019 年 6 月 ES6 与 ECMAScript 2015 的关系ES6 泛指 ES 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等。而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。 https://github.com/ruanyf/es6tutorial/blob/8240374c621ba0180b381c74c78198bf7107c433/docs/intro.md#es6-%E4%B8%8E-ecmascript-2015-%E7%9A%84%E5%85%B3%E7%B3%BB TC39ECMA 的第 39 号技术专家委员会（Technical Committee 39，简称 TC39）负责制订 ECMAScript 标准，成员包括 Microsoft、Mozilla、Google 等大公司。 TC39 是一个讨论 JavaScript 标准规范的技术委员会，已决定从 2019 年开始改变其运营结构。TC39 每年召开六次会议，规模已经发展到每次有 40 到 60 人参会的程度。 这个委员会以前是主席和副主席的运营结构，现在改为由三位联合主席（Aki Braun（PayPal）、Brian Terlson（微软）和 Yulia Startsev（Mozilla））共同负责的架构。他们还在 2019 年 3 月开设了官方网站： https://tc39.es/ https://tc39.github.io https://github.com/tc39 每一项新特性最终要进入到 ECMAScript 规范里，需要经历 5 个阶段，这 5 个阶段如下： Stage 0: Strawperson：只要是 TC39 成员或者贡献者，都可以提交想法 Stage 1: Proposal：这个阶段确定一个正式的提案 Stage 2: draft：规范的第一个版本，进入此阶段的提案大概率会成为标准 Stage 3: Candidate：进一步完善提案细则 Stage 4: Finished：表示已准备好将其添加到正式的 ECMAScript 标准 ECMAScript 6 简介 ES6 相关知识点主要以阮一峰文档为主，此篇笔记只是做一些常用功能提炼、补充说明和自己的理解。另外，有些属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。 http://es6.ruanyifeng.com/ ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，泛指 5.1 版以后的 JavaScript，涵盖了 ES2015、ES2016、ES2017 等等。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 2015 年 6 月正式发布 ECMAScript 2015（简称 ES2015） 2016 年 6 月，在 ES2015 基础上进行小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的 includes 方法和指数运算符），基本上是同一个标准。 image 常用的 ES6 新特性 let、const 解构赋值 扩展运算符（展开） rest 参数（收缩） 模版字符串 函数参数的默认值 箭头函数 对象属性的简洁表示法 Promise Class ES Module image ES6 部署Babel为了环境的兼容性，你可以使用 babel 来将 ES6 代码转为 ES5 代码。 npm WARN deprecated babel-preset-es2015@6.24.1: � Thanks for using Babel: we recommend using babel-preset-env now: please read babeljs.io/env to update!（已弃用 babel-preset-es2015，现在建议使用 babel-preset-env） 12&#x2F;&#x2F; npm install babel-preset-es2015 --save-devnpm install babel-preset-env --save-dev .babelrc： 12345678910111213141516&#123; &quot;presets&quot;: [ [&quot;env&quot;, &#123; &quot;targets&quot;: &#123; &quot;browsers&quot;: [&quot;Android &gt;&#x3D; 4.0&quot;, &quot;ios &gt;&#x3D; 6&quot;] &#125;, &quot;include&quot;: [], &quot;useBuiltIns&quot;: true &#125;] ], &quot;plugins&quot;: [ [&quot;lodash&quot;], [&quot;transform-object-rest-spread&quot;], [&quot;component&quot;, &#123; &quot;libraryName&quot;: &quot;mint-ui&quot;, &quot;style&quot;: true &#125;] ]&#125; let 和 const 命令ES6 提出了两个新的声明变量的命令：let和const，主要是为了规避使用var定义变量时的副作用（变量提升问题、作用域问题等），减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的设计是为了让大家养成良好的编程习惯 —— 变量一定要在声明之后使用，否则就报错。 块级作用域JavaScript 一直是函数作用域，这就是为什么将整个 JavaScript 文件包装在一个空的立即调用函数表达式（IIFE）中变得很普遍的原因。这样做是为了隔离文件中的所有变量，因此没有可变冲突。 现在，我们有块作用域和两个绑定到块的新变量声明。 ES6 带来了块级作用域，通过let和const定义的变量属于块级作用域。 123456&#123; var a &#x3D; 1; let b &#x3D; 2;&#125;console.log(a); &#x2F;&#x2F; 1console.log(b); &#x2F;&#x2F; Uncaught ReferenceError: b is not defined 注意：let和const不允许重复声明 12let v &#x3D; 1;let v &#x3D; 2; &#x2F;&#x2F; Uncaught SyntaxError: Identifier &#39;v&#39; has already been declared 注意：由let和const命令声明的变量不是顶层对象（window、global）的属性 12let a &#x3D; 1;window.a &#x3D;&#x3D;&#x3D; undefined; &#x2F;&#x2F; true letlet 完全可以取代 var，因为两者语义相同，而且 let 没有副作用（不存在变量提升问题，并且属于块级作用域）。==建议不再使用 var 命令，而是使用 let 命令取代。== 123456789&#39;use strict&#39;;if (true) &#123; let x &#x3D; &#39;hello&#39;;&#125;for (let i &#x3D; 0; i &lt; 10; i++) &#123; console.log(i);&#125; 上面代码如果用 var 替代 let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var 命令做不到这一点。 constconst 用来声明只读的常量。一旦声明，常量的值就不能改变，否则报错。 注意: const 定义的数组和对象可以被修改（不变的是指向的内存地址） 1234const k &#x3D; &#123; a: 1 &#125;;k.a &#x3D; 2;k.b &#x3D; 3;console.log(k); &#x2F;&#x2F; Object &#123;a: 2, b: 3&#125; 最佳实践： 在 let 和 const 之间，建议优先使用 const，尤其是在全局环境，不应该设置变量，只应设置常量。 所有的函数都应该设置为常量。 暂时性死区12345let a &#x3D; 1;&#123; console.log(a); &#x2F;&#x2F; Uncaught ReferenceError: a is not defined let a &#x3D; 2;&#125; ES6 声明变量的六种方法ES5 只有两种声明变量的方法：var 命令和 function 命令。 ES6 添加了 let 和 const 命令、import 命令和 class 命令。所以，ES6 一共有 6 种声明变量的方法。 var function let const import class 变量的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 变量的解构赋值简化了数组和对象中信息的提取。ES6 前，我们一个一个获取对象信息；ES6 后，解构能让我们从对象或者数组里取出数据存为变量 数组的解构赋值123456789var data &#x3D; &#123; name: &#39;dys&#39;, age: 1 &#125;;&#x2F;&#x2F; ES5var name &#x3D; data.name;var age &#x3D; data.age;&#x2F;&#x2F; ES6const &#123; name, age &#125; &#x3D; data; 其实，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 对象的解构赋值对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 12let &#123; foo, bar &#125; &#x3D; &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;let &#123; foo: foo, bar: bar &#125; &#x3D; &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;; 12345678910111213141516171819&#x2F;&#x2F; ES5var people1 &#x3D; &#123; name: &#39;bai&#39;, age: 20, color: [&#39;red&#39;, &#39;blue&#39;]&#125;;var myName &#x3D; people1.name;var myAge &#x3D; people1.age;var myColor &#x3D; people1.color[0];&#x2F;&#x2F; ES6let people2 &#x3D; &#123; name: &#39;ming&#39;, age: 20, color: [&#39;red&#39;, &#39;blue&#39;]&#125;let &#123; name, age &#125; &#x3D; people2;let [first, second] &#x3D; people2.color; 解构赋值允许指定默认值==解构赋值允许指定默认值==。注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于 undefined，默认值才会生效。 12let [x &#x3D; 1] &#x3D; [undefined]; x &#x2F;&#x2F; 1let [x &#x3D; 1] &#x3D; [null]; x &#x2F;&#x2F; null ==如果解构不成功，变量的值就等于 undefined==。 1234567let [x, y &#x3D; &#39;b&#39;] &#x3D; [&#39;a&#39;, undefined]; &#x2F;&#x2F; x&#x3D;&#39;a&#39;, y&#x3D;&#39;b&#39;let [head, ...tail] &#x3D; [1, 2, 3, 4]; &#x2F;&#x2F; head&#x3D;1, tail&#x3D;[2, 3, 4]let &#123; foo, bar &#125; &#x3D; &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;; &#x2F;&#x2F; foo&#x3D;&quot;aaa&quot;, bar&#x3D;&quot;bbb&quot;let &#123; log, sin, cos &#125; &#x3D; Math;let [a, b, c, d, e] &#x3D; &#39;hello&#39;; 解构赋值用途 交换变量的值 1234let a &#x3D; 1;let b &#x3D; 2;[b, a] &#x3D; [a, b];console.log(a, b); &#x2F;&#x2F; 2 1 从函数返回多个值，以前需要通过数组索引取值 1234567function foo() &#123; return [1, 2, 3, 4, 5, 6];&#125;let a, b, rest;[a, , , b, ...rest] &#x3D; foo();console.log(a, b, rest); &#x2F;&#x2F; 1 4 [5, 6] 提取 JSON 数据 函数参数的定义 函数参数的默认值 输入模块的指定方法 最佳实践使用数组成员对变量赋值时，优先使用解构赋值。 12345678const arr &#x3D; [1, 2, 3, 4];&#x2F;&#x2F; badconst first &#x3D; arr[0];const second &#x3D; arr[1];&#x2F;&#x2F; goodconst [first, second] &#x3D; arr; 函数的参数如果是对象的成员，优先使用解构赋值。 1234567891011121314&#x2F;&#x2F; badfunction getFullName(user) &#123; const firstName &#x3D; user.firstName; const lastName &#x3D; user.lastName;&#125;&#x2F;&#x2F; goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; &#x3D; obj;&#125;&#x2F;&#x2F; bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 1234567891011&#x2F;&#x2F; badfunction processInput(input) &#123; return [left, right, top, bottom];&#125;&#x2F;&#x2F; goodfunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; &#x3D; processInput(input);","tags":[{"name":"HTML","slug":"HTML","permalink":"https://bxm0927.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://bxm0927.github.io/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://bxm0927.github.io/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://bxm0927.github.io/tags/ES6/"}]},{"title":"聊聊布局","date":"2019-02-25T14:57:15.000Z","path":"2019/02/25/layout/","text":"image 布局方法过时的布局方法 表格布局（table） 传统的布局方法 定位（position） 浮动（float） 前沿的布局方法 弹性盒子布局（Flexible Box Layout） 网格布局（Grid Layout） 经验之谈布局可以从以下几个方面思考： 利用 float + margin 实现 利用 absolute 绝对定位实现 利用 BFC 实现 利用 Flexbox 实现 利用 Grid 实现 几个注意点： 移动端能用 Flex 就用 Flex，灵活方便并且功能强大，无愧为网页布局的一大利器！ 使用 float 时，注意要清除浮动，避免高度塌陷 避免使用老旧的 table 布局（如 display: table;、display: table-row;、display: table-cell;）。表格布局会使 margin 失效，设置间隔比较麻烦。 居中布局水平居中行内元素水平居中： 123456// 利用 text-align: center 可以将块级元素内部的行内元素水平居中。// 此方法对 inline、inline-block、inline-table 和 inline-flex 元素水平居中都有效。// 也可以将 block 元素设置成 inline-block，再用这种方式实现块级元素的水平居中.inline-x-center &#123; text-align: center;&#125; 单个块级元素水平居中： 1234567// 可通过将左和右外边距设置为 auto 来实现块级元素水平居中。// 此时需要设置宽度，如果宽度是 100%，则对齐没有效果。@mixin margin-auto-center($width: 80%) &#123; width: $width; margin-left: auto; margin-right: auto;&#125; 多个块级元素水平居中： 注意多个 inline-block 元素间空白字符 font-size 不为 0 的问题 12345678.parent &#123; text-align: center; /* font-size: 0; */&#125;.child &#123; display: inline-block;&#125; 垂直居中行内元素垂直居中： 1234.inline-y-center &#123; height: 40px; line-height: 40px;&#125; 垂直对齐一幅图像、字体图标： 1234// vertical-align 属性设置元素的垂直对齐方式，默认情况下，元素放置在父元素的基线(baseline)上。.img-y-center &#123; vertical-align: middle;&#125; 水平垂直居中 总结：一般情况下，水平垂直居中，我们最常用的就是绝对定位加负边距，缺点就是需要知道宽高，使用 transform 倒是可以不需要知道宽高，但是兼容性不好（IE9+） 高度宽度已知： 12345678910// Negative margin@mixin margin-center($width, $height) &#123; position: absolute; top: 50%; left: 50%; width: $width; height: $height; margin-left: -($width / 2); margin-top: -($height / 2);&#125; 高度宽度未知： 123456789// Transform centering// Horizontally and vertically centers a child element within a parent element using `position: absolute` and `transform: translate()`.// Similar to `flexbox`, this method does not require you to know the height or width of your parent or child so it is ideal for responsive applications..transform-center &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 1234567// Flexbox centering// Horizontally and vertically centers a child element within a parent element using `flexbox`..flexbox-center &#123; display: flex; // enables flexbox. align-items: center; // centers the child vertically. justify-content: center; // centers the child horizontally.&#125; 1234567// Grid centering// Horizontally and vertically centers a child element within a parent element using `grid`..grid-center &#123; display: grid; // enables grid. align-items: center; // centers the child vertically. justify-content: center; // centers the child horizontally.&#125; 两列布局 image 左列定宽，右列自适应 利用 float + margin 实现： 12345678.left &#123; float: left; width: 100px;&#125;.right &#123; margin-left: 120px; /* 大于等于 `.left` 的宽度 */&#125; 利用 BFC 实现： BFC（Block fomatting context）：块级元素格式化上下文，它决定了其子元素将如何定位，以及和其他元素的相互关系。 BFC 在页面上是一个独立的容器，与其他元素互不影响 12345678.left &#123; float: left; width: 100px;&#125;.right &#123; overflow: hidden; /* 触发 BFC 达到自适应 */&#125; 利用 absolute 绝对定位实现： 1234567891011121314151617.parent &#123; position: relative;&#125;.left &#123; position: absolute; top: 0; left: 0; width: 100px;&#125;.right &#123; position: absolute; top: 0; left: 100px; /* 大于等于 `.left` 的宽度 */ right: 0;&#125; 利用 Flexbox 实现： 123456789101112.parent &#123; display: flex;&#125;.left &#123; width: 100px; flex: 0 0 100px;&#125;.right &#123; flex: 1; /* 均分了父元素剩余空间 */&#125; 利用 Grid 实现： 12345.parent &#123; display: grid; grid-template-columns: 100px auto; /* 设定 2 列就 ok 了, auto 换成 1fr 也行 */ width: 100%;&#125; 左列自适应，右列定宽 利用 float + margin 实现： 123456789101112131415.parent &#123; height: 500px; padding-left: 100px; /* 抵消 left 的 margin-left 以达到 parent 水平居中 */&#125;.left &#123; float: left; margin-left: -100px; /* 正值等于 right 的宽度 */ width: 100%;&#125;.right &#123; float: right; width: 100px;&#125; 利用 BFC 实现： 123456789101112131415&lt;style&gt; .left &#123; overflow: hidden; /* 触发 BFC 达到自适应 */ &#125; .right &#123; float: right; margin-left: 10px; /* margin 需要定义在 right 上 */ width: 100px; &#125;&lt;/style&gt;&lt;!-- right 先渲染 --&gt;&lt;div id=\"right\"&gt;右列定宽&lt;/div&gt;&lt;div id=\"left\"&gt;左列自适应&lt;/div&gt; 利用 absolute 绝对定位实现： 1234567891011121314151617.parent &#123; position: relative;&#125;.left &#123; position: absolute; top: 0; left: 0; right: 100px; /* 大于等于 `.right` 的宽度 */&#125;.right &#123; position: absolute; top: 0; right: 0; width: 100px;&#125; 利用 Flexbox 实现： 123456789101112.parent &#123; display: flex;&#125;.left &#123; flex: 1; /* 均分了父元素剩余空间 */&#125;.right &#123; width: 100px; flex: 0 0 100px;&#125; 利用 Grid 实现： 12345.parent &#123; display: grid; grid-template-columns: auto 100px; /* 设定 2 列就 ok 了, auto 换成 1fr 也行 */ width: 100%;&#125; 一列不定，一列自适应 盒子宽度随着内容增加或减少发生变化，另一个盒子自适应 这里演示左列不定宽，右列自适应。左列自适应，右列不定宽同理。 利用 BFC 实现： 12345678.left &#123; float: left; /* 只设置浮动，不设宽度 */ margin-right: 10px;&#125;.right &#123; overflow: hidden; /* 触发 BFC */&#125; 利用 Flexbox 实现： 123456789101112.parent &#123; display: flex;&#125;.left &#123; /* 不设宽度 */ margin-right: 10px;&#125;.right &#123; flex: 1; /* 均分 parent 剩余的部分 */&#125; 利用 Grid 实现： 12345678.parent &#123; display: grid; grid-template-columns: auto 1fr; /* auto 和 1fr 换一下顺序就是“左列自适应，右列不定宽”了 */&#125;.left &#123; margin-right: 10px;&#125; 三列布局两列定宽，一列自适应 利用 float + margin 实现： 123456789101112131415161718.parent &#123; min-width: 310px; /* 100 + 10 + 200，防止宽度不够，子元素换行*/&#125;.left &#123; float: left; margin-right: 10px; /* left 和 center 间隔 */ width: 100px;&#125;.center &#123; float: left; width: 200px;&#125;.right &#123; margin-left: 320px; /* 等于 left 和 center 的宽度之和加上间隔，多出来的就是 right 和 center 的间隔 */&#125; 利用 BFC 实现： 12345678910111213141516171819.parent &#123; min-width: 320px; /* 防止宽度不够，子元素换行 */&#125;.left &#123; float: left; margin-right: 10px; width: 100px;&#125;.center &#123; float: left; margin-right: 10px; /* 在此定义和 right 的间隔 */ width: 200px;&#125;.right &#123; overflow: hidden;&#125; 利用 Flexbox 实现： 1234567891011121314151617.parent &#123; display: flex;&#125;.left &#123; margin-right: 10px; width: 100px;&#125;.center &#123; margin-right: 10px; width: 200px;&#125;.right &#123; flex: 1;&#125; 利用 Grid 实现： 1234.parent &#123; display: grid; grid-template-columns: 100px 200px auto; /* 设置3列，固定第一第二列的宽度，第三列 auto 或者 1fr */&#125; 左右定宽，中间自适应 image 利用 Flexbox 实现123456789101112131415.parent &#123; display: flex;&#125;.left &#123; width: 100px;&#125;.center &#123; flex: 1;&#125;.right &#123; width: 200px;&#125; 利用 absolute 绝对定位实现12345678910111213141516171819202122.parent &#123; position: relative;&#125;.left &#123; position: absolute; top: 0; left: 0; width: 100px;&#125;.center &#123; margin-left: 100px; /* 大于等于 left 的宽度，或者给 parent 添加同样大小的 padding-left */ margin-right: 200px; /* 大于等于 right 的宽度，或者给 parent 添加同样大小的 padding-right */&#125;.right &#123; position: absolute; top: 0; right: 0; width: 200px;&#125; 圣杯布局圣杯布局又叫做固比固布局，即两边固定宽度，中间自适应的三栏布局。 具体操作是三栏全部浮动，左右两栏负 margin 让其跟中间栏并排。 注意：中间栏要在放在文档流前面以优先渲染。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div class=\"grail\"&gt; &lt;!-- 中间盒子优先渲染 --&gt; &lt;div class=\"middle\"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Qui, ut.&lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .grail &#123; box-sizing: border-box; width: 100%; min-width: 1024px; height: 400px; /* 让中间自适应的盒子安全显示 */ padding: 0 300px; background-color: darkseagreen; &#125; .middle &#123; float: left; width: 100%; height: 300px; background-color: deepskyblue; &#125; .left &#123; float: left; position: relative; left: -300px; width: 300px; height: 300px; /* 左侧盒子上浮; */ margin-left: -100%; background-color: red; &#125; .right &#123; float: left; position: relative; right: -300px; width: 300px; height: 300px; /* 右侧盒子上浮 */ margin-left: -300px; background-color: red; &#125;&lt;/style&gt; 双飞翼布局事实上，圣杯布局和双飞翼布局是一回事，它们实现的都是三栏布局，但是双飞翼布局可以更好地解决中栏内容超出的情景。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div class=\"grail\"&gt; &lt;div class=\"middle-wrapper\"&gt; &lt;div class=\"middle\"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Qui, ut.&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .grail &#123; width: 100%; min-width: 1024px; height: 400px; background-color: darkseagreen; &#125; .middle-wrapper &#123; float: left; width: 100%; height: 300px; background-color: deepskyblue; &#125; .middle &#123; height: 300px; margin-left: 300px; margin-right: 300px; background-color: yellowgreen; &#125; .left &#123; float: left; width: 300px; height: 300px; margin-left: -100%; background-color: red; &#125; .right &#123; float: left; width: 300px; height: 300px; margin-left: -300px; background-color: red; &#125;&lt;/style&gt; 多列布局等宽布局 浮动等宽布局： 1234.column &#123; float: left; width: 25%; /* 100 ÷ 列数，得出百分比 */&#125; 弹性盒子等宽布局： 1234567.parent &#123; display: flex;&#125;.column &#123; flex: 1;&#125; 网格等宽布局： 1234.parent &#123; display: grid; grid-template-columns: repeat(6, 1fr); /* 6 就是列数 */&#125; 九宫格布局 image DOM结构： 1234567891011121314151617&lt;div class=\"parent\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"item\"&gt;1&lt;/div&gt; &lt;div class=\"item\"&gt;2&lt;/div&gt; &lt;div class=\"item\"&gt;3&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"item\"&gt;4&lt;/div&gt; &lt;div class=\"item\"&gt;5&lt;/div&gt; &lt;div class=\"item\"&gt;6&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"item\"&gt;7&lt;/div&gt; &lt;div class=\"item\"&gt;8&lt;/div&gt; &lt;div class=\"item\"&gt;9&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 使用 table 表格布局实现： display:table 相当于 table 标签 display:table-row 相当于 tr 标签 display:table-cell 相当于 td 标签 123456789.parent &#123; display: table;&#125;.row &#123; display: table-row;&#125;.item &#123; display: table-cell;&#125; 使用 Flex 弹性盒子布局实现： 1234567891011.parent &#123; display: flex; flex-direction: column;&#125;.row &#123; display: flex; flex: 1;&#125;.item &#123; flex: 1;&#125; 使用 Grid 网格布局实现： 12345.parent &#123; display: grid; grid-template-columns: repeat(3, 1fr); /* 等同于 1fr 1fr 1fr，此为重复的合并写法 */ grid-template-rows: repeat(3, 1fr); /* 等同于 1fr 1fr 1fr，此为重复的合并写法 */&#125; 栅格系统12345678910111213141516171819202122232425262728293031323334@media screen and (max-width: 768px) &#123; .column-xs-1 &#123; width: 8.33333333%; &#125; .column-xs-2 &#123; width: 16.66666667%; &#125; .column-xs-3 &#123; width: 25%; &#125; .column-xs-4 &#123; width: 33.33333333%; &#125; .column-xs-5 &#123; width: 41.66666667%; &#125; .column-xs-6 &#123; width: 50%; &#125; .column-xs-7 &#123; width: 58.33333333%; &#125; .column-xs-8 &#123; width: 66.66666667%; &#125; .column-xs-9 &#123; width: 75%; &#125; .column-xs-10 &#123; width: 83.33333333%; &#125; .column-xs-11 &#123; width: 91.66666667%; &#125; .column-xs-12 &#123; width: 100%; &#125;&#125;@media screen and (min-width: 768px) &#123; .column-sm-1 &#123; width: 8.33333333%; &#125; .column-sm-2 &#123; width: 16.66666667%; &#125; .column-sm-3 &#123; width: 25%; &#125; .column-sm-4 &#123; width: 33.33333333%; &#125; .column-sm-5 &#123; width: 41.66666667%; &#125; .column-sm-6 &#123; width: 50%; &#125; .column-sm-7 &#123; width: 58.33333333%; &#125; .column-sm-8 &#123; width: 66.66666667%; &#125; .column-sm-9 &#123; width: 75%; &#125; .column-sm-10 &#123; width: 83.33333333%; &#125; .column-sm-11 &#123; width: 91.66666667%; &#125; .column-sm-12 &#123; width: 100%; &#125;&#125;div[class^=\"column-xs-\"]&#123; float: left;&#125;div[class^=\"column-sm-\"]&#123; float: left;&#125; 滚动场景横向滚动：overflow-x: auto; 纵向滚动：overflow-y: auto; 横向、纵向滚动：overflow: auto; 更复杂的滚动场景可以借助第三方库实现，如 better-scroll","tags":[{"name":"HTML","slug":"HTML","permalink":"https://bxm0927.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://bxm0927.github.io/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://bxm0927.github.io/tags/JavaScript/"},{"name":"Layout","slug":"Layout","permalink":"https://bxm0927.github.io/tags/Layout/"}]},{"title":"Java 文件 I/O 流详细解读","date":"2018-07-11T13:31:05.000Z","path":"2018/07/11/Java-io/","text":"I/O 概述利用 Java 的 I/O（input/output，输入和输出）技术可以将数据保存到文本文件、二进制文件甚至是压缩包之中，以达到永久性保存数据的要求。I/O 通常使用“流”的方式进行数据传输，一个流必须有源和目的地，他们通常是磁盘文件，但也可以是键盘、鼠标、显示器、内存甚至是网络等设备。 Java 语言定义了许多类专门负责各种形式的输入和输出，这些类被放在java.io包中，他们根据数据形态可分为：流式部分和非流式部分。 Java I/O 机制提供了一套简单的标准化 API，以方便从不同的数据源读取和写入字符数据或字节数据。 非流式部分File 类文件自身操作类，是 java.io 包中唯一一个与文件本身有关的操作类。File 类用于处理文件和文件系统，如创建、删除、重命名文件等操作，以路径名的形式代表一个文件。 File 类的构造方法： 123File(String filePath) &#x2F;&#x2F; 创建指定文件路径的 File 对象File(String filePath, String fileName) &#x2F;&#x2F; 创建指定文件路径和指定文件名的 File 对象File(File dirObj, String fileName) 123File f1 &#x3D; new File(&quot;&#x2F;&quot;);File f2 &#x3D; new File(&quot;&#x2F;&quot;, &quot;a.txt&quot;);File f3 &#x3D; new File(f1, &quot;a.txt&quot;); 注意： File 类不支持文件内容的读写操作。 路径（filePath）分为相对路径和绝对路径，相对路径是相对于项目根目录而言的。 File 类常用方法 文件路径分隔符：/、\\\\或File.separator 方法 描述 length() 文件的长度（字节 Byte） getName() 返回文件名 getParent() 返回父目录名 exists() 判断文件（或目录）是否存在 canRead() 判断文件是否可读 canWrite() 判断文件是否可写 isFile() 是否是一个文件 delete() 删除文件 getPath() 返回相对路径 getAbsolutePath() 返回绝对路径 getCanonicalPath() 返回路径名的规范格式？？ isDirectory() 是否是目录 isAbsolute() 是否是绝对路径名 isHidden() 是否是隐藏文件 lastModified() 最后修改时间 list()、list(filter) 返回当前目录下的文件和目录的列表（String[]） listFiles() 返回直接子目录(文件)的抽象 createNewFile() 创建文件 mkdir() 创建单级目录 mkdirs() 创建多级目录 renameTo() 重命名 12345678910111213141516171819202122232425File f1 &#x3D; new File(&quot;e:&quot; + File.separator + &quot;test.txt&quot;);if (f1.exists()) &#123; f1.delete(); System.out.println(&quot;文件删除成功&quot;);&#125; else &#123; try &#123; f1.createNewFile(); System.out.println(&quot;文件创建成功&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;System.out.println(f1.getName()); &#x2F;&#x2F; test.txtSystem.out.println(f1.getPath()); &#x2F;&#x2F; e:\\test.txtSystem.out.println(f1.getAbsolutePath()); &#x2F;&#x2F; e:\\test.txtSystem.out.println(f1.getParent()); &#x2F;&#x2F; e:\\System.out.println(f1.canRead()); &#x2F;&#x2F; trueSystem.out.println(f1.canWrite()); &#x2F;&#x2F; trueSystem.out.println(f1.isDirectory()); &#x2F;&#x2F; falseSystem.out.println(f1.isFile()); &#x2F;&#x2F; trueSystem.out.println(f1.isAbsolute()); &#x2F;&#x2F; trueSystem.out.println(f1.lastModified()); &#x2F;&#x2F; 1519556856932System.out.println(f1.length() + &quot;Byte&quot;); &#x2F;&#x2F; 0Byte RandomAccessFile 类文件随机访问类，即可以跳转到文件的任意位置处进行读写操作。RandomAccessFile 对象有一个位置指示器，指向当前读写处的位置。该类仅限于操作文件，不能访问其他 IO 设备，如网络、内存映象等等。 RandomAccessFile 类的构造方法： 12RandomAccessFile(File file, String mode) &#x2F;&#x2F; 创建一个随机访问文件流，文件属性由 File 参数指定RandomAccessFile(String name, String mode) &#x2F;&#x2F; 创建一个随机访问文件流，文件名由 name 参数指定 mode 决定了随机访问文件流的操作模式： value meaning r read，以只读方式打开，调用该对象的任何写方法都会导致 IOException 异常 rw read-write，以读、写方式打开，若文件不存在，则创建之 rws read-write-synchronized，以读、写方式打开，且文件内容同步更新 rwd 类似 rws RandomAccessFile 类常用方法 方法 描述 close() 关闭此随机访问文件流 length() 返回此文件的长度 read() 从这个文件读取一个字节的数据 write(byte[] b) 写 b.length 字节到文件中 getFilePointer() 返回此文件中的当前偏移量（位置指示器） seek(long pos) 设置文件指针偏移量（位置指示器） skipBytes(int n) 跳过指定字节 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.io.File;import java.io.RandomAccessFile;&#x2F;&#x2F; 向文件中写入三个员工的信息，并读出public class Test &#123; public static void main(String[] args) throws Exception &#123; Employee person1 &#x3D; new Employee(&quot;zhangsan&quot;, 18); Employee person2 &#x3D; new Employee(&quot;lisi&quot;, 20); File file &#x3D; new File(&quot;C:&#x2F;Users&#x2F;bxm09&#x2F;Desktop&#x2F;test.txt&quot;); if (file.exists()) &#123; file.delete(); &#125; RandomAccessFile f1 &#x3D; new RandomAccessFile(&quot;C:&#x2F;Users&#x2F;bxm09&#x2F;Desktop&#x2F;test.txt&quot;, &quot;rw&quot;); f1.write(person1.name.getBytes()); f1.writeInt(person1.age); f1.write(person2.name.getBytes()); f1.writeInt(person2.age); f1.close(); RandomAccessFile f2 &#x3D; new RandomAccessFile(&quot;C:&#x2F;Users&#x2F;bxm09&#x2F;Desktop&#x2F;test.txt&quot;, &quot;r&quot;); System.out.println(&quot;第 2 个员工的信息：&quot;); f2.skipBytes(12); &#x2F;&#x2F; 跳过指定字节 String p1Name &#x3D; &quot;&quot;; for (int i &#x3D; 0; i &lt; 8; i++) &#123; p1Name +&#x3D; (char) f2.readByte(); &#125; System.out.println(&quot;name：&quot; + p1Name); System.out.println(&quot;age：&quot; + f2.readInt()); System.out.println(&quot;第 1 个员工的信息：&quot;); f2.seek(0); &#x2F;&#x2F; 设置文件指针偏移量 String p2Name &#x3D; &quot;&quot;; for (int i &#x3D; 0; i &lt; 8; i++) &#123; p2Name +&#x3D; (char) f2.readByte(); &#125; System.out.println(&quot;name：&quot; + p2Name); System.out.println(&quot;age：&quot; + f2.readInt()); f2.close(); &#125;&#125;&#x2F;&#x2F; 员工类class Employee &#123; String name; &#x2F;&#x2F; 员工姓名 int age; &#x2F;&#x2F; 员工年龄 final static int LENGTH &#x3D; 8; &#x2F;&#x2F; 规定 name 为 8 个字符，方便读取。8 个字符 &#x3D; 8个汉字 &#x3D; 8个数字 &#x3D; 8个字母 public Employee(String name, int age) &#123; if (name.length() &gt; LENGTH) &#123; name &#x3D; name.substring(0, LENGTH); &#x2F;&#x2F; 超八位则截取 &#125; else &#123; while (name.length() &lt; LENGTH) &#123; name +&#x3D; &quot;\\u0000&quot;; &#x2F;&#x2F; 不足八位用空格代替 &#125; &#125; this.name &#x3D; name; this.age &#x3D; age; &#125;&#125; 流式部分在 Java 中，所有的 I/O 机制都是基于数据“流”方式完成的，而操作流的对象都封装到了 java.io 包中。 I/O 流的分类： 按操作数据的内容形态划分：字节流（InputStream、OutputStream）和字符流（Reader、Writer） 按流的功能流向划分：输入流（InputStream、Reader）和输出流（OutputStream、Writer） 1234public abstract class InputStream implements Closeable &#123; ... &#125;public abstract class OutputStream implements Closeable, Flushable &#123; ... &#125;public abstract class Reader implements Readable, Closeable &#123; ... &#125;public abstract class Writer implements Appendable, Closeable, Flushable &#123; ... &#125; 字节流类和字符流类的 API 大致相同 流属于资源，使用后要关闭之（记得擦屁股 - - !） 字符流字符流又叫做文本流，是用于操作字符数据的 I/O 流，==通常用来处理字符或字符串数据（汉字、多国语言等）==。 Reader 字符输入流 Writer 字符输出流 每个字节存放一个 ASCII 码，代表一个字符（而对于 Unicode 编码来说，每两个字节表示一个字符）。 1234567891011File file &#x3D; new File(&quot;C:&#x2F;Users&#x2F;bxm09&#x2F;Desktop&#x2F;test.txt&quot;);Writer out &#x3D; new FileWriter(file);out.write(&quot;hello world!&quot;);out.close();Reader in &#x3D; new FileReader(file);char[] accept &#x3D; new char[1024]; &#x2F;&#x2F; 此数组用于存放读取到的数据int len &#x3D; in.read(accept);System.out.println(new String(accept, 0, len)); &#x2F;&#x2F; 将字符数组转化为字符串in.close(); 字节流字节流又叫做二进制流，是用于操作字节数据的 I/O 流，==通常用来处理二进制数据（多媒体数据、网络传输数据等）==。 InputStream 字节输入流 OutputStream 字节输出流 字节流在输入输出时，与内存中的存储形式相同，以单个字节（Byte）为读写单位。用字节流来处理数据可以节省内存空间和转化时间，但一个字节并不代表一个字符，所以不能直接输出字符形式。 一般在操作文件流时，不管是字节流还是字符流，都可以按照如下的流程进行： 使用 File 类找到一个要操作的文件对象。 使用 File 类的对象去实例化字节流类或字符流类的子类 使用字节/字符的读写操作 关闭 IO 流资源 1234567891011121314File file = new File(\"C:/Users/bxm09/Desktop/test.txt\");// 写文件OutputStream out = new FileOutputStream(file);byte[] b = \"hello world!\".getBytes();out.write(b);out.close();// 读文件InputStream in = new FileInputStream(file);byte[] accept = new byte[1024]; // 此数组用于存放读取到的数据int len = in.read(accept);System.out.println(new String(accept, 0, len)); // 将字节数组转化为字符串in.close(); 文件流使用文件流可以将数据永久保存在文件中。 FileInputStream 字节文件输入流 FileOutputStream 字节文件输出流 FileReader 字符文件输入流 FileWriter 字符文件输出流 123456789101112131415161718192021222324252627&#x2F;&#x2F; 文件流初体验&#x2F;&#x2F; 使用 FileInputStream 向文件写入数据，然后使用 FileOutputStream 读取文件中的数据File file &#x3D; new File(&quot;hello.txt&quot;);&#x2F;&#x2F; 写文件try &#123; OutputStream out &#x3D; new FileOutputStream(file); out.write(&quot;HELLO WORLD&quot;.getBytes()); out.flush(); &#x2F;&#x2F; 记得擦屁股 out.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#x2F;&#x2F; 读文件try &#123; InputStream in &#x3D; new FileInputStream(file); byte[] data &#x3D; new byte[1024]; &#x2F;&#x2F; 用于存储读取到的数据 int len &#x3D; in.read(data); System.out.println(new String(data, 0, len)); in.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 缓冲流为了达到较高的转换效率，建议不要直接使用 InputStream、OutputStream 来进行读写，而应尽量使用缓冲流类来对数据进行缓存处理。 BufferedReader 字符缓冲输入流 BufferedWriter 字符缓冲输出流 InputStreamReader 字节缓冲输入流 OutputStreamWriter 字节缓冲输出流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#x2F;&#x2F; 缓冲流初体验，性能对比，复制一首歌曲public static void main(String[] args) throws IOException &#123; InputStream in &#x3D; new FileInputStream(&quot;爱我中华.mp3&quot;); &#x2F;&#x2F; 指定需要复制的文件路径 OutputStream out &#x3D; new FileOutputStream(&quot;爱我中华2.mp3&quot;); &#x2F;&#x2F; 指定文件复制后的输出路径 &#x2F;&#x2F; copyOfByte(in, out); &#x2F;&#x2F; 耗时18599毫秒 &#x2F;&#x2F; copyOfByteArray(in, out); &#x2F;&#x2F; 耗时40毫秒 copyOfBuffer(in, out); &#x2F;&#x2F; 耗时14毫秒&#125;&#x2F;&#x2F; 1. 使用字节读写private static void copyOfByte(InputStream in, OutputStream out) throws IOException &#123; long startTime &#x3D; System.currentTimeMillis(); int data &#x3D; 0; while (data !&#x3D; -1) &#123; data &#x3D; in.read(); &#x2F;&#x2F; read 方法返回 -1 表示要读的文件已经到了尽头 out.write(data); &#125; in.close(); out.flush(); out.close(); long endTime &#x3D; System.currentTimeMillis(); System.out.println(&quot;耗时&quot; + (endTime - startTime) + &quot;毫秒&quot;);&#125;&#x2F;&#x2F; 2. 使用字节数组读写private static void copyOfByteArray(InputStream in, OutputStream out) throws IOException &#123; long startTime &#x3D; System.currentTimeMillis(); byte[] bytes &#x3D; new byte[1024]; int data &#x3D; 0; while (data !&#x3D; -1) &#123; data &#x3D; in.read(bytes); out.write(bytes); &#125; in.close(); out.flush(); out.close(); long endTime &#x3D; System.currentTimeMillis(); System.out.println(&quot;耗时&quot; + (endTime - startTime) + &quot;毫秒&quot;);&#125;&#x2F;&#x2F; 3. 使用缓冲流来读写private static void copyOfBuffer(InputStream in, OutputStream out) throws IOException &#123; long startTime &#x3D; System.currentTimeMillis(); InputStream buffIn &#x3D; new BufferedInputStream(in); OutputStream buffOut &#x3D; new BufferedOutputStream(out); byte[] bytes &#x3D; new byte[1024]; int data; while ((data &#x3D; buffIn.read(bytes)) !&#x3D; -1) &#123; buffOut.write(bytes, 0, data); &#125; in.close(); out.flush(); out.close(); long endTime &#x3D; System.currentTimeMillis(); System.out.println(&quot;耗时&quot; + (endTime - startTime) + &quot;毫秒&quot;);&#125; 转换流字符流对字节流进行了包装，使其可以接受字符串的输入，字符流在输入时在其底层将字符转化为字节，读取时又将字节转化为字符。如果要将字节显示为字符，就需要用到字节与字符的转换。 InputStreamReader：字节输入流转为字符输入流 OutputStreamWriter：字节输出流转为字符输出流 12345&#x2F;&#x2F; 读取来自控制台的输入BufferedReader buffIn &#x3D; new BufferedReader(new InputStreamReader(System.in));BufferedWriter buffOut &#x3D; new BufferedWriter(new OutputStreamWriter(System.out));String readLine &#x3D; buffIn.readLine(); &#x2F;&#x2F; 读取键盘上输入的一整行字符 JDK 5 后的版本我们也可以使用 Java Scanner 类来获取控制台的输入。 管道流管道：将一个程序的输出当做另一个程序的输入。 管道流主要用于连接两个线程间的通讯。 管道流分为两组： 字节管道操作流：PipedInputStream、PipedOutputStream 字符管道操作流：PipedReader、PipedWriter 一个 PipedInputStream 对象必须和一个 PipedOutputStream 对象进行连接，才能产生一个通信管道。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.io.IOException;import java.io.PipedInputStream;import java.io.PipedOutputStream;&#x2F;&#x2F; 管道流public class Test &#123; public static void main(String[] args) throws Exception &#123; Sender sender &#x3D; new Sender(); Receiver receiver &#x3D; new Receiver(); PipedOutputStream out &#x3D; sender.getPipedOutputStream(); &#x2F;&#x2F; 返回各自的管道流 PipedInputStream in &#x3D; receiver.getPipedInputStream(); out.connect(in); &#x2F;&#x2F; 管道连接 new Thread(sender).start(); &#x2F;&#x2F; 启动线程 new Thread(receiver).start(); &#125;&#125;&#x2F;&#x2F; 消息发送方class Sender implements Runnable &#123; PipedOutputStream out &#x3D; new PipedOutputStream(); public PipedOutputStream getPipedOutputStream() &#123; return out; &#125; @Override public void run() &#123; String str &#x3D; &quot;hello world!&quot;; try &#123; out.write(str.getBytes()); out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;&#x2F;&#x2F; 消息接受方class Receiver implements Runnable &#123; PipedInputStream in &#x3D; new PipedInputStream(); public PipedInputStream getPipedInputStream() &#123; return in; &#125; @Override public void run() &#123; byte[] accept &#x3D; new byte[1024]; try &#123; int len &#x3D; in.read(accept); System.out.println(&quot;Receiver：&quot; + new String(accept, 0, len)); in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 打印流打印流是一个输出信息最方便的流类，==如果由程序向一个终端输出数据时，一定要使用打印流==。 打印流特点： 不抛出 IO 异常 自动刷新 打印流分为两组： 字节打印流：PrintStream 字符打印流：PrintWriter PrintStream 类提供了一系列重载的 print 和 println 方法，用来将基本数据类型的格式转换为字符串进行输出，对于一个非基本数据类型的对象，print 和 println 方法会默认调用对象的 toString 方法。 PrintStream 继承了 OutputStream类，并且实现了方法 write()，但是 write() 方法不经常使用，因为 print() 和 println() 方法用起来更为方便。 打印流使用的是“装饰设计模式”，即：将一个不是很完善的功能，添加一些代码后将其完善起来。 System.out.prinln 语句中的 System.out 就是 PrintStream 类的一个实例化对象。 12345678910&#x2F;&#x2F; 向屏幕输出信息PrintWriter out &#x3D; new PrintWriter(System.out);out.println(&quot;hello&quot;);out.close();&#x2F;&#x2F; 向文件输出信息File f &#x3D; new File(&quot;C:&#x2F;Users&#x2F;bxm09&#x2F;Desktop&#x2F;test.txt&quot;);PrintWriter out &#x3D; new PrintWriter(new FileWriter(f));out.println(&quot;hello&quot;);out.close(); 打印流的格式化输出类似C语言的 printf 函数，即用一些占位标记来暂时代替输出。 占位标记 含义 %s 字符串 %S 字符串（大写形式） %c 字符 %d 整数（十进制） %o 整数（八进制） %x 整数（十六进制） %X 整数（十六进制大写形式） %f 小数 %.nf 小数（限制小数位数） %e 科学计数法 %E 科学计数法（大写形式） %n 换行 %b 布尔值 1System.out.printf(&quot;字符串：%s，小数：%.2f&quot;, &quot;hello&quot;, 20.123); &#x2F;&#x2F; 字符串：hello，小数：20.12 内存操作流在内存中读写数据，而不是在文件中。此时，内存作为源和目的地。 内存操作流分为两组： 字节内存操作流：ByteArrayInputStream、ByteArrayOutputStream 字符内存操作流：CharArrayReade、CharArrayWriter 合并流（序列流）SequenceInputStream 类可以将多个输入流按顺序连接起来，也可以实现多个文件的合并操作。 1234567891011121314151617181920&#x2F;&#x2F; 两个文件的合并为一个文件File f1 &#x3D; new File(&quot;e:&#x2F;1.txt&quot;);File f2 &#x3D; new File(&quot;e:&#x2F;2.txt&quot;);File f3 &#x3D; new File(&quot;e:&#x2F;3.txt&quot;);FileInputStream in1 &#x3D; new FileInputStream(f1); &#x2F;&#x2F; 文件输入流FileInputStream in2 &#x3D; new FileInputStream(f2); &#x2F;&#x2F; 文件输入流SequenceInputStream s &#x3D; new SequenceInputStream(in1, in2); &#x2F;&#x2F; 将两个输入流合并为一个输入流FileOutputStream out &#x3D; new FileOutputStream(f3); &#x2F;&#x2F; 文件输出流int len;while ((len &#x3D; s.read()) !&#x3D; -1) &#123; out.write(len);&#125;in1.close();in2.close();out.close(); 对象流（对象序列化）对象序列化是指将内存中保存的对象转化为二进制数据流的形式的一种操作。通过对象序列化，可以方便的地实现对象的存储和读取。 对象反序列化就是使用 ObjectInputStream 类将序列化的对象读取出来。 在 Java 中，并不是所有类的对象都可以被序列化，会报NotSerializableException异常，只有实现了 java.io.Serializable 接口的类的对象可以被序列化，Serializable 接口中没有任何成员，是一个标识接口。 有两个类用于对象序列化操作： 对象输入流：ObjectInputStream 对象输出流：ObjectOutputStream transient 关键字阻止对象序列化 在默认情况下，当一个类的对象序列化时，会将这个类的所有属性都保存下来，如果不希望类中的某个属性被序列化，就需要加上 transient 关键字。 1234567891011121314151617181920212223242526272829303132333435363738394041public class Test &#123; public static void main(String[] args) throws Exception &#123; File file &#x3D; new File(&quot;.&#x2F;test&quot;); serializ(file); deserializ(file); &#125; &#x2F;&#x2F; 对象序列化：存储 private static void serializ(File file) throws Exception &#123; OutputStream out &#x3D; new FileOutputStream(file); ObjectOutputStream cout &#x3D; new ObjectOutputStream(out); cout.writeObject(new Person(&quot;白小明&quot;)); &#x2F;&#x2F; 写对象 cout.close(); &#125; &#x2F;&#x2F; 对象反序列化：读取 private static void deserializ(File file) throws Exception &#123; InputStream in &#x3D; new FileInputStream(file); ObjectInputStream cin &#x3D; new ObjectInputStream(in); Person p &#x3D; (Person) cin.readObject(); &#x2F;&#x2F; 读对象 System.out.println(p.getName()); &#x2F;&#x2F; null cin.close(); &#125;&#125;@SuppressWarnings(&quot;serial&quot;)class Person implements Serializable &#123; private transient String name; &#x2F;&#x2F; 该属性不想被序列化 public Person(String name) &#123; this.name &#x3D; name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://bxm0927.github.io/tags/Java/"},{"name":"IO","slug":"IO","permalink":"https://bxm0927.github.io/tags/IO/"}]},{"title":"Java 类集框架详细解读","date":"2018-07-11T05:48:05.000Z","path":"2018/07/11/Java-Collection/","text":"类集框架概述类集框架又叫做集合框架或集合类，是 Java 提供的一套性能优良、使用方便的接口和类，位于java.util包中。类集框架本质上是对基本的数据结构（线性表、树等）和算法（查找、排序等）的封装。 由于基本数据类型不能保存一系列的数据，对其进行扩展便形成了数组；又由于数组长度不可更改，缺乏灵活性，对数组进一步扩展便形成了功能更强大的“类集框架”。数组和类集框架都是一种“容器”，不同的是： 数组的长度时固定的，集合类的长度时可变的； 数组用来存放基本数据类型，集合类用来存储对象的引用，不能存储基本数据类型，存储的基本数据类型会进行自动类型转换。 12345678910// 集合类初体验public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); System.out.println(list.size()); // 2 System.out.println(list); // [1, 2] list.forEach(item -&gt; System.out.print(item + \" \")); // 1 2&#125; 类集框架体系结构类集框架最上层定义了两个接口，Collection 和 Map，Collection 叫做集合接口，每次只保存一个对象；Map 叫做映射接口，每次保存一对对象： 12public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; ... &#125;public interface Map&lt;K,V&gt; &#123; ... &#125; 在类集框架的类中，有一些是上层接口，有一些是抽象类（如：AbstractCollection、AbstractList、AbstractSet、AbstractMap等），提供了接口的部分实现，还有一些是具体实现类，这些类可以直接拿来使用。 123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; ... &#125;public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; ... &#125;public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; ... &#125; CollectionCollection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素。Collection 接口很少在开发中直接去使用，且没有直接实现它的标准类，通常都会用它的子接口 List 和 Set。 Collection 接口中定义的常用抽象方法： 方法 描述 int size() 类集中元素的个数 boolean add(Object obj) 将 obj 添加到类集中 boolean addAll(Collection c) 将 c 中的所有元素添加到类集中 boolean remove(Object obj) 从类集中删除 obj boolean removeAll(Collection c) 从类集中删除 c 中的所有元素 boolean retainAll(Collection c) 从类集中删除除了包含在 c 中的所有的元素 void clear() 清空类集中的元素 boolean contains(Object obj) obj 是否属于该类集 boolean containsAll(Collection c) c 中所有元素是否都属于该类集 boolean isEmpty() 类集是否为空 Object[] toArray() 将类集中的元素以数组的形式返回 Object[] toArray(Object array[]) 将类集中指定类型的元素以数组的形式返回 Iterator iterator() 调用类集的迭代器 ListList 接口是实现了 Collection 接口的子接口，是数据结构中的线性表的体现，List 接口下还有一些实现它的标准类：ArrayList、LinkedList，其中： ArrayList 是顺序表的体现 LinkedList 是链表的体现 123public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; ... &#125;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; ... &#125;public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; ... &#125; List 集合的特点是： List 集合中的元素允许重复 List 集合中存储的元素在逻辑上是有序的，因此能够通过索引来访问 List 中的元素，能够精确的控制每个元素插入的位置 List 接口对 Collection 接口进行了扩充，增加了一些方法： 方法 描述 Object set(int index, Object obj) 对列表中指定索引处的对象进行赋值 Object get(int index) 查找列表中指定索引处的对象（根据索引找对象） int indexOf(Object obj) 查找列表中 obj 第一次出现的索引，没有则返回 -1（根据对象找索引） int lastIndexOf(Object obj) 查找列表中 obj 最后一次出现的索引，没有则返回 -1（根据对象找索引） void add(int index, Object obj) 将 obj 插入到列表的 index 索引处（列表动态扩容） boolean addAll(int index, Collection c) 将 c 中的所有元素插入到列表的 index 索引处 Object remove(int index) 删除列表中指定索引处的对象（列表动态压缩） List subList(int start, int end) 返回一个子列表 ListIterator listIterator() 调用列表开始的迭代器 ListIterator listIterator(int index) 调用列表指定索引处开始的迭代器 ArrayList 可以这么说，Java 中最常用的两个类就是 String 和 ArrayList 了 ArrayList 是 List 接口的实现类，是数据结构中顺序表的体现，相当于一个动态数组（长度可变的数组）。ArrayList 的底层是Object[]，String 底层是 char[] 数组。 除了上层 List 给予的特性外，ArrayList 集合类还具有以下的特性： 允许有 null 元素 不同步，非线程安全 访问快（查找、遍历），时间复杂度是O(1)；更新慢（插入、删除），时间复杂度为O(n)。当 ArrayLIst 里有大量数据时，这时候去频繁插入或删除元素，会触发底层数组频繁拷贝，效率很低，还会造成内存空间的浪费。 ArrayList 类的构造方法： 123ArrayList(); &#x2F;&#x2F; 初始容量为 10ArrayList(int initialCapacity); &#x2F;&#x2F; 指定初始容量为 initialCapacity 大小ArrayList(Collection c); &#x2F;&#x2F; 由 c 中的元素初始化 注意：虽然初始化数组的长度是10，但是size是0，size是实际长度，并不是数组的容量 LinkedListLinkedList 是 List 接口的实现类，是数据结构中链表（双向循环链表）的体现。链表在物理存储上通常是非连续的，数据元素的逻辑顺序通过链表中的指针引用来实现。 除了上层 List 给予的特性外，LinkedList 集合类还具有以下的特性： 允许有 null 元素 不同步，非线程安全 访问慢（查找、遍历），更新快（插入、删除），因为插入和删除时不会触发底层数组的复制 LinkedList 类的构造方法： 12LinkedList(); &#x2F;&#x2F; 初始容量为 10LinkedList(Collection c); &#x2F;&#x2F; 由 c 中的元素初始化 12345678910111213141516&#x2F;&#x2F; LinkedList 初体验LinkedList&lt;Integer&gt; linkedList &#x3D; new LinkedList&lt;Integer&gt;();System.out.println(linkedList); &#x2F;&#x2F; []linkedList.addFirst(1); &#x2F;&#x2F; 这里会自动装箱 int -&gt; IntegerlinkedList.addFirst(2);linkedList.addLast(3);linkedList.addLast(4);System.out.println(linkedList); &#x2F;&#x2F; [2, 1, 3, 4]linkedList.removeFirst();linkedList.removeLast();System.out.println(linkedList); &#x2F;&#x2F; [1, 3]linkedList.set(1, 9527);System.out.println(linkedList.get(1)); &#x2F;&#x2F; 9527 SetSet 接口也是 Collection 接口的子接口，它并没有对 Collection 接口进行了扩充，而是完整的继承了 Collection 接口。Set 接口下也有一些实现它的标准类：HashSet、TreeSet、SortedSet。 123public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123; ... &#125;public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; ... &#125;public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable &#123; ... &#125; Set 集合的特点是： Set 集合中的元素不可重复 Set 集合中的元素是无序的的，因此不能通过索引来访问 Set 中的元素，但是删除和插入效率较高，因为插入和删除不会引起元素位置改变 HashSetHashSet 类使用哈希表实现了 Set 接口。 除了上层 Set 给予的特性外，HashSet 集合类还具有以下的特性： 允许有 null 元素，但最多只能一个 不同步，非线程安全 不保证元素的迭代顺序，同 HashMap 所谓无序，就是 Java 语言没有规定 HashSet 按什么顺序遍历。你应该知道，有好多种 Java 虚拟机，有的运行在Windows上，有的运行在 Linux上。即使在同一个平台上，也会有好几种虚拟机。每种虚拟机对 HashSet 的实现都是不一样的，所以每种虚拟机对 HashSet 的遍历顺序可能都不太一样。但对同一种虚拟机来说，你的遍历输出都是一样的。 Java 是跨平台的，你写的程序可能会在不同的平台上运行，这些平台上的虚拟机都是不一样的。如果你选用了 HashSet，就要明白，在不同的平台上，遍历顺序可能会不一样。如果你对遍历顺序有要求，就要考虑使用有序的，或排序的容器。 HashSet 类的构造方法： 1234HashSet(); &#x2F;&#x2F; 初始化一个哈希表HashSet(Collection c); &#x2F;&#x2F; 由 c 中的元素初始化HashSet(int capacity); &#x2F;&#x2F; 初始容量为 capacityHashSet(int capacity, float fillRatio); &#x2F;&#x2F; 初始容量为 capacity，填充比 fillRatio，默认 0.75 1234567891011121314&#x2F;&#x2F; HashSet 初体验HashSet&lt;String&gt; hs &#x3D; new HashSet&lt;String&gt;();hs.add(&quot;F&quot;);hs.add(&quot;C&quot;);hs.add(&quot;B&quot;);hs.add(&quot;E&quot;);hs.add(&quot;D&quot;);hs.add(&quot;A&quot;);System.out.println(hs.size()); &#x2F;&#x2F; 6System.out.println(hs.add(&quot;C&quot;)); &#x2F;&#x2F; falsehs.remove(&quot;C&quot;);System.out.println(hs.add(&quot;C&quot;)); &#x2F;&#x2F; trueSystem.out.println(hs); &#x2F;&#x2F; [A, B, C, D, E, F] TreeSetTreeSet 类使用树（二叉树）实现 了Set 接口。 除了上层 Set 给予的特性外，TreeSet 集合类还具有以下的特性： 对象默认按升序存储，检索很快 适用于存储大量需要检索的信息 TreeSet 类的构造方法： 1234TreeSet(); &#x2F;&#x2F; 初始化一个空的 TreeSetTreeSet(Collection c); &#x2F;&#x2F; 由 c 中的元素初始化TreeSet(Comparator comp); &#x2F;&#x2F; 通过比较器（Comparator）自定义比较规则TreeSet(SortedSet ss); TreeSet 类扩充的方法： first()：返回第一个元素 last()：返回最后一个元素 1234567891011&#x2F;&#x2F; TreeSet 初体验TreeSet&lt;String&gt; ts &#x3D; new TreeSet&lt;&gt;();ts.add(&quot;1&quot;);ts.add(&quot;3&quot;);ts.add(&quot;2&quot;);ts.add(&quot;C&quot;);ts.add(&quot;a&quot;);ts.add(&quot;B&quot;);System.out.println(ts.first()); &#x2F;&#x2F; 1System.out.println(ts); &#x2F;&#x2F; [1, 2, 3, B, C, a] SortedSetSortedSet 类也实现了 Set 接口，保存有序的集合。 QueueQueue 接口是数据结构中队列的实现，与 List、Set 同一级别，都是继承了 Collection 接口。LinkedList 类实现了 Queue 接口。 队列有两个基本操作：在队列尾部加入一个元素（入队），和从队列头部移除一个元素（出队） 方法 描述 boolean add(E e) 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常 boolean offer(E e) 添加一个元素并返回true，如果队列已满，则返回false E remove() 移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 E poll() 移除并返问队列头部的元素，如果队列为空，则返回null E element() 返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 E peek() 返回队列头部的元素，如果队列为空，则返回null MapMap 叫做映射接口，它存储的是一系列形如&lt;K, V&gt;的“键值对”元素，提供 key 到 value 的映射，通过 key 就能找到对应的 value，key 必须是唯一的，value 可以相同。 Map 接口下也有一些实现它的标准类：HashMap、TreeMap、SortedMap 等 123public interface Map&lt;K,V&gt; &#123; ... &#125;public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; ... &#125;public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; ... &#125; Map 接口中常用的方法： 方法 描述 int size() 返回“键值对”的个数 Object get(Object k) 通过 key 获取 value Object put(Object k, Object v) 添加一对对象到映射中，同时改写原来 key 所对应 value（如果存在的话） Object putAll(Map m) 将映射 m 添加到调用的映射中 void remove(Object k) 删除关键字为 k 的那一对对象 void clear() 清空映射 boolean containsKey() 映射中是否存在该 key boolean containsValue() 映射中是否存在该 value boolean isTmpty() 映射是否为空 Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() 将 Map 变为 Collection 返回 Set&lt;k&gt; keySet() 得到键的“类集视图” Collection values() 得到值的“类集视图” 需要注意的是，Map 并不属于 Collection，他们没有任何亲缘关系。但可以通过一些方法获得映射的类集视图：entrySet()、keySet() 和 values()，“类集视图”是将映射集成到类集框架内的手段。 HashMapHashMap 类使用哈希表实现 Map 接口 HashMap 集合类的特点： 允许有 null 元素，但 key 最多有一个 null，value 不限制 不同步，非线程安全 更新快（插入、删除元素） 不保证元素的迭代顺序，同 HashSet HashMap 类的构造方法： 1234HashMap(); &#x2F;&#x2F; 初始化一个散列映射HashMap(Map m); &#x2F;&#x2F; 由 m 中的元素初始化HashMap(int capacity); &#x2F;&#x2F; 初始容量为 capacityHashMap(int capacity, float fillRatio); &#x2F;&#x2F; 初始容量为 capacity，填充比 fillRatio，默认 0.75 12345678910111213141516171819HashMap&lt;String, Double&gt; hm &#x3D; new HashMap&lt;&gt;();System.out.println(hm); &#x2F;&#x2F; &#123;&#125;hm.put(&quot;苹果&quot;, 19.8);hm.put(&quot;橘子&quot;, 15.0);hm.put(&quot;香蕉&quot;, 13.5);hm.put(&quot;香蕉&quot;, 14.5); &#x2F;&#x2F; 修改元素System.out.println(hm); &#x2F;&#x2F; &#123;苹果&#x3D;19.8, 香蕉&#x3D;14.5, 橘子&#x3D;15.0&#125;&#x2F;&#x2F; 将 Map 转换为 SetSet&lt;Entry&lt;String, Double&gt;&gt; set &#x3D; hm.entrySet();Iterator&lt;Entry&lt;String, Double&gt;&gt; it &#x3D; set.iterator();while (it.hasNext()) &#123; Map.Entry&lt;String, Double&gt; entry &#x3D; (Map.Entry&lt;String, Double&gt;) it.next(); System.out.println(entry); &#x2F;&#x2F; 苹果&#x3D;19.8 香蕉&#x3D;14.5 橘子&#x3D;15.0 System.out.println(entry.getKey()); System.out.println(entry.getValue());&#125; TreeMapTreeMap 类使用树（二叉树）来实现 Map 接口。 TreeMap 集合类的特点： key 和 value 都不允许有 null 元素 元素按升序排序 更新和访问的效率不如 HashMap TreeMap 类的构造方法： 1234TreeMap(); &#x2F;&#x2F; 初始化一个空的树映射TreeMap(Comparator comp); &#x2F;&#x2F; 通过比较器（Comparator）自定义比较规则TreeMap(Map m); &#x2F;&#x2F; 由 m 中的元素初始化TreeMap(sortedMap sm); &#x2F;&#x2F; 由 sm 中的元素初始化 1234567891011121314151617181920TreeMap&lt;String, Double&gt; tm &#x3D; new TreeMap&lt;String, Double&gt;();System.out.println(tm); &#x2F;&#x2F; &#123;&#125;tm.put(&quot;苹果&quot;, 19.8);tm.put(&quot;橘子&quot;, 15.0);tm.put(&quot;香蕉&quot;, 13.5);Set&lt;String&gt; set &#x3D; tm.keySet();Iterator&lt;String&gt; it &#x3D; set.iterator();while (it.hasNext()) &#123; String string &#x3D; (String) it.next(); System.out.println(string);&#125;Collection&lt;Double&gt; coll &#x3D; tm.values();Iterator&lt;Double&gt; it2 &#x3D; coll.iterator();while (it2.hasNext()) &#123; Double double1 &#x3D; (Double) it2.next(); System.out.println(double1);&#125; SortedMapSortedMap 类也实现了 Map 接口，使 Key 保持在升序排列。 Map.Entry 接口java.util.Map.Entry 接口描述了在一个 Map 中的一个元素（键/值对），其中有两个重要的方法： getKey() getValue() Collection 的输出和遍历迭代器 IteratorIterator 是标准的类集输出方式。 迭代器（Iterator）是一种设计模式，Java 把它封装成了一个接口，利用这个接口的迭代方法iterator()可以实现类集的遍历。 每一个 Collection 接口的标准实现类都提供一个迭代方法iterator()，调用这个方法返回一个该类集的迭代器（类似 C 语言中的指针），用来遍历该类集的每一个元素。 Iterator 接口定义如下： 12345public interface Iterator&lt;E&gt; &#123; public boolean hasNext(); public E next(); public void remove();&#125; hasNext：判断是否有下一个元素 next：取得下一个元素 remove：删除当前元素（需要先通过next取得元素） 使用迭代方法的步骤： 调用该类集的iterator()方法获取该类集的迭代器 hasNext()为真就进行迭代 使用next()取得元素 123456789List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(&quot;hello&quot;);list.add(&quot;Java&quot;);Iterator&lt;String&gt; iterator &#x3D; list.iterator();while (iterator.hasNext()) &#123; String elem &#x3D; iterator.next(); System.out.println(elem);&#125; 双向迭代器 ListIterator双向迭代器 ListIterator 扩展了迭代器 Iterator，增加了一些方法，允许双向遍历类集，并且可以修改元素 注意：完成反向遍历前，需要先进行正向遍历，让迭代器（指针）指向类集尾部 方法 描述 void add(Object obj) 将 obj 插入到列表 void set(Object obj) 将 obj 赋给当前元素 void remove() 删除当前元素 boolean hasNext() 是否有下一个元素 boolean hasPrevious() 是否有上一个元素 boolean next() 取得下一个元素 boolean previous() 取得上一个元素 boolean nextIndex() 取得下一个元素的索引 boolean previousIndex() 取得上一个元素的索引 12345678910111213141516171819ArrayList&lt;String&gt; al &#x3D; new ArrayList&lt;String&gt;();al.add(&quot;a&quot;);al.add(&quot;b&quot;);al.add(&quot;c&quot;);System.out.println(al);ListIterator&lt;String&gt; listIt &#x3D; al.listIterator(); &#x2F;&#x2F; 返回该类集的双向迭代器 listIt&#x2F;&#x2F; 正向遍历while (listIt.hasNext()) &#123; String string &#x3D; (String) listIt.next(); listIt.set(string + &quot;-set&quot;); &#x2F;&#x2F; 修改元素&#125;&#x2F;&#x2F; 反向遍历while (listIt.hasPrevious()) &#123; String string &#x3D; (String) listIt.previous(); System.out.println(string); &#x2F;&#x2F; c-set b-set a-set&#125; 枚举迭代 EnumerationEnumeration 属于最古老的输出接口之一，==尽管没有被废弃，但是已经被迭代器 Iterator 所取代。== 若要取得 Enumeration 的对象，只能依靠 Vector 类。 Enumeration 接口定义如下： 1234public interface Enumeration&lt;E&gt; &#123; public boolean hasMoreElements(); public E nextElement();&#125; 12345678910Vector&lt;String&gt; al &#x3D; new Vector&lt;String&gt;();al.add(&quot;a&quot;);al.add(&quot;b&quot;);al.add(&quot;c&quot;);Enumeration&lt;String&gt; en &#x3D; al.elements();while (en.hasMoreElements()) &#123; String string &#x3D; (String) en.nextElement(); System.out.println(string);&#125; for、foreach、forEach 输出foreach 不仅可以用来遍历数组，也可以用来遍历集合类。 12345678910111213List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(&quot;hello&quot;);list.add(&quot;Java&quot;);&#x2F;&#x2F; 普通 foreachfor (String elem : list) &#123; System.out.println(elem);&#125;&#x2F;&#x2F; Java 8 Lambda 表达式list.forEach(item -&gt; &#123; System.out.println(item);&#125;); Map 的输出和遍历 遍历技巧：如果需要在遍历过程中增加元素，可以新建一个临时map存放新增的元素，等遍历完毕，再把临时map放到原来的map中 遍历集合类有多种方法，从最早的 Iterator，到 Java 5 支持的 foreach ，再到 Java 8 的 Lambda 表达式，让我们一起来看下具体的用法以及各自的优缺点： entrySet()可以同时拿到key和value，这一种也是最常用的遍历方法，==推荐使用==。 12345678Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(&quot;name&quot;, &quot;白小明&quot;);map.put(&quot;sex&quot;, &quot;男&quot;);for (Map.Entry&lt;String, String&gt; string : map.entrySet()) &#123; System.out.println(string.getKey()); System.out.println(string.getValue());&#125; keySet()、values()如果只需要map的key或者value，用map的keySet或values方法无疑是最方便的。 1234567891011Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(&quot;name&quot;, &quot;白小明&quot;);map.put(&quot;sex&quot;, &quot;男&quot;);for (String string : map.keySet()) &#123; System.out.println(string);&#125;for (String string : map.values()) &#123; System.out.println(string);&#125; keySet()、get(key)可以同时拿到key和value，但性能不及上一种，不推荐使用 12345678Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(&quot;name&quot;, &quot;白小明&quot;);map.put(&quot;sex&quot;, &quot;男&quot;);for (String string : map.keySet()) &#123; System.out.println(string); System.out.println(map.get(string));&#125; IteratorMap 接口中没有迭代器iterator()方法，需要先用 entrySet() 等转成集合才行。 使用 Iterator 的 remove 方法删除元素非常便捷，如果需要在遍历过程中删除元素推荐使用Iterator。 123456789101112Map&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(\"name\", \"白小明\");map.put(\"sex\", \"男\");Set&lt;Map.Entry&lt;String, String&gt;&gt; set = map.entrySet();Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = set.iterator();while (it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = (Map.Entry&lt;String, String&gt;) it.next(); System.out.println(entry.getKey() + \" = \" + entry.getValue()); // it.remove(); // 删除元素&#125; Java 8 Lambda 表达式Java 8 提供了 Lambda 表达式支持，语法看起来更简洁，可以同时拿到key和value，不过，经测试，性能低于 entrySet 1234567Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(&quot;name&quot;, &quot;白小明&quot;);map.put(&quot;sex&quot;, &quot;男&quot;);map.forEach((key, value) -&gt; &#123; System.out.println(key + &quot; &#x3D; &quot; + value);&#125;); 关于 Map 遍历的一个简单的性能测试用100万条数据，做了一个简单性能测试，该测试结果仅供参考 1234567891011121314151617181920212223242526272829303132333435private static int sum;public static void main(String[] args) &#123; Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;(); for (int i &#x3D; 0; i &lt; 1000000; i++) &#123; map.put(i, 1); &#125; entrySet(map); &#x2F;&#x2F; 29 31 31 lambda(map); &#x2F;&#x2F; 204 202 238&#125;private static void entrySet(Map&lt;Integer, Integer&gt; map) &#123; long start &#x3D; System.currentTimeMillis(); for (Map.Entry&lt;Integer, Integer&gt; integer : map.entrySet()) &#123; sum +&#x3D; integer.getKey() + integer.getValue(); &#125; long end &#x3D; System.currentTimeMillis(); System.out.println(end - start);&#125;private static void lambda(Map&lt;Integer, Integer&gt; map) &#123; long start &#x3D; System.currentTimeMillis(); map.forEach((key, value) -&gt; &#123; sum +&#x3D; key + value; &#125;); long end &#x3D; System.currentTimeMillis(); System.out.println(end - start);&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://bxm0927.github.io/tags/Java/"},{"name":"Collection","slug":"Collection","permalink":"https://bxm0927.github.io/tags/Collection/"},{"name":"List","slug":"List","permalink":"https://bxm0927.github.io/tags/List/"},{"name":"Set","slug":"Set","permalink":"https://bxm0927.github.io/tags/Set/"},{"name":"Map","slug":"Map","permalink":"https://bxm0927.github.io/tags/Map/"},{"name":"集合类","slug":"集合类","permalink":"https://bxm0927.github.io/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"},{"name":"类集框架","slug":"类集框架","permalink":"https://bxm0927.github.io/tags/%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6/"}]},{"title":"Java 异常处理详细解读","date":"2018-07-10T02:35:58.000Z","path":"2018/07/10/Java-Exception/","text":"异常概述异常（Exception）指的是所有可能造成计算机无法正常处理的情况。发生异常时，将阻止程序的运行，若不妥善处理异常，可能造成计算机死机。经过异常处理，可以保证程序的正常运行，我们把针对不同的异常做妥善的处理的方式叫做“异常处理机制”。 异常处理的目的：加强程序的健壮性、安全性。 Java 中，所有的异常都被封装到相应的类中，同时，用户也可以自定义异常类和自定义抛出异常。 抛出异常（throw）：是指将异常提交给运行时系统的过程。 捕获异常（catch）：是指运行时系统找到发生异常的方法的过程。 异常类 Throwable异常类是指由程序抛出的异常对象所属的类。 异常可以分为两大类：java.lang.Exception类和java.lang.Error类。这两个类均继承自 java.lang.Throwable 类 Error 类通常指的是 JVM 出错和线程死锁，用户无法在程序中处理（无法捕获） Exception 类通常指的是可以处理的异常，分为编译时异常和运行时异常（RuntimeException），编译时异常是 Exception 下除了运行时异常以外的所有异常 对于编译时异常，不解决编译就不会通过 对于运行时异常，可以选择性地来进行处理，如果不处理则出现异常时将交给 JVM 默认处理 获取异常信息的方法 Java 中常见的异常类 异常 描述 NullPointerException 空指向异常（空指针异常）。指的是使用了一个未初始化的对象（未开辟内存空间的对象）。 ArithmeticException 算术异常。如：除以零 ArrayIndexOutOfBoundsException 数组下标越界异常。数组的索引超过了上界或下界 FileNotFoundException 文件未找到异常 OutOfMemoryExceptin 内存溢出异常（内存不足异常）。可用内存不足以分配给一个对象时抛出 NoSuchElementExceptin 调用了类集中不存在的元素 ClassCastExceptin 对象与类集中的元素不兼容 UnsupportedOperationExceptin 修改一个不允许修改的对象 异常处理 try-catch-finally 死了都要 try，不 try 到 catch 不痛快 当发生异常时，通常有两种处理方法： 交给 Java 默认的异常处理机制做处理。这种情况 Java 会输出异常信息，然后中断程序的运行 自己编写 try-catch-finally 来捕获异常。这种情况可以灵活的控制程序，而且程序不会中断运行。 异常处理的语法： 12345678try &#123; &#x2F;&#x2F; 要检查的语句&#125; catch (异常类 e) &#123; &#x2F;&#x2F; 异常发生时的处理语句 e.printStackTrace(); &#x2F;&#x2F; 打印异常信息&#125; finally &#123; &#x2F;&#x2F; 一定会运行到的语句&#125; try 语句块不可以独立存在，必须与 catch 或 finally 同存，finally 语句块可以省略 catch 区块可以有多个，此时异常类型必须子类在前，父类在后 当 try 区块捕获到异常时，不执行接下来的语句，立即进入 catch 区块 finally 语句块不会被执行的情况 在 finally 语句块中发生了异常 在前面的代码中使用了 System.exit() 退出程序 程序所在的线程死亡 CPU 关闭 异常处理的几种形式try…catch try…catch…finally try…finally 向上抛出异常 throws方法头中使用 throws 关键字可以表明这个方法可能存在的异常类型，此方法不处理异常，而是将该异常提交给调用这个方法的方法。 123456789101112131415public class Test &#123; public static void main(String[] args) &#123; int[] arr &#x3D; new int[5]; try &#123; setZero(arr, 10); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;end&quot;); &#125; public static void setZero(int[] arr, int index) throws ArrayIndexOutOfBoundsException &#123; arr[index] &#x3D; 0; &#125;&#125; 自行抛出异常 throwthrows用于方法声明中，声明一个方法会抛出哪些异常，而throw是方法体中实际执行抛出异常的动作。 1throw 异常类型的实例 12345try &#123; throw new ArrayIndexOutOfBoundsException(&quot;我是异常信息&quot;);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 自定义异常类当系统提供的异常类不足以满足业务需求时，我们可以自定义异常类 123class 自定义异常类 extends 异常类型 &#123;&#125; 12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; try &#123; throw new MyException(&quot;我是自定义异常类&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class MyException extends Exception &#123; private String msg; public MyException(String msg) &#123; this.msg &#x3D; msg; &#125; @Override public String toString() &#123; return &quot;MyException [msg&#x3D;&quot; + msg + &quot;]&quot;; &#125;&#125; 异常处理的经验之谈 不要忽略异常 只针对异常的情况才使用异常 优先使用标准异常，而不是直接在方法上 throws Exception 或 Throwable 每个方法抛出的异常都应该有文档 处理运行时异常时，采用逻辑规避同时辅助try-catch处理 在多重catch块后面，可以加上一个catch(Exception)来处理被遗漏的异常 对于不确定的代码，也可以加上try-catch，处理潜在的异常 尽量去处理异常，切忌只是简单的调用printStackTrace()去打印输出 尽量添加finally去释放占用的资源 具体如何处理异常，要根据不同的业务需求和异常类型去决定","tags":[{"name":"Java","slug":"Java","permalink":"https://bxm0927.github.io/tags/Java/"},{"name":"Exception","slug":"Exception","permalink":"https://bxm0927.github.io/tags/Exception/"},{"name":"异常处理","slug":"异常处理","permalink":"https://bxm0927.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"Markdown 入门详细教程","date":"2018-06-26T00:53:05.000Z","path":"2018/06/26/md/","text":"Markdown 简介 Markdown 中文官网：http://www.markdown.cn 【简明版】有道云笔记Markdown指南：http://note.youdao.com/iyoudao/?p=2411 【进阶版】有道云笔记Markdown指南：http://note.youdao.com/iyoudao/?p=2445 Markdown 是一种简单、易读易写的「标记语言」，用来写博客、做笔记非常方便，通常为程序员群体所用。 Markdown 的语法十分简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。用户可以使用一些标记符号以最小的输入代价生成极富表现力的文档（譬如您正在阅读的这份文档就是通过 Markdown 书写的）。 安利一波 Markdown 工具 注意：不同平台的 Markdown 语法会有些许差别。 Markdown 编辑器（支持实时同步预览）： VSCode Sublime + Markdown 插件（MarkdownPreview） Markdown 在线编辑器： CSDN 博客：https://blog.csdn.net 简书：https://www.jianshu.com 马克飞象：https://maxiang.io 作业部落：https://www.zybuluo.com/mdeditor 笔记工具： 有道云笔记：https://note.youdao.com 印象笔记：https://www.yinxiang.com 为知笔记：http://www.wiz.cn OneNote：https://www.onenote.com Markdown 基本语法Markdown 的标记语法非常之多，并且不同平台的 Markdown 语法会有些许差别，但是常用的标记符号不超过十个，且平台间基本通用。 常用标记：标题、粗体、斜体、删除线、下划线、高亮、引用、分割线、链接与图片 不常用标记：列表、待办事项、表格、代码高亮、流程图、序列图、甘特图、数学公式 标题 image 粗体和斜体 image 引用 image 链接与图片 image 分割线 image 列表 image 待办事项 image 表格 image 代码高亮： image 流程图 image 甘特图 image Markdown 使用技巧表情可以在 HTML、Markdown 中使用下面的表情，微软自带的输入法可以输入这些表情： 📦 🚀 🐠 ✂️ 🔥 🚨 ✏️ 🛠 💅 👌 ✨ 💯 ⚛️ 📄 目录有道云支持 Markdown 目录，使用 [TOC] 控制图片大小和位置123&lt;div align&#x3D;&quot;center&quot;&gt; &lt;img width&#x3D;&quot;65&quot; height&#x3D;&quot;75&quot; src&#x3D;&quot;&quot;&#x2F;&gt;&lt;&#x2F;div&gt; 图文混排12345678910111213&lt;img align&#x3D;&quot;right&quot; src&#x3D;&quot;&quot;&#x2F;&gt;这是一个示例图片。图片显示在 N 段文字的右边。N 与图片高度有关。刷屏行。刷屏行。到这里应该不会受影响了，本行应该延伸到了图片的正下方，所以我要足够长才能确保不同的屏幕下都看到效果。 在表格单元格里换行借助于 HTML 里的 &lt;br /&gt; 实现。 123| Header1 | Header2 ||---------|----------------------------------|| item 1 | 1. one&lt;br &#x2F;&gt;2. two&lt;br &#x2F;&gt;3. three | 老子今天不加班.mp31&lt;audio controls&#x3D;&quot;controls&quot; autoplay&#x3D;&quot;true&quot; src&#x3D;&quot;https:&#x2F;&#x2F;oijmns1ch.qnssl.com&#x2F;antiwork_today.mp3&quot;&gt;&lt;&#x2F;audio&gt;","tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://bxm0927.github.io/tags/Markdown/"},{"name":"有道云笔记","slug":"有道云笔记","permalink":"https://bxm0927.github.io/tags/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0/"}]},{"title":"可能是最详细的 Hexo + GitHub Pages 搭建个人博客的教程","date":"2018-06-24T14:00:37.000Z","path":"2018/06/24/hexo-github-blog/","text":"前言 个人博客地址：www.lovebxm.com如果您在搭建的过程中遇到无法解决的问题，可与我交流探讨，QQ：80583600 我们为什么要写博客？一方面写博客可以用来监督自己，阶段性总结归纳所学的知识点，进而达到学以致用的目的；另一方面在于分享精神，在分享与交流的过程中，你的语言表达能力会逐渐变得简洁清晰，而且带有很强的逻辑性。 所以说，写博客是一个好习惯，希望大家能够坚持下来。最近刚好有空，就把自己个人博客搭建的全过程记录下来，希望能够帮助到一些朋友。当然了，搭建个人博客的方式有很多，比如自己写前后端、WordPress、Jekyll等等，这里我是用的是免费开源、简洁高效的“Hexo + GitHub Pages”来搭建。 大概流程如下： 搭建 Node.js 环境 搭建 Git 环境 GitHub 注册和配置 Hexo 安装 Hexo 配置 关联 Hexo 与 GitHub 将 GitHub Pages 地址解析到个人域名 Hexo 常规操作 结束语 搭建 Node.js 环境 为什么要搭建 Node.js 环境？ —- 因为 Hexo 博客系统是基于 Node.js 编写的，要运行在 Node.js 环境之上。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。 Node.js 的包管理器 npm（node package manager），是全球最大的开源库生态系统，安装 Node.js 时会自动安装 npm。我们之后要通过 npm 来安装 Hexo。 在 Node.js 官网：https://nodejs.org/en/ 下载最新稳定版，安装时保持默认设置即可，一路Next，安装很快就结束了。 最后，打开命令提示符，输入 node -v、npm -v，出现版本号则说明 Node.js 环境配置成功，第一步完成！！！ 搭建 Git 环境 为什么要搭建 Git 环境？ —- 因为需要把本地的网页和文章等资源提交到远程Git仓库（GitHub）上。 Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 在 Git 官网：https://git-scm.com/ 下载安装包，安装过程如下： 桌面右键，打开 Git Bush Here，输入 git --version，出现版本号则说明 Git 环境配置成功，第二步完成！！！ GitHub 注册和配置GitHub 是什么？GitHub 又名 GayHub，全球最大的同性交友网站。 （哈哈哈，开个玩笑 ^_^）实际上，GitHub 是一个代码托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。我们的博客最终是托管在 GitHub 上的。 Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 提供的域名 github.io 或者自定义域名来发布站点。 首先，我们需要在 Github 官网进行注册：https://github.com image 然后，创建仓库：Repository name 使用自己的用户名，每个用户只能建立一个，仓库名规则（注意：yourname 必须是你的用户名）： 1yourname&#x2F;yourname.github.io 比如我的仓库是这样创建的： 最后，访问 https://yourname.github.io，比如我的是 https://bxm0927.github.io，如果可以正常访问，那么 Github 的配置已经结束了，第三步完成！！！ 至此，搭建 Hexo 个人博客的前置环境配置已经完成，下面开始讲解 Hexo 搭建个人博客的核心操作。 Hexo 安装什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架，默认使用 Markdown 解析文章，在几秒内，即可利用靓丽的主题生成静态网页，只需一条指令即可部署到 GitHub Pages 或其他网站。 强烈建议读者花20分钟去读一读 Hexo 的官方文档：https://hexo.io/zh-cn/ 使用 npm 安装 Hexo（在这之前，请确保你已经成功安装了Node.js和Git）： 1npm install hexo-cli -g 然后你将会看到下图所示信息，可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。 查看Hexo的版本，hexo version，正确输出如下信息则代表 Hexo 安装成功。 Hexo 配置安装 Hexo 完成后，执行下列命令来初始化 Hexo，用户名改成你自己的（我的是bxm0927），Hexo 将会在指定文件夹中新建博客系统所需要的文件。 12345hexo init bxm0927.github.iocd bxm0927.github.ionpm install 新建完成后，目录如下（不同的版本可能目录有些不一样）： 1234567891011.├── .deploy # 需要部署的文件├── node_modules # Hexo依赖├── public # 生成的静态网页文件├── scaffolds # 模板，当您新建文章时，Hexo 会根据 scaffold 来建立文件。├── source # 博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts # 草稿| └── _posts # 文章├── themes # 主题，Hexo 会根据主题来生成各种各样的静态页面。├── _config.yml # 全局配置文件，您可以在此配置大部分的参数。└── package.json # npm 依赖配置文件 然后，在本地运行 Hexo：hexo server或hexo s 您的网站会在 http://localhost:4000 下启动，如果能够正常访问（如下图），则说明 Hexo 博客系统已经搭建起来了，但是目前只是在本地哦，别人是看不到的。 在下面步骤中，我们要把这个本地博客系统部署到 Github 上，让外网的人能够访问到你的博客。 常见问题：执行hexo server提示找不到该指令解决办法：在 Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：npm install hexo -server –save 关联 Hexo 与 GitHub 这一步对于不熟悉GitHub的朋友来说可能有些繁琐，慢慢来，不要着急~ 配置 SSH 生成 SSH 首先，使用SSH让本地Git项目与远程的GitHub建立起连接，方便传输文件。执行下面命令生成SSH公私钥，一路回车（记得输入你自己的邮箱地址哦~）： 1ssh-keygen -t rsa -C &quot;80583600@qq.com&quot; 添加 SSH Key 到 GitHub 用记事本打开 C:\\Users\\bxm09\\.ssh\\id_rsa.pub，此文件里面内容为刚才生成的公公钥，准确的复制这个文件的内容，粘贴到 https://github.com/settings/ssh 的“new SSH key”中 测试 输入下面的命令，看看SSH是否配置成功，git@github.com的部分不要修改： 1ssh -T git@github.com 如果是下面的反馈： 123The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes&#x2F;no)? 不要紧张，输入yes就好，然后会看到： 1Hi aierui! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 配置 Git 个人信息现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理。 输入下面的代码进行个人信息的设置（把名称和邮箱替换成你自己的）： 12git config --global user.name &quot;bxm0927&quot;git config --global user.email &quot;80583600@qq.com&quot; 配置 Deployment在_config.yml文件中，找到Deployment，然后按照如下修改： 注意：1. 用户名改成你自己的，2. 冒号后面记得空一格 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.htmldeploy: type: git repo: git@github.com:bxm0927&#x2F;bxm0927.github.io.git branch: master 将本地文件提交到 GitHub Pages 来了来了来了~ 1234567891011121314# 本地预览hexo s# 删除旧的静态文件，即 public 文件hexo clean# 生成新的静态文件，即 public 文件（或者 hexo g）hexo generate# 部署到远程站点，即 GitHub（或者 hexo d）hexo deploy# 当然你也可以执行下面的组合命令hexo d -g 在浏览器中输入 https://bxm0927.github.io （用户名改成你自己的），可以正常访问则说明 Hexo 与 GitHub 已经成功关联了，哇哇哇哇哇哇，开心死你了，不要忘了回来给我点赞哟 ~ 常见问题 若上面操作失败，则需要提前安装一个扩展： 1npm install hexo-deployer-git --save 如果在执行 hexo d 后,出现 error deployer not found:github 的错误（如下），则是因为没有设置好 public key 所致，重新详细设置即可。 1234Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 怎么避免 Markdown 文件（.md）被解析？ Hexo 原理就是在执行hexo generate时会在本地先把博客生成的一套静态html页面，然后放到public文件夹中，再执行hexo deploy时将其复制到.deploy文件夹中。 Github 通常建议同时附上README.md项目说明文档，但是 hexo 默认情况下会把所有 Markdown 文件（.md）文件解析成html文件，所以即使你在线生成了 README. md，它也会在你下一次部署时被删去。 那么怎么解决呢？ 在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。 将 GitHub Pages 地址解析到个人域名 其实当上一步结束之后，我们的博客也基本上完成了，能发博文，别人也能够通过外网域名访问到你的站点，但是~ 看着博客的域名是GitHub的二级域名，总有一种寄人篱下的感觉，为了让这个小窝看起来更加正式，我们可以花几十块钱去买一个自己的域名，然后将其绑定自己的域名上，进行该绑定过程，其实就是一个重定向的过程。这里我使用的是阿里云的万网域名服务： 在 GitHub 仓库的根目录下建立一个 CNAME 的文本文件(注意：没有扩展名)，文件里面只能输入一个你的域名，不能加http:// 1www.xxx.com 注意到时候CNAME一定是在你Github项目的master根目录下，你也可以建立一个CNAME的文本文件，放到Hexo–&gt;public目录下，因为到时候同步上去的是这个public文件夹。 进入阿里云域名解析地址，添加解析： 记录类型选择CNAME 主机记录填www 解析线路选择默认 记录值填yourname.github.io TTL值为10分钟 再添加一个解析，记录类型A 主机记录填www 解析线路选择默认 记录值填你GitHub 的ip地址（在cmd中ping：） 1ping bxm0927.github.com 点击保存，等 1 分钟，访问下你自己的域名，一切就ok了。 域名绑定成功，域名解析成功，因此你在浏览中输入 www.lovebxm.com，或 lovebxm.com 就可以访问到博客了，输入 bxm0927.github.io 会重定向到 www.lovebxm.com。过程：www 的方式，会先解析成 http://xxxx.github.io，然后根据 CNAME 再变成 www 注意：CNAME文件在下次 hexo deploy的时候就消失了，需要重新创建，这样就很繁琐 方法一：每次 hexo d 之后，就去 GitHub 仓库根目录新建 CNAME文件 方法二：在 hexo g 之后， hexo d 之前，把CNAME文件复制到 “\\public&quot; 目录下面，里面写入你要绑定的域名。 方法三（推荐）：将需要上传至github的内容放在source文件夹，例如CNAME、favicon.ico、images等，这样在 hexo d 之后就不会被删除了。 方法四：通过安装插件实现永久保留 1$ npm install hexo-generator-cname --save 之后在_config.yml中添加一条 12plugins:- hexo-generator-cname 需要注意的是：如果是在github上建立的CNAME文件，需要先clone到本地，然后安装插件，在deploy上去即可。CNAME只允许一个域名地址。 注意1：每次生成的 CNAME 都是 yoursite.com 怎么解决？ 修改 _config.yml 1234url: http:&#x2F;&#x2F;www.lovebxm.comroot: &#x2F;permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;permalink_defaults: Hexo 常规操作发表一篇文章运行下面的命令创建一个新文章文件，然后，会在本地博客文件夹 source\\_posts 文件夹下我们可以看到新建的 markdown 文件。 1hexo new &quot;文章标题&quot; 文章编辑好之后，可以执行本地预览、部署等命令： 1234567891011121314# 本地预览hexo s# 删除旧的静态文件，即 public 文件hexo clean# 生成新的静态文件，即 public 文件（或者 hexo g）hexo generate# 部署到远程站点，即 GitHub（或者 hexo d）hexo deploye# 当然你也可以执行下面的组合命令hexo d -g 显示部分文章内容如果在博客文章列表中不想全文显示，可以在文章中增加 &lt;!-- more --&gt;, 在这后面的内容就不会显示在列表。 1&lt;!-- more --&gt; 更改主题 官方主题库：https://hexo.io/themes/ 有哪些好看的 Hexo 主题？：https://www.zhihu.com/question/24422335 Hexo主题非常丰富，hexo3.0使用的默认主题是landscape，我推荐搭建使用 Next 为主题，好看且文档详细。详情请阅读 Next 的官方文档（ http://theme-next.iissnan.com/ ），5 分钟快速安装。 再提示一点，大家可以修改一步就hexo s在本地看下效果。 添加插件添加 feed 插件和 sitemap 网站地图，有助于 SEO。 切换到你本地的 hexo 目录 ，输入以下命令 12npm install hexo-generator-feed -savenpm install hexo-generator-sitemap -save 修改 _config.yml，增加以下内容 123456789101112# ExtensionsPlugins:- hexo-generator-feed- hexo-generator-sitemap#Feed Atomfeed: type: atom path: atom.xml limit: 20#sitemapsitemap: path: sitemap.xml 再执行以下命令，部署到远端： 1hexo d -g 配完之后，就可以访问 https://bxm0927.github.io/atom.xml 和 https://bxm0927.github.io/sitemap.xml ，发现这两个文件已经成功生成了。 添加404 页面GitHub Pages 自定义404页面非常容易，直接在根目录下创建自己的404.html就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo s在本机调试也是不起作用的。 其实，404页面可以做更多有意义的事，来做个404公益项目吧。 推荐使用腾讯公益404 http://www.qq.com/404/ ： 12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;404&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;br&gt;&lt;!--&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt; &lt;title&gt;公益404 | 不如&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;#404 Not found By Bruce&lt;h1&gt;404 Page Not Found&lt;&#x2F;h1&gt;--&gt;&lt;br&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.qq.com&#x2F;404&#x2F;search_children.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;&lt;br&gt;&lt;!--公益404介接入地址益云公益404 http:&#x2F;&#x2F;yibo.iyiyun.com&#x2F;Index&#x2F;web404腾讯公益404 http:&#x2F;&#x2F;www.qq.com&#x2F;404失蹤兒童少年資料管理中心404 http:&#x2F;&#x2F;404page.missingkids.org.tw--&gt;&lt;br&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 复制上面代码，贴粘到目录下新建的404.html即可！ 我的404页面配置如下： 12345678910111213141516&lt;html&gt;&lt;head&gt; &lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8;&quot;&#x2F;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge,chrome&#x3D;1&quot; &#x2F;&gt; &lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;all&quot; &#x2F;&gt; &lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;index,follow&quot;&#x2F;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;www.qq.com&#x2F;404&#x2F;search_children.js&quot; charset&#x3D;&quot;utf-8&quot; homePageUrl&#x3D;&quot;gdutxiaoxu.github.io&quot; homePageName&#x3D;&quot;回到我的主页&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 多PC同步管理博客很多人可能家里一台笔记本，公司一个台式机，想两个同时管理博客，同时达到备份的博客主题、文章、配置的目的。下面就介绍一下用github来备份博客并同步博客。 A电脑备份博客内容到github 配置.gitignore文件。进入博客目录文件夹下，找到此文件，用sublime text 打开，在最后增加两行内容/.deploy_git和/public 初始化仓库。 在博客根目录下，在git bash下依次执行git init和git remote add origin 为远程仓库地址。 同步到远程仓库。 gitbash下依次执行以下命令 12345git add . #添加目录下所有文件git commit -m &quot;更新说明&quot; #提交并添加更新说明git push -u origin master #推送更新到远程仓库 B电脑拉下远程仓库文件 在B电脑上同样先安装好node、git、ssh、hexo，然后建好hexo文件夹，安装好插件，（然后选做：将备份到远程仓库的文件及文件夹删除），然后执行以下命令： 1234567git initgit remote add origin &lt;server&gt;git fetch --allgit reset --hard origin&#x2F;master 发布博客后同步 在B电脑发布完博客之后，记得将博客备份同步到远程仓库执行以下命令： 1234567git add .#可以用git master 查看更改内容git commit -m &quot;更新信息&quot;git push -u origin master #以后每次提交可以直接git push 平时同步管理每次想写博客时，先执行：git pull进行同步更新。发布完文章后同样按照上面的 发布博客后同步 同步到远程仓库。 中文乱码问题在 md 文件中写中文内容，发布出来后为乱码，原因是 md 的编码不对，将 md 文件另存为UTF-8编码的文件即可解决问题。 结束语建站的系统有很多，如： Hexo + GitHub Pages Jekyll + GitHub Pages WordPress + 服务器 + 域名 DeDeCMS + 服务器 + 域名 … 使用 Hexo + GitHub Pages 建站，有优点也有缺点： GitHub Pages 不支持数据库管理，所以你只能做静态页面的博客，不能像其他博客（如 WordPress）那样通过数据库管理自己的博客内容。 但是，GitHub Pages 无需购置服务器，免服务器费的同时还能做负载均衡，github pages有300M免费空间。 个人博客真的有必要用数据库吗？答案是否定的。博客静态化，评论记录使用第三方的 网易云跟帖 就可以了。静态的博客更有利于搜索引擎蜘蛛爬取，轻量化的感觉真的很好。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，非常符合我的口味。Markdown 真的是专门针对程序员开发的语言啊，现在感觉没有 Markdown 什么都不想写。什么富文本编辑器，什么word，太麻烦了！而且样式都好丑！效率太低！ 推荐几个很好用的在线 Markdown 编辑器： 作业部落：https://www.zybuluo.com/mdeditor 马克飞象：https://maxiang.io 推荐一个图床：极简图床 + chrome 插件 + 七牛空间，七牛云储存提供10G的免费空间,以及每月10G的流量，存放个人博客外链图片最好不过了，七牛云储存还有各种图形处理功能、缩略图、视频存放速度也给力（非打广告）。 以上。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://bxm0927.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://bxm0927.github.io/tags/github/"},{"name":"blog","slug":"blog","permalink":"https://bxm0927.github.io/tags/blog/"},{"name":"搭建个人博客","slug":"搭建个人博客","permalink":"https://bxm0927.github.io/tags/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"blog-hexo","date":"2013-07-13T12:46:25.000Z","path":"2013/07/13/blog/","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 ✂️ Build Setup前置条件： Node.js (Should be at least nodejs 6.9) Git 12345678910111213141516171819# install Hexo$ npm install hexo-cli -g# Create a new Hexo folder.$ hexo init &lt;blog-name&gt;$ cd &lt;blog-name&gt;$ npm install# Start the server.$ hexo server# Generate static files.$ hexo generate # hexo g# Deploy your website.$ hexo deploy # hexo d# One-click deployment$ hexo generate --deploy # hexo g -d ✏️Q&amp;A","tags":[{"name":"HTML","slug":"HTML","permalink":"https://bxm0927.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://bxm0927.github.io/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://bxm0927.github.io/tags/JS/"}]}]